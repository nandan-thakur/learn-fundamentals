[
    {
        "id": "core-java-mastery",
        "category": "Programming",
        "title": "Core Java Mastery Handbook",
        "subtitle": "A comprehensive, end-to-end guide to Core Java covering language fundamentals, object-oriented principles, memory management, exception handling, multithreading, I/O, modern Java features, reflection, and essential design patterns.",
        "icon": "☕",
        "stats": {
            "sections": 7,
            "topics": 40,
            "difficulty": "Beginner to Advanced"
        },
        "sections": [
  {
    "id": "section-1",
    "title": "Java Basics",
    "topics": [
      {
        "id": "s1-1-1",
        "title": "JVM (Java Virtual Machine)",
        "explanations": {
          "english": "JVM (Java Virtual Machine) ek abstract computing machine hai jo Java bytecode execute karne ke liye runtime environment provide karta hai. Ye compiled Java code aur underlying hardware ke beech mein ek intermediary ki tarah kaam karta hai, bytecode ko native machine instructions mein translate karta hai interpretation ya Just-In-Time (JIT) compilation ke through. JVM platform independence ensure karta hai by operating system differences ko abstract karke, jisse Java programs kisi bhi device pe compatible JVM implementation ke saath run kar sake. Ye critical runtime operations manage karta hai jaise memory allocation, garbage collection, security enforcement, aur thread synchronization. JVM architecture samajhna application performance optimize karne aur complex runtime issues debug karne ke liye essential hai."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "JVM runtime environment provide karta hai jo kisi bhi platform pe Java bytecode execute kar sakta hai",
          "Ye code execution ke liye interpretation aur JIT compilation ka combination use karta hai",
          "JVM hardware differences ko abstract karke Java ki 'write once, run anywhere' capability enable karta hai",
          "Key components mein classloader, runtime data areas, aur execution engine shaamil hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-1-2",
        "title": "JRE (Java Runtime Environment)",
        "explanations": {
          "english": "Java Runtime Environment (JRE) ek software package hai jo Java applications run karne ke liye necessary libraries, Java Virtual Machine (JVM), aur other components provide karta hai. Isme core classes, supporting files, aur JVM implementation shaamil hai jo compiled Java bytecode execute karne ke liye required hain. JRE mein development tools jaise compilers ya debuggers nahi hote, isliye ye end-users ke liye suitable hai jo sirf Java programs run karna chahte hain. Isme essential libraries jaise Java Class Library (JCL) hoti hai jo collections, concurrency, networking, aur GUI development ke liye utilities provide karti hai. Jab aap Java application users ko distribute karte hain, toh unke system pe typically sirf JRE installed hona chahiye successful execution ke liye."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "JRE Java applications run karne ke minimum requirements provide karta hai bina development capabilities ke",
          "Isme JVM, core libraries, aur supporting configuration files shaamil hain",
          "JRE end-users ke liye target kiya gaya hai jabki JDK developers ke liye hai",
          "Isme compilers, debuggers, ya other development tools nahi hote"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-1-3",
        "title": "JDK (Java Development Kit)",
        "explanations": {
          "english": "Java Development Kit (JDK) ek comprehensive software development environment hai jo Java applications, applets, aur components build karne ke liye use hota hai. Isme Java Runtime Environment (JRE), Java compiler (javac), debugger, documentation generator (javadoc), archiver (jar), aur development ke liye necessary other tools shaamil hain. JDK developers ko allow karta hai ki wo Java source code likhe, compile kare, aur debug kare bytecode mein jo JVM execute kar sakta hai. Isme development libraries aur APIs bhi hain jo JRE mein available core functionality ko extend karte hain. Development environment setup karte waqt, correct JDK version install karna first essential step hai taaki language features aur libraries ke saath compatibility ensure ho sake."
        },
        "code": {
          "title": "Basic JDK Commands",
          "language": "bash",
          "content": "# Compile Java source file\njavac HelloWorld.java\n\n# Run compiled Java program\njava HelloWorld\n\n# Generate documentation\njavadoc -d docs HelloWorld.java\n\n# Create JAR archive\njar cvf app.jar HelloWorld.class"
        },
        "codeExplanations": {
          "english": "Ye commands essential JDK tools demonstrate karti hain: javac .java files ko .class bytecode mein compile karta hai, java command bytecode ko JVM pe execute karta hai, javadoc HTML API documentation generate karta hai source comments se, aur jar compiled classes ko archive files mein package karta hai distribution ke liye."
        },
        "keyPoints": [
          "JDK JRE ka superset hai jo development tools jaise compiler aur debugger include karta hai",
          "Javac compiler Java source code ko platform-independent bytecode mein transform karta hai",
          "JDK documentation, archiving, aur monitoring tools provide karta hai Java applications ke liye",
          "Different JDK versions different Java language features aur APIs support karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-1-4",
        "title": "JVM Architecture (High-level)",
        "explanations": {
          "english": "JVM architecture teen main components se milkar bana hai jo saath mein kaam karke Java programs efficiently execute karte hain. Class Loader Subsystem class files ko memory mein load karta hai loading, linking, aur initialization phases ke through. Runtime Data Areas mein Method Area, Heap, Java Stacks, PC Registers, aur Native Method Stacks shaamil hain jahan execution ke dauraan data store hota hai. Execution Engine mein Interpreter, JIT Compiler, aur Garbage Collector hain jo bytecode ko machine code mein translate karte hain aur memory manage karte hain. Ye modular design JVM ko allow karta hai ki adaptive optimization techniques ke through performance optimize kare jabki strict security aur memory safety guarantees maintain rakhe."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "Class Loader Subsystem classes ke loading, linking, aur initialization ko handle karta hai",
          "Runtime Data Areas memory ko method area, heap, stacks, aur registers mein divide karta hai",
          "Execution Engine bytecode interpret karta hai ya native code mein compile karta hai JIT use karke",
          "Garbage Collector automatically heap memory manage karta hai unreachable objects remove karke"
        ],
        "extras": {
          "flowDiagram": "┌─────────────────────────────────────┐\n│         Class Loader                │\n│  Loading → Linking → Initialization │\n└──────────────┬──────────────────────┘\n               ↓\n┌─────────────────────────────────────┐\n│       Runtime Data Areas            │\n│  Method Area | Heap | Stacks | PC   │\n└──────────────┬──────────────────────┘\n               ↓\n┌─────────────────────────────────────┐\n│       Execution Engine              │\n│  Interpreter | JIT Compiler | GC    │\n└─────────────────────────────────────┘",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-1-5",
        "title": "Java Compilation & Execution Flow",
        "explanations": {
          "english": "Java compilation aur execution flow human-readable source code ko running applications mein transform karta hai multi-stage process ke through. Pehle, Java compiler (javac) lexical analysis, parsing, aur semantic checking perform karta hai platform-independent bytecode generate karke .class files mein store karta hai. Runtime ke dauraan, Class Loader dynamically in class files ko JVM memory areas mein load karta hai. Phir Bytecode Verifier loaded code ko security violations aur type safety ke liye validate karta hai execution se pehle. Finally, Execution Engine ya toh bytecode ko line-by-line interpret karta hai ya frequently used code ko native machine code mein compile karta hai JIT compiler use karke improved performance ke liye."
        },
        "code": {
          "title": "Compilation and Execution Process",
          "language": "java",
          "content": "// Source file: HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n// Step 1: Compile\n// javac HelloWorld.java\n// Generates: HelloWorld.class (bytecode)\n\n// Step 2: Execute\n// java HelloWorld\n// Output: Hello, World!"
        },
        "codeExplanations": {
          "english": "Ye example complete workflow dikhata hai: .java source file mein human-readable code hota hai jo javac compile karta hai platform-independent bytecode mein .class file mein. Phir java command JVM launch karta hai, class load karta hai, aur main method execute karta hai output produce karne ke liye."
        },
        "keyPoints": [
          "Java source code (.java) javac compiler se bytecode (.class) mein compile hota hai",
          "Bytecode platform-independent hai aur kisi bhi JVM implementation pe run kar sakta hai",
          "Class loading dynamic hai, runtime pe hoti hai compile time ke bajaye",
          "JIT compilation frequently executed bytecode ko native machine code mein convert karta hai speed ke liye"
        ],
        "extras": {
          "flowDiagram": "HelloWorld.java → [javac] → HelloWorld.class → [Class Loader] → [Bytecode Verifier] → [Execution Engine] → Output",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-2-1",
        "title": "Primitive Data Types",
        "explanations": {
          "english": "Java mein primitive data types data manipulation ke fundamental building blocks hain jo simple values directly memory mein store karte hain. Java eight primitives define karta hai: byte (8-bit), short (16-bit), int (32-bit), long (64-bit) integers ke liye; float (32-bit) aur double (64-bit) floating-point numbers ke liye; char (16-bit Unicode) characters ke liye; aur boolean true/false values ke liye. Reference types ke unlike, primitives objects nahi hain aur unke paas methods ya fields nahi hain, jisse ye memory-efficient aur processing mein fast hote hain. Har primitive ka fixed size hai regardless of platform, different JVM implementations mein consistent behavior ensure karta hai. Har primitive ki range aur memory footprint samajhna performance optimize karne aur overflow errors prevent karne ke liye crucial hai."
        },
        "code": {
          "title": "Primitive Type Declarations",
          "language": "java",
          "content": "// Integer types\nbyte byteVal = 127;\nshort shortVal = 32767;\nint intVal = 2147483647;\nlong longVal = 9223372036854775807L;\n\n// Floating point types\nfloat floatVal = 3.14f;\ndouble doubleVal = 3.14159265359;\n\n// Other primitives\nchar charVal = 'A';\nboolean boolVal = true;"
        },
        "codeExplanations": {
          "english": "Ye code Java mein all eight primitive types ke declaration aur initialization demonstrate karta hai. Notice karein 'L' suffix long literals ke liye aur 'f' suffix float literals ke liye required hain correct type specify karne ke liye. Default integer literals ko int treat kiya jaata hai, aur floating-point literals ko double."
        },
        "keyPoints": [
          "Java mein 8 primitive types hain: byte, short, int, long, float, double, char, boolean",
          "Primitives values directly stack memory mein store karte hain, jisse ye efficient hote hain",
          "Har primitive ka specific bit-width aur range hai jo platform-independent hai",
          "Primitives null values support nahi karte aur unke paas methods ya properties nahi hote"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Type|Size|Range\nbyte|8-bit|-128 to 127\nshort|16-bit|-32,768 to 32,767\nint|32-bit|-2^31 to 2^31-1\nlong|64-bit|-2^63 to 2^63-1\nfloat|32-bit|IEEE 754\nchar|16-bit|0 to 65,535 (Unicode)\nboolean|JVM dependent|true or false",
          "examples": []
        }
      },
      {
        "id": "s1-2-2",
        "title": "Reference Data Types",
        "explanations": {
          "english": "Java mein reference data types memory addresses (references) store karte hain jo objects ki taraf point karte hain, na ki actual data values khud. Primitives ke unlike, reference types mein classes, interfaces, arrays, aur enums shaamil hain, jo 'new' keyword se create hote hain aur heap memory mein store hote hain. Jab aap ek reference variable doosre ko assign karte hain, toh dono variables same object ko memory mein point karte hain, matlab ek reference ke through changes doosre ko bhi affect karte hain. Reference types null ho sakte hain, indicating ki wo currently kisi object ko point nahi kar rahe. Ye types inheritance, polymorphism, aur encapsulation support karte hain, Java mein object-oriented programming ka foundation form karte hain."
        },
        "code": {
          "title": "Reference Type Usage",
          "language": "java",
          "content": "// Class reference\nString name = new String(\"Java\");\n\n// Array reference\nint[] numbers = new int[5];\n\n// Interface reference\nRunnable task = new Runnable() {\n    public void run() {\n        System.out.println(\"Running\");\n    }\n};\n\n// Null reference\nString empty = null;"
        },
        "codeExplanations": {
          "english": "Ye example different reference types dikhata hai: String ek class reference hai jo heap mein string object ki taraf point karta hai, arrays special reference types hain jo multiple values hold karte hain, interfaces ko implementing classes ke liye reference types ki tarah use kiya ja sakta hai, aur null represent karta hai reference jo kisi object ko point nahi kar raha."
        },
        "keyPoints": [
          "Reference types heap-allocated objects ki taraf point karne wale memory addresses store karte hain",
          "Isme classes, interfaces, arrays, aur enums shaamil hain",
          "Multiple references same object ko point kar sakte hain, state share karke",
          "Reference types null ko default value ke roop mein support karte hain aur methods aur inheritance support karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-2-3",
        "title": "Variable Declaration & Initialization",
        "explanations": {
          "english": "Java mein variable declaration mein data type specify karna hota hai uske baad variable name, jo memory space reserve karta hai aur variable ki scope aur type constraints establish karta hai. Initialization declared variable ko initial value assign karta hai, jo declaration ke same line pe ho sakta hai ya code mein baad mein. Local variables ko use karne se pehle explicitly initialize karna padta hai, jabki instance variables automatically default values receive kar lete hain. Java same type ke multiple variables ko single statement mein comma se separate karke declare karta hai support karta hai. Naming convention mein camelCase required hai variables ke liye, lowercase letter se start hokar, aur constants uppercase mein underscores ke saath use hote hain."
        },
        "code": {
          "title": "Variable Declaration Examples",
          "language": "java",
          "content": "// Declaration and initialization\nint age = 25;\nString name = \"John\";\n\n// Declaration only, initialization later\ndouble salary;\nsalary = 50000.00;\n\n// Multiple declarations\nint x = 1, y = 2, z = 3;\n\n// Constants\nfinal double PI = 3.14159;\nfinal int MAX_USERS = 100;"
        },
        "codeExplanations": {
          "english": "Code different declaration patterns demonstrate karta hai: combined declaration aur initialization, baad mein assignment ke liye separate declaration aur initialization, ek statement mein multiple variables, aur final keyword use karke constant declaration jo reassignment prevent karta hai."
        },
        "keyPoints": [
          "Variables use karne se pehle type aur name declare karna padta hai; local variables initialization require karte hain",
          "Instance variables default values receive karte hain (0, false, ya null) agar initialize nahi kiye gaye toh",
          "Final keyword constants create karta hain jo initialization ke baad modify nahi ho sakte",
          "Same type ke multiple variables ek statement mein declare kiye ja sakte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-2-4",
        "title": "Type Casting (Implicit vs Explicit)",
        "explanations": {
          "english": "Java mein type casting values ko ek data type se doosre compatible type mein convert karta hai jab possible ho. Implicit casting (widening) automatically occur hota hai jab smaller type se larger type mein convert karte hain, jaise int se long ya float se double, kyunki koi data loss nahi hoti. Explicit casting (narrowing) require karta hai ki programmer target type parentheses mein specify kare jab larger se smaller type mein convert karte hain, jaise double se int, jo data loss ya truncation cause kar sakta hai. Reference type casting allow karta hai objects ko different types ki tarah treat karna inheritance hierarchy mein, instanceof checks ke saath ClassCastException avoid karne ke liye recommended hai. Casting rules samajhna runtime errors prevent karne aur data integrity maintain karne ke liye essential hai."
        },
        "code": {
          "title": "Type Casting Examples",
          "language": "java",
          "content": "// Implicit casting (widening)\nint intVal = 100;\nlong longVal = intVal;\ndouble doubleVal = longVal;\n\n// Explicit casting (narrowing)\ndouble price = 99.99;\nint intPrice = (int) price; // Truncates to 99\n\n// Casting with potential data loss\nlong bigNumber = 10000000000L;\nint smallNumber = (int) bigNumber; // Overflow\n\n// Reference casting\nObject obj = \"Hello\";\nString str = (String) obj;"
        },
        "codeExplanations": {
          "english": "Ye code implicit casting dikhata hai jahan compiler automatically smaller types ko larger ones mein convert karta hai. Explicit casting manual conversion demonstrate karta hai decimal values ke truncation ya large numbers ke overflow ke potential ke saath. Reference casting allow karta hai general Object ko specific String type ki tarah treat karna."
        },
        "keyPoints": [
          "Implicit casting (widening) automatically smaller se larger compatible types mein hota hai",
          "Explicit casting (narrowing) require karta hai syntax (targetType) value aur data loss cause kar sakta hai",
          "Incompatible types ke beech casting compilation ya runtime errors result kar sakta hai",
          "Reference casting se pehle hamesha object types instanceof se verify karein taaki exceptions prevent ho sakein"
        ],
        "extras": {
          "flowDiagram": "byte → short → int → long → float → double\n        char ↗",
          "comparisonTable": "Casting Type|Direction|Syntax|Data Loss\nImplicit|Widening|auto|No\nExplicit|Narrowing|(type) value|Possible",
          "examples": []
        }
      },
      {
        "id": "s1-2-5",
        "title": "Scope of Variables",
        "explanations": {
          "english": "Java mein variable scope define karta hai program ke us region ko jahan variable visible aur accessible hai, uski lifetime aur accessibility rules determine karta hai. Local variables jo methods ya blocks ke andar declare hote hain sirf un braces ke andar exist karte hain aur block exit hone pe destroy ho jaate hain. Instance variables object instances ko belong karte hain aur throughout the class accessible hote hain, object ke exist karne tak exist karte hain. Class variables (static) class khud ko belong karte hain aur all instances ke beech share hote hain, program ke duration tak persist karte hain. Parameters ka method scope hota hai, sirf method signature aur body mein accessible. Scope samajhna naming conflicts prevent karne, memory efficiently manage karne, aur encapsulation control karne ke liye zaroori hai."
        },
        "code": {
          "title": "Variable Scope Demonstration",
          "language": "java",
          "content": "public class ScopeDemo {\n    // Instance variable\n    int instanceVar = 10;\n    \n    // Class variable\n    static int staticVar = 20;\n    \n    public void method(int param) { // Parameter scope\n        int localVar = 30; // Local variable\n        \n        if (true) {\n            int blockVar = 40; // Block scope\n            System.out.println(blockVar);\n        }\n        // blockVar not accessible here\n        System.out.println(localVar + param);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye example different scopes illustrate karta hai: instanceVar har object instance ke liye exist karta hai, staticVar all instances mein share hota hai, param throughout the method accessible hai, localVar method body mein exist karta hai, aur blockVar if-statement block mein restricted hai aur uske bahar inaccessible hai."
        },
        "keyPoints": [
          "Local variables sirf unke declared block ya method mein exist karte hain",
          "Instance variables throughout the class accessible hote hain aur object ke saath exist karte hain",
          "Static variables class ko belong karte hain aur all instances mein share hote hain",
          "Variables unke scope ke bahar access nahi kiye ja sakte, naming conflicts prevent karke"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Scope Type|Declaration|Lifetime|Access\nLocal|Inside block/method|Block execution|Within block only\nInstance|Inside class, outside methods|Object lifetime|Throughout class\nStatic|With static keyword|Program duration|Via class name or instance\nParameter|Method signature|Method execution|Within method only",
          "examples": []
        }
      },
      {
        "id": "s1-3-1",
        "title": "Arithmetic Operators",
        "explanations": {
          "english": "Java mein arithmetic operators numeric operands pe mathematical calculations perform karte hain, addition (+), subtraction (-), multiplication (*), division (/), aur modulo (%) shaamil hain. Division operator integer division perform karta hai jab dono operands integers hote hain, decimal portion truncate karke, lekin floating-point division jab koi operand float ya double ho. Modulo operator division ka remainder return karta hai, cyclic operations ya divisibility check karne mein useful. Compound assignment operators (+=, -=, *=, /=, %=) arithmetic operations ko assignment ke saath combine karte hain concise code ke liye. Operator precedence standard mathematical rules follow karta hai, multiplication aur division addition aur subtraction se pehle evaluate hote hain unless parentheses order override karein."
        },
        "code": {
          "title": "Arithmetic Operations",
          "language": "java",
          "content": "int a = 10, b = 3;\n\nint sum = a + b;        // 13\nint diff = a - b;       // 7\nint product = a * b;    // 30\nint quotient = a / b;   // 3 (integer division)\nint remainder = a % b;  // 1\n\n// Compound assignment\na += 5;  // a = 15\na *= 2;  // a = 30\n\n// Division with doubles\ndouble result = 10.0 / 3; // 3.333..."
        },
        "codeExplanations": {
          "english": "Ye code basic arithmetic operations demonstrate karta hai integer division truncate karta hai results (10/3=3), jabki doubles involve karne se precise decimal results aate hain. Compound assignment operators variables ko in place modify karte hain, a = a + 5 ke equivalent lekin zyada concise."
        },
        "keyPoints": [
          "Integer division decimal results truncate karti hai; precision ke liye floating-point types use karein",
          "Modulo operator % remainder return karta hai aur cyclic patterns ke liye useful hai",
          "Compound assignment operators arithmetic ko assignment ke saath combine karte hain (+=, -=, etc.)",
          "Division by zero integers ke liye ArithmeticException throw karta hai lekin doubles ke liye Infinity return karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "Checking even/odd: number % 2 == 0",
            "Cycling through array: index = (index + 1) % array.length"
          ]
        }
      },
      {
        "id": "s1-3-2",
        "title": "Relational Operators",
        "explanations": {
          "english": "Java mein relational operators do operands compare karte hain aur boolean value return karte hain jo unke beech relationship indicate karta hai. Equality operators == aur != check karte hain ki values equal hain ya nahi, primitives aur references dono ke saath kaam karte hain, lekin reference comparison memory addresses check karta hai content ki jagah. Ordering operators mein less than (<), greater than (>), less than or equal to (<=), aur greater than or equal to (>=) shaamil hain, jo sirf numeric types aur characters pe applicable hain. Ye operators conditional logic, loop control, aur sorting algorithms ka foundation form karte hain. Reference types ko content equality ke liye compare karte waqt equals() method use karein == ki jagah taaki memory addresses compare na hoon."
        },
        "code": {
          "title": "Relational Comparisons",
          "language": "java",
          "content": "int x = 5, y = 10;\n\nboolean isEqual = (x == y);        // false\nboolean notEqual = (x != y);       // true\nboolean lessThan = (x < y);        // true\nboolean greaterThan = (x > y);     // false\nboolean lessOrEqual = (x <= 5);    // true\n\n// Reference comparison\nString s1 = new String(\"Hi\");\nString s2 = new String(\"Hi\");\nboolean refEqual = (s1 == s2);     // false\nboolean valueEqual = s1.equals(s2); // true"
        },
        "codeExplanations": {
          "english": "Example relational operators dikhata hai primitive values aur references compare karte hain. Note karein ki == objects ke liye reference addresses compare karta hai, content nahi, isliye s1 == s2 false hai despite same text. Logical string comparison ke liye hamesha equals() use karein."
        },
        "keyPoints": [
          "Relational operators operand comparison pe based boolean values return karte hain",
          "== aur != sab types ke saath kaam karte hain lekin references ke liye memory addresses compare karte hain",
          "Ordering operators (<, >, <=, >=) sirf numeric types aur chars ke saath kaam karte hain",
          "Objects ke content comparison ke liye equals() method use karein, == nahi"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Operator|Meaning|Example|Result\n==|Equal to|5 == 5|true\n!=|Not equal|5 != 3|true\n>|Greater than|5 > 3|true\n<|Less than|5 < 3|false\n>=|Greater or equal|5 >= 5|true\n<=|Less or equal|3 <= 5|true",
          "examples": []
        }
      },
      {
        "id": "s1-3-3",
        "title": "Logical Operators",
        "explanations": {
          "english": "Java mein logical operators boolean expressions combine karke complex conditional logic form karte hain, boolean operands pe operate karke boolean results produce karte hain. Logical AND (&&) sirf true return karta hai jab dono operands true hain, jabki logical OR (||) true return karta hai agar kam se kam ek operand true ho. Logical NOT (!) boolean value invert karta hai, true ko false aur false ko true mein convert karke. Short-circuit evaluation && aur || ke saath occur karta hai, matlab second operand sirf tab evaluate hota hai jab zaroori ho, performance improve karta hai aur potential errors jaise null pointer exceptions prevent karta hai. Logical operators decision-making, validation logic, aur multiple conditions ke based program flow control ke liye essential hain."
        },
        "code": {
          "title": "Logical Operations",
          "language": "java",
          "content": "boolean a = true, b = false;\n\nboolean and = a && b;  // false\nboolean or = a || b;   // true\nboolean not = !a;       // false\n\n// Short-circuit evaluation\nString text = null;\nif (text != null && text.length() > 0) {\n    // Safe: text.length() never called if text is null\n}\n\n// Complex condition\nint age = 25;\nboolean valid = (age >= 18) && (age <= 65);"
        },
        "codeExplanations": {
          "english": "Ye code logical AND, OR, aur NOT operations demonstrate karta hai. Short-circuit example dikhata hai kaise && NullPointerException prevent karta hai agar text null hai toh text.length() evaluate nahi karta. Complex conditions multiple relational checks combine karte hain logical operators use karke."
        },
        "keyPoints": [
          "&& (AND) sirf tab true return karta hai jab dono operands true hain",
          "|| (OR) true return karta hai agar koi bhi operand true ho",
          "! (NOT) boolean value invert karta hai",
          "Short-circuit evaluation unnecessary operand evaluation skip karta hai, errors prevent karke"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "A|B|A && B|A || B|!A\ntrue|true|true|true|false\ntrue|false|false|true|false\nfalse|true|false|true|true\nfalse|false|false|false|true",
          "examples": []
        }
      },
      {
        "id": "s1-3-4",
        "title": "Bitwise Operators",
        "explanations": {
          "english": "Java mein bitwise operators integer types (byte, short, int, long) ke individual bits pe operations perform karte hain, binary data ki low-level manipulation enable karte hain. Bitwise AND (&) bit ko 1 set karta hai sirf jab dono corresponding bits 1 hain, jabki OR (|) bit ko 1 set karta hai agar koi bhi bit 1 ho. XOR (^) bit ko 1 set karta hai agar bits different hain, aur NOT (~) saare bits invert karta hai. Shift operators bits ko left (<<) ya right (>> signed, >>> unsigned) move karte hain, effectively powers of two se multiply ya divide karke. Ye operators flag management, cryptography, graphics programming, aur performance-critical algorithms mein use hote hain jahan direct bit manipulation arithmetic operations se efficiency advantage provide karta hai."
        },
        "code": {
          "title": "Bitwise Operations",
          "language": "java",
          "content": "int a = 5;  // 0101\nint b = 3;  // 0011\n\nint and = a & b;    // 0001 (1)\nint or = a | b;     // 0111 (7)\nint xor = a ^ b;    // 0110 (6)\nint not = ~a;       // 1111...1010 (-6)\n\n// Shift operations\nint left = a << 1;  // 1010 (10)\nint right = a >> 1; // 0010 (2)\n\n// Flag management\nint READ = 4;  // 0100\nint WRITE = 2; // 0010\nint permissions = READ | WRITE; // 0110"
        },
        "codeExplanations": {
          "english": "Ye example binary representations pe bitwise operations demonstrate karta hai. Flag management example dikhata hai kaise OR permission bits ko single integer mein combine karta hai, ek common pattern systems programming mein jahan har bit different capability ya flag represent karta hai."
        },
        "keyPoints": [
          "Bitwise operators integer types ke individual bits pe kaam karte hain",
          "& (AND), | (OR), ^ (XOR), ~ (NOT) har bit pair pe logical operations perform karte hain",
          "Shift operators (<<, >>, >>>) bits ko left ya right move karte hain 2 se multiplication/division ke liye",
          "Commonly use hote hain flags, masks, aur low-level performance optimization ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "Checking flags: (permissions & READ) != 0",
            "Toggling bits: flags ^= MASK"
          ]
        }
      },
      {
        "id": "s1-3-5",
        "title": "Ternary Operator",
        "explanations": {
          "english": "Java mein ternary operator ek concise way provide karta hai conditional assignment ke liye syntax condition ? valueIfTrue : valueIfFalse ke saath. Ye boolean condition evaluate karta hai aur pehla expression return karta hai agar true ho, otherwise doosra expression, simple if-else statements ka compact alternative act karta hai. Operator right-associative hai, multiple conditions chain karne allow karta hai, lekin excessive nesting readability reduce karta hai. Dono result expressions compatible types ke hone chahiye jo common type mein implicitly cast ho sakein. Jabki simple conditional assignments ke liye useful hai, complex logic ke liye standard if-else blocks use karein clarity ke liye. Ternary operator code brevity improve karta hai variable initialization, return statements, aur method arguments mein."
        },
        "code": {
          "title": "Ternary Operator Usage",
          "language": "java",
          "content": "// Basic usage\nint age = 20;\nString status = (age >= 18) ? \"Adult\" : \"Minor\";\n\n// Nested ternary (use sparingly)\nint score = 85;\nchar grade = (score >= 90) ? 'A' : \n             (score >= 80) ? 'B' : \n             (score >= 70) ? 'C' : 'F';\n\n// Method argument\nSystem.out.println((age > 0) ? \"Valid\" : \"Invalid\");\n\n// Return statement\npublic int max(int a, int b) {\n    return (a > b) ? a : b;\n}"
        },
        "codeExplanations": {
          "english": "Code ternary operator ko simple if-else logic replace karte hain variable assignment ke liye dikhata hai. Nested example multiple conditions demonstrate karta hai lekin illustrate karta hai ki deep nesting readability ke liye avoid karni chahiye. Operator kahin bhi kaam karta hai jahan value expected hai, method arguments aur return statements mein bhi."
        },
        "keyPoints": [
          "Syntax: condition ? trueValue : falseValue",
          "Simple if-else statements ke liye compact alternative provide karta hai assignments ke liye",
          "Dono result expressions compatible ya implicitly castable types ke hone chahiye",
          "Nest kar sakte hain lekin excessive nesting readability harm karti hai"
        ],
        "extras": {
          "flowDiagram": "Condition ? → True → Return Value1\n         ↓\n         False → Return Value2",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-3-6",
        "title": "Operator Precedence",
        "explanations": {
          "english": "Java mein operator precedence determine karta hai ki jab multiple operators ek expression mein ho toh kaunsa pehle evaluate hoga, defined hierarchy follow karte hain mathematical conventions ke similar. Parentheses () sabse highest precedence rakhte hain aur default evaluation order override kar sakte hain, complex expressions mein clarity aur correctness ensure karte hain. Postfix operators (++, --) unary operators (+, -, !, ~) se pehle evaluate hote hain, jo multiplicative (*, /, %), phir additive (+, -), phir shift, phir relational, phir equality, phir bitwise, phir logical AND, phir logical OR, aur finally assignment operators se pehle aate hain. Equal precedence ke operators left-to-right evaluate hote hain (left-associative) assignment aur unary operators ke alawa jo right-associative hote hain. Precedence samajhna subtle bugs prevent karne aur excessive parentheses par rely kam karne mein help karta hai jabki code readability maintain rahe."
        },
        "code": {
          "title": "Precedence Examples",
          "language": "java",
          "content": "// Without parentheses\nint result = 5 + 3 * 2;  // 11, not 16\n\n// With parentheses to override\nresult = (5 + 3) * 2;    // 16\n\n// Complex expression\nboolean check = 5 + 3 > 4 && 2 * 2 == 4;\n// Evaluated as: ((5 + 3) > 4) && ((2 * 2) == 4)\n// Result: true\n\n// Assignment is right-associative\nint a, b, c;\na = b = c = 10; // c=10, b=c, a=b"
        },
        "codeExplanations": {
          "english": "Ye code demonstrate karta hai kaise multiplication addition se higher precedence rakhta hai, parentheses ko force karne ke liye pehle addition chahiye. Boolean expression dikhata hai kaise arithmetic relational operators se pehle aata hai, jo logical AND se pehle aate hain. Right-associativity allow karta hai chained assignments right se left."
        },
        "keyPoints": [
          "Parentheses sabse high precedence rakhte hain aur default order override kar sakte hain",
          "Multiplication aur division addition aur subtraction se pehle hoti hain",
          "Relational operators logical operators se higher precedence rakhte hain",
          "Assignment operators right-associative hain; baki zyadatar left-associative hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Precedence|Operators|Associativity\nHighest|()|Left\nPostfix|++ --|Left\nUnary|+ - ! ~|Right\nMultiplicative|* / %|Left\nAdditive|+ -|Left\nShift|<< >> >>>|Left\nRelational|< > <= >= instanceof|Left\nEquality|== !=|Left\nBitwise AND|&|Left\nBitwise XOR|^|Left\nBitwise OR|||Left\nLogical AND|&&|Left\nLogical OR||||Left\nTernary|? :|Right\nAssignment|= += -= *= /=|Right",
          "examples": []
        }
      },
      {
        "id": "s1-4-1",
        "title": "Conditional Statements - if",
        "explanations": {
          "english": "Java mein if statement ek fundamental control structure hai jo code block sirf tab execute karta hai jab specified boolean condition true evaluate hoti hai. Ye if keyword se start hota hai condition parentheses mein followed by statement ya code block curly braces mein. Condition boolean expression honi chahiye; non-boolean values jaise integers directly conditions ki tarah use nahi ho sakte kuchh aur languages ki tarah. If statements doosre if statements ke andar nest ho sakte hain complex decision trees create karne ke liye. Ye structure programs ko decisions lene aur runtime conditions ke based code selectively execute karne allow karta hai, program logic flow ka base form karta hai."
        },
        "code": {
          "title": "If Statement Usage",
          "language": "java",
          "content": "int temperature = 75;\n\nif (temperature > 80) {\n    System.out.println(\"It's hot\");\n}\n\n// Single statement without braces (discouraged)\nif (temperature > 60)\n    System.out.println(\"It's warm\");\n\n// With boolean variable\nboolean isRaining = true;\nif (isRaining) {\n    System.out.println(\"Take an umbrella\");\n}"
        },
        "codeExplanations": {
          "english": "Example basic if statement syntax dikhata hai jahan code block sirf tab execute hota hai jab condition true ho. Doosra example single statements ke liye optional braces demonstrate karta hai, lekin braces recommended hain maintenance ke dauraan errors prevent karne ke liye. Boolean variables directly conditions ki tarah use ho sakte hain."
        },
        "keyPoints": [
          "Code block sirf tab execute karta hai jab boolean condition true ho",
          "Condition boolean honi chahiye; non-zero integers true ki tarah treat nahi hote",
          "Curly braces single statements ke liye optional hain lekin strongly recommended hain",
          "Nested ja sakta hai complex conditional logic create karne ke liye"
        ],
        "extras": {
          "flowDiagram": "Start → Condition? → True → Execute Block → Continue\n                ↓\n                False → Continue",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-4-2",
        "title": "Conditional Statements - if-else",
        "explanations": {
          "english": "Java mein if-else statement binary decision-making capability provide karta hai ek code block execute karke jab condition true ho aur alternative block jab false ho. Else clause if block ke baad aata hai aur code contain karta hai jo exclusively tab run karta hai jab if condition false evaluate hoti hai. Ye structure mutually exclusive execution paths create karta hai, ensure karta hai ki exactly do blocks mein se ek run ho. Multiple conditions else-if ladders use karke chain kiye ja sakte hain sequentially teen ya zyada scenarios handle karne ke liye. If-else structure binary choices, error handling, aur branching logic ke liye essential hai jahan exactly ek path runtime conditions ke based lena padta hai."
        },
        "code": {
          "title": "If-Else Patterns",
          "language": "java",
          "content": "int score = 75;\n\n// Basic if-else\nif (score >= 60) {\n    System.out.println(\"Pass\");\n} else {\n    System.out.println(\"Fail\");\n}\n\n// If-else-if ladder\nif (score >= 90) {\n    System.out.println(\"A\");\n} else if (score >= 80) {\n    System.out.println(\"B\");\n} else if (score >= 70) {\n    System.out.println(\"C\");\n} else {\n    System.out.println(\"F\");\n}"
        },
        "codeExplanations": {
          "english": "Pehla example Pass aur Fail ke beech binary choice dikhata hai. Else-if ladder multiple ranges handle karna demonstrate karta hai, conditions ko top-down evaluate karta hai jab tak ek match na ho ya final else execute ho. If-else-if chain mein sirf ek block execute hota hai, mutually exclusive conditions ke liye efficient banata hai."
        },
        "keyPoints": [
          "Condition ke based do mutually exclusive execution paths provide karta hai",
          "Else block sirf tab execute karta hai jab if condition false ho",
          "Else-if ladders multiple conditions sequentially handle karte hain",
          "If-else-if chain mein sirf ek block execute hota hai"
        ],
        "extras": {
          "flowDiagram": "Start → Condition? → True → If Block → End\n                ↓\n                False → Else Block → End",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-4-3",
        "title": "Conditional Statements - switch",
        "explanations": {
          "english": "Java mein switch statement multi-way branch provide karta hai jo variable ki value ko multiple constant cases se efficiently compare karta hai. Ye expression ek baar evaluate karta hai aur matching case label pe jump karta hai, code execute karta hai break statement ya switch block ke end tak. Switch byte, short, char, int, unke wrapper classes, enums, aur Java 7 se Strings ke saath kaam karta hai. Break statements ke bina, execution subsequent cases mein fall through karta hai (fall-through behavior), jo cases group karne mein use ho sakta hai lekin often bugs cause karta hai agar bhool se chhoot jaye. Java 12 ne switch expressions introduce kiye jo values return karte hain aur arrow syntax use karte hain cleaner syntax ke liye. Switch statements zyada readable hain lambi if-else ladders ki jagah jab single variable ko discrete values se compare karna ho."
        },
        "code": {
          "title": "Switch Statement Examples",
          "language": "java",
          "content": "// Traditional switch\nint day = 3;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    default:\n        System.out.println(\"Other\");\n}\n\n// Fall-through grouping\nchar grade = 'B';\nswitch (grade) {\n    case 'A':\n    case 'B':\n    case 'C':\n        System.out.println(\"Pass\");\n        break;\n    default:\n        System.out.println(\"Fail\");\n}"
        },
        "codeExplanations": {
          "english": "Pehla example standard switch syntax dikhata hai break statements ke saath fall-through prevent karne ke liye. Doosra intentional fall-through demonstrate karta hai jahan multiple cases same code block share karte hain, useful jab different inputs identical handling require karte hain. Default case unmatched values ko catch karta hai."
        },
        "keyPoints": [
          "Variable ko multiple constant values se efficiently compare karta hai",
          "Byte, short, char, int, enums, Strings, aur wrappers support karta hai",
          "Break statements subsequent cases mein fall-through prevent karte hain",
          "Default case koi bhi case label match nahi hone par handle karta hai"
        ],
        "extras": {
          "flowDiagram": "Start → Evaluate Expression → Match Case? → Execute → Break? → End\n                ↓ No Match\n                Default → End",
          "comparisonTable": "Feature|If-Else|Switch\nCondition|Any boolean|Equality only\nExpressions|Multiple|Single variable\nReadability|Poor for many cases|Good for discrete values\nPerformance|Sequential checks|Jump table optimization",
          "examples": []
        }
      },
      {
        "id": "s1-4-4",
        "title": "Looping Statements - for",
        "explanations": {
          "english": "Java mein for loop compact way provide karta hai iterate karne ka counter-controlled structure ke saath jo initialization, condition, aur update expressions se milkar bana hai. Syntax for(init; condition; update) initialization ek baar execute karta hai, har iteration se pehle condition check karta hai, body execute karta hai agar true ho, phir update perform karta hai. Ye loop arrays ya collections iterate karne ke liye ideal hai jab size known ho ya specific number of iterations required ho. Enhanced for loop (for-each) Java 5 mein introduce hua arrays aur Iterable collections ko simplify karta hai bina explicit indexing ke. Teen traditional for components optional hain, infinite loops allow karte hain for(;;) ke saath, lekin break statements unhe terminate karein."
        },
        "code": {
          "title": "For Loop Patterns",
          "language": "java",
          "content": "// Traditional for loop\nfor (int i = 0; i < 5; i++) {\n    System.out.println(\"Iteration: \" + i);\n}\n\n// Decrementing\nfor (int i = 10; i > 0; i--) {\n    System.out.println(i);\n}\n\n// Enhanced for loop (for-each)\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) {\n    System.out.println(num);\n}\n\n// Multiple variables\nfor (int i = 0, j = 10; i < j; i++, j--) {\n    System.out.println(i + \", \" + j);\n}"
        },
        "codeExplanations": {
          "english": "Traditional for loop initialization (int i=0), condition (i<5), aur increment (i++) dikhata hai. Enhanced for loop automatically array elements iterate karta hai bina index management ke. For header mein multiple variables simultaneously update ho sakte hain, bidirectional iteration ke liye useful."
        },
        "keyPoints": [
          "Syntax: for(init; condition; update) saare parts optional hain",
          "Initialization ek baar execute hoti hai; condition har iteration se pehle check hoti hai",
          "Enhanced for loop (for-each) array/collection iteration simplify karta hai",
          "Loop variable scope ke saath careful rahein; loop ke bahar end hoti hai"
        ],
        "extras": {
          "flowDiagram": "Start → Initialization → Condition? → True → Body → Update → Condition?\n                      ↓ False\n                      End",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-4-5",
        "title": "Looping Statements - while",
        "explanations": {
          "english": "Java mein while loop code block ko repeatedly execute karta hai jab tak specified boolean condition true rehti hai, har iteration se pehle condition evaluate karta hai. Ye ideal hai situations mein jahan iterations ki number pehle se unknown hai aur runtime conditions ya external factors pe depend karti hai. Condition eventually false honi chahiye infinite loops avoid karne ke liye; ensure karein ki loop body variables modify karti hai jo condition affect karte hain. While loops input streams read karne, polling, ya specific state changes wait karne ke liye achhe kaam karte hain. For loop ke unlike, while loop typically variable initialization loop se pehle aur modification body ke andar handle karta hai, isse ye event-driven ya condition-dependent iteration ke liye zyada suitable hai."
        },
        "code": {
          "title": "While Loop Examples",
          "language": "java",
          "content": "// Basic while loop\nint count = 0;\nwhile (count < 5) {\n    System.out.println(\"Count: \" + count);\n    count++;\n}\n\n// Reading until condition\nScanner scanner = new Scanner(System.in);\nString input = \"\";\nwhile (!input.equals(\"quit\")) {\n    System.out.print(\"Enter text: \");\n    input = scanner.nextLine();\n    System.out.println(\"You entered: \" + input);\n}\n\n// Infinite loop with break\nwhile (true) {\n    if (someCondition) {\n        break;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Pehla example counter-controlled while loop dikhata hai jahan count pehle initialize hota hai aur andar increment hota hai. Doosra event-driven pattern demonstrate karta hai jo user input handling mein common hai. Infinite loop break ke saath while(true) ko server ya game loop pattern ki tarah dikhata hai internal termination logic ke saath."
        },
        "keyPoints": [
          "Condition har iteration se pehle evaluate hoti hai; body kabhi execute na bhi ho sakti hai",
          "Use karein jab iteration count unknown ho aur runtime conditions pe depend kare",
          "Ensure karein ki condition variables loop ke andar modify hote hain infinite loops avoid karne ke liye",
          "Pre-test loop input validation aur event polling ke liye suitable hai"
        ],
        "extras": {
          "flowDiagram": "Start → Condition? → True → Body → Condition?\n                ↓ False\n                End",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-4-6",
        "title": "Looping Statements - do-while",
        "explanations": {
          "english": "Java mein do-while loop ek post-test loop hai jo apna body at least ek baar execute karta hai continuation condition check karne se pehle. Syntax while(condition) ko do block ke end mein place karta hai, pehli execution guarantee karta hai regardless of condition truth value. Ye loop particularly useful hai menu systems, input validation, ya scenarios mein jahan at least one iteration chahiye jaise game rounds ya database queries. While loop ki tarah, isme bhi careful handling chahiye taaki condition eventually false ho jaye infinite loops prevent karne ke liye. While condition ke baad semicolon mandatory hai aur common syntax error source hai agar omit ho jaye."
        },
        "code": {
          "title": "Do-While Patterns",
          "language": "java",
          "content": "// Basic do-while\nint i = 0;\ndo {\n    System.out.println(\"Value: \" + i);\n    i++;\n} while (i < 5);\n\n// Input validation\nScanner scanner = new Scanner(System.in);\nint number;\ndo {\n    System.out.print(\"Enter positive number: \");\n    number = scanner.nextInt();\n} while (number <= 0);\nSystem.out.println(\"Valid number: \" + number);\n\n// Menu system\nint choice;\ndo {\n    System.out.println(\"1. Start 2. Options 3. Exit\");\n    choice = scanner.nextInt();\n    processChoice(choice);\n} while (choice != 3);"
        },
        "codeExplanations": {
          "english": "Examples do-while guarantee of at least one execution dikhate hain. Input validation ensure karta hai ki prompt validity check se pehle appear ho. Menu system classic use case dikhata hai jahan options kam se kam ek baar display hone chahiye exit condition check se pehle."
        },
        "keyPoints": [
          "Post-test loop body ko at least ek baar execute karta hai condition check se pehle",
          "While(condition); ke baad semicolon required hai",
          "Menu systems aur input validation ke liye ideal hai jahan initial prompt chahiye",
          "Standard while loop se different hai kyunki body condition evaluation se pehle execute hoti hai"
        ],
        "extras": {
          "flowDiagram": "Start → Body → Condition? → True → Body\n                      ↓ False\n                      End",
          "comparisonTable": "Feature|While|Do-While\nEvaluation|Pre-test|Post-test\nMinimum Executions|0|1\nUse Case|May not need iteration|Must execute at least once\nSyntax|while(condition)|do {} while(condition);",
          "examples": []
        }
      },
      {
        "id": "s1-4-7",
        "title": "break and continue",
        "explanations": {
          "english": "Java mein break aur continue statements loops aur switch statements ke andar flow control provide karte hain. Break statement immediately innermost enclosing loop ya switch terminate karta hai, execution ko block ke baad pehle statement pe transfer karta hai. Continue statement current iteration ke remaining code ko skip karta hai aur next iteration ki condition check pe jump karta hai. Labeled breaks allow karte hain nested loops se exit specify karke label identifier outer loop se pehle. Ye statements sparingly use karne chahiye kyunki ye code ko follow karne mein mushkil bana sakte hain; often logic restructure karke ya methods extract karke clearer alternatives provide karte hain. Ye useful hain early exit conditions, iterations filter karne, ya complex search algorithms se break out karne ke liye."
        },
        "code": {
          "title": "Break and Continue Usage",
          "language": "java",
          "content": "// Break in loop\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) {\n        break; // Exit loop at 5\n    }\n    System.out.println(i);\n}\n\n// Continue - skip iteration\nfor (int i = 0; i < 5; i++) {\n    if (i == 2) {\n        continue; // Skip printing 2\n    }\n    System.out.println(i);\n}\n\n// Labeled break\nouter: for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        if (i == 1 && j == 1) {\n            break outer; // Exit both loops\n        }\n        System.out.println(i + \",\" + j);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Break example loop completely exit karta hai jab i 5 reach karta hai. Continue current iteration skip karta hai jab i 2 ho, usse print nahi karta lekin i=3 ke saath continue karta hai. Labeled break demonstrate karta hai kaise nested loops se escape kiya ja sakta hai outer label pe break karke, dono loops ko immediately stop karke."
        },
        "keyPoints": [
          "Break innermost loop ya switch ko immediately exit kar deta hai",
          "Continue remaining iteration logic ko skip karta hai aur loop condition dobara check karta hai",
          "Labeled breaks nested structures mein specified outer loops se exit allow karte hain",
          "Sparingly use karein code readability maintain karne aur spaghetti logic avoid karne ke liye"
        ],
        "extras": {
          "flowDiagram": "For Break: Loop → Condition? → True → Check Break? → True → Exit Loop\n                                   ↓ False\n                                   Continue Loop\n\nFor Continue: Loop Body → Check Continue? → True → Skip to Next Iteration",
          "comparisonTable": "Statement|Action|Use Case\nbreak|Exit loop/switch|Early termination, found result\ncontinue|Skip to next iteration|Filter, skip specific cases\nlabeled break|Exit nested loops|Escape from deep nesting",
          "examples": []
        }
      },
      {
        "id": "s1-5-1",
        "title": "Method Declaration & Invocation",
        "explanations": {
          "english": "Java mein methods classes ke andar declare kiye jaate hain signature ke through jo modifiers, return type, method name, parameter list, aur optional throws clause include karta hai. Declaration syntax follow karta hai: modifiers returnType methodName(parameters) { body }. Method invocation method name ke through occur karta hai parentheses mein arguments ke saath jo parameter types match karte hain. Static methods class ko belong karte hain aur ClassName.method() use karke call kiye jaate hain, jabki instance methods ko object reference chahiye. Methods code reusability, modularity, aur abstraction promote karte hain specific functionality encapsulate karke. Proper method naming camelCase conventions follow karta hai lowercase letter se start hokar verb-noun combinations ke saath jo action describe karte hain."
        },
        "code": {
          "title": "Method Declaration and Calling",
          "language": "java",
          "content": "public class Calculator {\n    // Instance method\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    // Static method\n    public static void greet() {\n        System.out.println(\"Hello!\");\n    }\n    \n    public static void main(String[] args) {\n        // Invoke static method\n        Calculator.greet();\n        \n        // Invoke instance method\n        Calculator calc = new Calculator();\n        int result = calc.add(5, 3);\n        System.out.println(result);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Example do method types dikhata hai: add ek instance method hai jo object creation require karta hai invoke karne ke liye, jabki greet static hai aur directly class pe call kiya ja sakta hai. Main method dono invocation patterns demonstrate karta hai, dikhata hai kaise static methods instantiation require nahi karte lekin instance methods karte hain."
        },
        "keyPoints": [
          "Method signature mein modifiers, return type, name, aur parameters shaamil hain",
          "Static methods class ko belong karte hain; instance methods objects ko belong karte hain",
          "Methods matching argument types aur count ke saath call karne padte hain",
          "Return type void indicate karta hai koi value return nahi hoti; otherwise specified type return karna padta hai"
        ],
        "extras": {
          "flowDiagram": "Caller → Method Call → Parameter Passing → Execute Body → Return Value → Caller",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-5-2",
        "title": "Method Overloading",
        "explanations": {
          "english": "Java mein method overloading allow karta hai ki same class mein multiple methods same name share kar sakein lekin different parameter lists ke saath, intuitive APIs enable karte hain varied input options ke saath. Overloaded methods mein parameters ki number, types, ya order different honi chahiye; sirf return type se different hone se compilation error aata hai. Compiler determine karta hai kaunsa method invoke karna hai compile time pe argument types ke based (static polymorphism). Overloading code readability improve karta hai related operations ke liye consistent naming use karke different data types ya argument counts handle karte hue. Common examples mein System.out.println() shaamil hai jo various types jaise String, int, aur double ke liye overloaded hai."
        },
        "code": {
          "title": "Method Overloading Examples",
          "language": "java",
          "content": "public class Printer {\n    // Overloaded methods\n    public void print(String text) {\n        System.out.println(\"String: \" + text);\n    }\n    \n    public void print(int number) {\n        System.out.println(\"Integer: \" + number);\n    }\n    \n    public void print(String text, int count) {\n        for (int i = 0; i < count; i++) {\n            System.out.println(text);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Printer p = new Printer();\n        p.print(\"Hello\");\n        p.print(42);\n        p.print(\"Hi\", 3);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye code overloading demonstrate karta hai different parameter types (String vs int) aur parameter count (single vs double) ke through. Compiler appropriate print method select karta hai compile time pe argument types ke based, same method name ko different input scenarios handle karne allow karta hai intuitively."
        },
        "keyPoints": [
          "Same class mein same method name different parameter lists ke saath",
          "Differences parameter ki number, type, ya order mein ho sakte hain",
          "Sirf return type se overloaded methods distinguish nahi hote",
          "Compile-time polymorphism: compiler method call ko definition se bind karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Aspect|Overloading|Overriding\nLocation|Same class|Parent-Child classes\nParameters|Must differ|Must be same\nReturn Type|Can differ|Must be same or covariant\nBinding|Compile time|Runtime\nPurpose|Different inputs|Different implementation",
          "examples": []
        }
      },
      {
        "id": "s1-5-3",
        "title": "Varargs",
        "explanations": {
          "english": "Java mein variable-length arguments (varargs) methods ko allow karte hain specified type ke zero ya more arguments accept karne ke liye, method calls ko varying argument counts ke saath simplify karte hain. Syntax type ke baad ellipsis (...) use karta hai, jaise int... numbers, jo compiler ko us type ke array mein convert karta hai method body ke andar. Varargs method signature mein last parameter hona chahiye, aur sirf ek varargs parameter allowed hai per method. Ye feature different argument counts handle karne wale multiple overloaded methods ki zaroorat eliminate karta hai ya callers ko manual array creation se bachata hai. Varargs ideal hain sum calculations, string formatting, logging utilities, aur kisi bhi method ke liye jo flexible argument lists se benefit le sakta hai."
        },
        "code": {
          "title": "Varargs Usage",
          "language": "java",
          "content": "public class VarargsDemo {\n    // Varargs method\n    public int sum(int... numbers) {\n        int total = 0;\n        for (int num : numbers) {\n            total += num;\n        }\n        return total;\n    }\n    \n    // Mixed parameters\n    public void log(String level, String... messages) {\n        System.out.print(level + \": \");\n        for (String msg : messages) {\n            System.out.print(msg + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        VarargsDemo demo = new VarargsDemo();\n        System.out.println(demo.sum());\n        System.out.println(demo.sum(1, 2));\n        System.out.println(demo.sum(1, 2, 3, 4, 5));\n        demo.log(\"INFO\", \"Server\", \"started\", \"successfully\");\n    }\n}"
        },
        "codeExplanations": {
          "english": "Sum method koi bhi number of integers accept karta hai, unhe internally array ki tarah treat karta hai. Log method varargs ko regular parameters ke saath dikhata hai, jahan varargs last hona chahiye. Callers zero, individual arguments, ya arrays pass kar sakte hain, compiler conversion automatically handle karta hai."
        },
        "keyPoints": [
          "Syntax: type... variableName array-like parameter create karta hai",
          "Varargs method signature mein last parameter hone chahiye",
          "Sirf ek varargs allowed hai per method",
          "Compiler arguments ko array mein convert karta hai; directly bhi array pass kar sakte hain"
        ],
        "extras": {
          "flowDiagram": "Call with args → Compiler packages into array → Method receives array → Iterate/process",
          "comparisonTable": "",
          "examples": [
            "System.out.printf(String format, Object... args)",
            "String.format(String format, Object... args)"
          ]
        }
      },
      {
        "id": "s1-5-4",
        "title": "Pass-by-Value in Java",
        "explanations": {
          "english": "Java strictly pass-by-value semantics use karta hai for all method arguments, matlab method argument ki value ki copy receive karta hai original variable ki jagah. Primitive types ke liye, iska matlab hai ki parameters ke andar modifications caller mein original variable affect nahi karte. Reference types ke liye, pass ki gayi value memory address (reference) hai, isliye jabki reference different object point nahi kar sakta, object ki internal state modify ho sakti hai. Ye behavior often developers ko confuse karta hai jo objects ke liye pass-by-reference expect karte hain. Ye distinction samajhna crucial hai method side effects predict karne aur aise APIs design karne ke liye jo modified values return karein parameter modification pe rely karne ke bajaye."
        },
        "code": {
          "title": "Pass-by-Value Demonstration",
          "language": "java",
          "content": "public class PassByValue {\n    public void modifyPrimitive(int x) {\n        x = 100; // Only changes local copy\n    }\n    \n    public void modifyReference(StringBuilder sb) {\n        sb.append(\" World\"); // Modifies object state\n    }\n    \n    public void reassignReference(StringBuilder sb) {\n        sb = new StringBuilder(\"New\"); // Only changes local reference\n    }\n    \n    public static void main(String[] args) {\n        int num = 50;\n        new PassByValue().modifyPrimitive(num);\n        System.out.println(num); // Still 50\n        \n        StringBuilder builder = new StringBuilder(\"Hello\");\n        new PassByValue().modifyReference(builder);\n        System.out.println(builder); // Hello World\n        \n        new PassByValue().reassignReference(builder);\n        System.out.println(builder); // Still Hello World\n    }\n}"
        },
        "codeExplanations": {
          "english": "Example prove karta hai primitives method calls ke baad unchanged rehte hain. References ke liye, modifyReference object ki internal state change karta hai (bahar visible), lekin reassignReference original variable ko new object point nahi kara sakta kyunki sirf reference ki copy locally reassign hui thi."
        },
        "keyPoints": [
          "Java strictly pass-by-value hai; method parameters copies hain",
          "Primitive modifications methods ke andar caller ki variable affect nahi karte",
          "Reference types memory address ki copy pass karte hain, object mutation allow karte hain",
          "Reference parameter ko method ke andar reassign karna original reference affect nahi karta"
        ],
        "extras": {
          "flowDiagram": "Caller: int x=5 → Pass copy (5) → Method modifies copy to 10 → Original x still 5\n\nCaller: ref → Pass copy of address → Method modifies object at address → Original ref sees changes\n\nCaller: ref → Pass copy → Method assigns new address to copy → Original ref unchanged",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-5-5",
        "title": "Return Types",
        "explanations": {
          "english": "Java methods mein return types specify karte hain ki method execution ke baad caller ko kis type ki value return hogi. Methods primitives, reference types, ya void return kar sakte hain jo indicate karta hai koi return value nahi hai. Return statement immediately method execution terminate karta hai aur specified value caller ke code ko pass back karta hai. Non-void methods ke liye, har possible execution path ko declared return type ke compatible value return karni chahiye. Return types polymorphism support karte hain covariant returns ke through, jahan overriding method parent method ki return type ka subtype return kar sakta hai. Multiple values objects, arrays, ya records mein encapsulate karke return kiye ja sakte hain."
        },
        "code": {
          "title": "Return Type Patterns",
          "language": "java",
          "content": "// Primitive return\npublic int square(int x) {\n    return x * x;\n}\n\n// Reference return\npublic String getGreeting() {\n    return \"Hello\";\n}\n\n// Void - no return\npublic void printMessage(String msg) {\n    System.out.println(msg);\n    return; // Optional in void methods\n}\n\n// Returning multiple values via array\npublic int[] getMinMax(int[] nums) {\n    int min = nums[0], max = nums[0];\n    for (int n : nums) {\n        if (n < min) min = n;\n        if (n > max) max = n;\n    }\n    return new int[]{min, max};\n}"
        },
        "codeExplanations": {
          "english": "Examples different return patterns demonstrate karte hain: primitives value return karte hain, references memory addresses return karte hain, void methods bina data return kiye execute hote hain, aur multiple values composite types jaise arrays return kiye ja sakte hain jab necessary ho."
        },
        "keyPoints": [
          "Return type method name se pehle declare kiya jaata hai; void matlab koi return value nahi",
          "Return statement method ko immediately exit karta hai aur value caller ko pass karta hai",
          "Non-void methods ko guarantee karna chahiye ki return statement sab paths mein execute hota hai",
          "Covariant return types overridden methods mein subclasses return karne allow karte hain"
        ],
        "extras": {
          "flowDiagram": "Method Start → Execute Logic → Return Statement → Return Value to Caller → Method End",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-6-1",
        "title": "One-Dimensional Arrays",
        "explanations": {
          "english": "Java mein one-dimensional arrays fixed-size, ordered collections hain same type ke elements ki, contiguously heap memory mein store hote hain. Declaration mein syntax type[] arrayName ya type arrayName[] use hota hai, instantiation ke liye new keyword aur size specification chahiye: new type[size]. Array indices 0 se start hote hain aur length-1 tak range karte hain, runtime bounds checking invalid access pe ArrayIndexOutOfBoundsException throw karta hai. Length property fixed capacity provide karta hai, filled elements ki count nahi. Arrays literal values se curly braces use karke declaration ke dauraan initialize ho sakte hain. Ye reference types hain, matlab assignment elements ki copy create karta hai reference ki jagah."
        },
        "code": {
          "title": "1D Array Operations",
          "language": "java",
          "content": "// Declaration and initialization\nint[] numbers = new int[5];\nint[] scores = {85, 90, 78, 92, 88};\n\n// Access and modify\nnumbers[0] = 10;\nSystem.out.println(scores[2]); // 78\n\n// Iterate\nfor (int i = 0; i < scores.length; i++) {\n    System.out.println(scores[i]);\n}\n\n// Enhanced for loop\nfor (int score : scores) {\n    System.out.println(score);\n}"
        },
        "codeExplanations": {
          "english": "Code do initialization styles dikhata hai: new int[5] fixed-size array create karta hai default values (0) ke saath, jabki literal syntax {85, 90...} simultaneously declare aur populate karta hai. Access zero-based indexing use karta hai, aur length property array size deti hai. Dono traditional aur enhanced for loops elements iterate karne ke liye."
        },
        "keyPoints": [
          "Arrays ka fixed size creation pe determine hota hai aur resize nahi ho sakta",
          "Zero-indexed: pehla element index 0 pe, last length-1 pe",
          "Length property total capacity return karta hai, used elements ki number nahi",
          "ArrayIndexOutOfBoundsException invalid index access pe throw hota hai"
        ],
        "extras": {
          "flowDiagram": "Index: 0 | 1 | 2 | 3 | 4\nValue: 85|90|78|92|88\nMemory: Contiguous heap allocation",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-6-2",
        "title": "Two-Dimensional Arrays",
        "explanations": {
          "english": "Java mein two-dimensional arrays arrays ke arrays hote hain, matrix-like structure create karte hain rows aur columns ke saath. Declaration syntax type[][] arrayName hai, structure create karta hai jahan outer array ka har element khud ek array hai. Ye tables, matrices, grids, ya coordinate systems represent kar sakte hain. Initialization mein dono dimensions specify kar sakte hain (rectangular arrays) ya second dimension variable chhod sakte hain (jagged arrays). Access ke liye do indices chahiye: array[row][column]. Memory truly contiguous 2D grid mein nahi hota; instead, outer array inner row arrays ke references hold karta hai. Ye complex data structures represent karne mein useful hain jaise game boards, spreadsheets, ya graph algorithms mein adjacency matrices."
        },
        "code": {
          "title": "2D Array Usage",
          "language": "java",
          "content": "// Rectangular array\nint[][] matrix = new int[3][4];\nint[][] grid = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\n\n// Access\nSystem.out.println(grid[1][2]); // 6\n\n// Iterate\nfor (int i = 0; i < grid.length; i++) {\n    for (int j = 0; j < grid[i].length; j++) {\n        System.out.print(grid[i][j] + \" \");\n    }\n    System.out.println();\n}"
        },
        "codeExplanations": {
          "english": "Example 3x3 matrix initialization lists use karke create karta hai. Access row aur column indices require karta hai. Nested loop rows grid.length se aur columns grid[i].length se iterate karta hai, non-rectangular (jagged) arrays allow karta hai jahan har row ka different length ho sakta hai."
        },
        "keyPoints": [
          "2D arrays arrays ke arrays hain; har row different array object ho sakta hai",
          "Do indices ke saath access: array[row][column]",
          "Outer array ki length rows ki number hai; inner arrays ki lengths columns hain",
          "Rectangular (equal columns) ya jagged (variable columns per row) ho sakte hain"
        ],
        "extras": {
          "flowDiagram": "matrix[0] → [0][1][2][3]\nmatrix[1] → [0][1][2][3]\nmatrix[2] → [0][1][2][3]",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-6-3",
        "title": "Jagged Arrays",
        "explanations": {
          "english": "Java mein jagged arrays multi-dimensional arrays hain jahan har row ka different length ho sakta hai, ragged ya triangular structure create karta hai rectangular matrix ki jagah. Ye arrays of arrays ki tarah implement hote hain jahan outer array pehle allocate hota hai, aur har inner array separately independent sizes ke saath create hota hai. Ye structure memory-efficient hai jab data naturally variable row lengths ke saath ho, jaise student grades store karna jahan har student ke different number of courses hain. Declaration mein sirf pehli dimension initially specify hoti hai, second dimensions per row allocate kiye jaate hain. Jagged arrays ko iterate karte waqt careful handling chahiye, har row ki length individually check karni padti hai ArrayIndexOutOfBoundsException avoid karne ke liye."
        },
        "code": {
          "title": "Jagged Array Creation",
          "language": "java",
          "content": "// Create jagged array\nint[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[4];\njagged[2] = new int[3];\n\n// Initialization\nint[][] triangle = {\n    {1},\n    {2, 3},\n    {4, 5, 6}\n};\n\n// Safe iteration\nfor (int i = 0; i < triangle.length; i++) {\n    for (int j = 0; j < triangle[i].length; j++) {\n        System.out.print(triangle[i][j] + \" \");\n    }\n    System.out.println();\n}"
        },
        "codeExplanations": {
          "english": "Code jagged array allocate karna dikhata hai sirf outer dimension (3 rows) specify karke, phir individually har row size karta hai. Triangle example jagged structure ki literal initialization demonstrate karta hai. Iteration triangle[i].length use karta hai variable column counts safely handle karne ke liye."
        },
        "keyPoints": [
          "Jagged array mein har row ka different length ho sakta hai",
          "Sirf pehli dimension ke saath declare karein: new int[rows][]",
          "Har row separately allocate karein: array[i] = new int[size]",
          "Iterate karte waqt hamesha array[i].length use karein variable row sizes handle karne ke liye"
        ],
        "extras": {
          "flowDiagram": "Row 0: [5][2]\nRow 1: [8][1][9][3]\nRow 2: [4][7]",
          "comparisonTable": "Rectangular|Jagged\nFixed column count|Variable column count\nMemory may waste space|Memory efficient for irregular data\nmatrix[0].length equals matrix[1].length|Each row length independent",
          "examples": []
        }
      },
      {
        "id": "s1-6-4",
        "title": "Array Initialization Techniques",
        "explanations": {
          "english": "Java mein arrays ko initialize karne ke multiple techniques available hain depend karta hai ki values kab known hain aur array ka purpose kya hai. Static initialization literal values curly braces mein declaration ke dauraan use karta hai, ideal jab data compile time pe known ho. Dynamic initialization 'new' ke saath memory allocate karta hai aur runtime pe values assign karta hai, calculated ya input-dependent data ke liye useful. Anonymous arrays allow karte hain arrays create aur pass karna bina variable declare kiye, convenient hai one-time use method arguments mein. Arrays.fill() method saare elements ko specific value se initialize karta hai, jabki Arrays.setAll() generator function use karta hai computed initialization ke liye. Ye techniques samajhna har scenario ke liye sabse concise aur appropriate method select karne mein allow karta hai."
        },
        "code": {
          "title": "Array Initialization Patterns",
          "language": "java",
          "content": "// Static initialization\nint[] nums = {1, 2, 3, 4, 5};\nString[] fruits = {\"Apple\", \"Banana\", \"Cherry\"};\n\n// Dynamic initialization\nint[] squares = new int[5];\nfor (int i = 0; i < squares.length; i++) {\n    squares[i] = i * i;\n}\n\n// Anonymous array\nprintArray(new int[]{10, 20, 30});\n\n// Arrays utility methods\nimport java.util.Arrays;\nint[] filled = new int[5];\nArrays.fill(filled, 42);\n\nint[] sequence = new int[5];\nArrays.setAll(sequence, i -> i * 2);"
        },
        "codeExplanations": {
          "english": "Static initialization known values ke liye compact syntax provide karta hai. Dynamic initialization loops use karta hai computed values ke liye. Anonymous arrays temporary arrays create karte hain immediate use ke liye. Arrays.fill uniform values set karta hai, jabki setAll functional initialization patterns ke liye har index pe function apply karta hai."
        },
        "keyPoints": [
          "Static initialization: type[] arr = {val1, val2} sirf declaration ke dauraan",
          "Dynamic initialization: new se allocate karein phir programmatically values assign karein",
          "Anonymous arrays: new type[]{values} temporary array arguments ke liye",
          "Arrays.fill() aur Arrays.setAll() bulk initialization utilities provide karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Method|Use Case|Syntax\nStatic|Known compile-time values|{1, 2, 3}\nDynamic|Runtime computed values|new int[size] + loop\nAnonymous|One-time use arguments|new int[]{1, 2, 3}\nFill|Uniform values|Arrays.fill(arr, val)",
          "examples": []
        }
      },
      {
        "id": "s1-6-5",
        "title": "Common Array Pitfalls",
        "explanations": {
          "english": "Java mein common array pitfalls often runtime exceptions ya subtle bugs cause karte hain array semantics aur boundaries ko lekar misunderstanding ki wajah se. ArrayIndexOutOfBoundsException occur hota hai jab valid 0 se length-1 range ke bahar indices access karte hain, often loop conditions mein off-by-one errors ki wajah se. NullPointerException arise hota hai jab uninitialized array references pe operations attempt karte hain. Arrays fixed-size hain; capacity se beyond elements add karne ki koshish require karta hai new larger array create karna aur data copy karna. Assignment reference aliases create karta hai copies ki jagah, isliye ek reference ke through modification saare aliases affect karta hai. equals() method arrays pe reference equality check karta hai, content nahi; value comparison ke liye Arrays.equals() use karein."
        },
        "code": {
          "title": "Common Array Mistakes",
          "language": "java",
          "content": "// Pitfall 1: Index out of bounds\nint[] arr = new int[5];\n// arr[5] = 10; // Runtime exception!\n\n// Pitfall 2: Null reference\nint[] nullArr;\n// System.out.println(nullArr.length); // NullPointerException!\n\n// Pitfall 3: Reference aliasing\nint[] a = {1, 2, 3};\nint[] b = a;\nb[0] = 100;\nSystem.out.println(a[0]); // 100 - unexpected!\n\n// Pitfall 4: Wrong equals usage\nint[] x = {1, 2};\nint[] y = {1, 2};\nSystem.out.println(x.equals(y)); // false!\nSystem.out.println(Arrays.equals(x, y)); // true"
        },
        "codeExplanations": {
          "english": "Examples critical errors demonstrate karte hain: size-5 array mein index 5 access karna (valid indices 0-4), uninitialized arrays use karna, reference assignment ke through unexpected shared state (b modify karta hai a ka data), aur Object.equals() use karne ka common mistake Arrays.equals() ki jagah content comparison ke liye."
        },
        "keyPoints": [
          "Hamesha ensure karein ki indices 0 se array.length-1 ke beech hain exceptions avoid karne ke liye",
          "Arrays use karne se pehle initialize karein; null arrays ki koi length ya elements nahi hote",
          "Assignment references copy karta hai, elements nahi; true copies ke liye Arrays.copyOf() use karein",
          "Proper array comparison aur printing ke liye Arrays.equals() aur Arrays.toString() use karein"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Mistake|Consequence|Solution\narr[n] where n>=length|ArrayIndexOutOfBoundsException|Check bounds: i < arr.length\nnullArr.length|NullPointerException|Initialize: new int[size]\nb = a; b[0]=x|Both arrays modified|Use Arrays.copyOf()\narr1.equals(arr2)|False for same content|Use Arrays.equals()",
          "examples": []
        }
      },
      {
        "id": "s1-7-1",
        "title": "String Immutability",
        "explanations": {
          "english": "Java mein Strings immutable hain, matlab ek baar String object create ho jaaye toh uska character sequence modify nahi ho sakta. Koi bhi operation jo string modify karne lagta hai—jaise concatenation, replacement, ya case conversion—actually create aur return karta hai naya String object original change karne ke bajaye. Ye immutability security benefits provide karta hai, kyunki strings threads ke beech safely share ho sakte hain bina synchronization ke, aur hash-based collections jaise HashMap mein keys ki tarah use ho sakte hain. JVM string interning ke through memory usage optimize kar sakta hai, literal strings pool mein cache karke duplicate objects avoid karte hue. Immutability samajhna performance ke liye crucial hai, kyunki excessive string concatenation loops mein bahut saare temporary objects create karta hai, StringBuilder ko mutable operations ke liye necessitate karta hai."
        },
        "code": {
          "title": "String Immutability Demo",
          "language": "java",
          "content": "String original = \"Hello\";\nString modified = original.concat(\" World\");\n\nSystem.out.println(original);  // Hello (unchanged!)\nSystem.out.println(modified);  // Hello World\n\n// Reassignment creates new reference\noriginal = original + \"!\";\nSystem.out.println(original);  // Hello!\n\n// Methods return new strings\nString upper = original.toUpperCase();\nSystem.out.println(original);  // Hello! (still unchanged)"
        },
        "codeExplanations": {
          "english": "Ye demonstrate karta hai ki concat(), + operator, aur toUpperCase() naye String objects return karte hain original modify karne ke bajaye. Original variable 'Hello' rehta hai concat ke baad, nayi value capture karne ke liye assignment chahiye. Original reassign karna sirf reference ko change karta hai kaunsa object point karta hai, object khud nahi."
        },
        "keyPoints": [
          "String objects create hone ke baad modify nahi ho sakte; saari 'modifying' methods naye instances return karti hain",
          "Immutability thread safety aur string data ka secure sharing enable karta hai",
          "String variable reassign karna reference change karta hai, object nahi",
          "String concatenation intermediate objects create karta hai; loops mein StringBuilder use karein"
        ],
        "extras": {
          "flowDiagram": "\"Hello\" → concat(\" World\") → New String \"Hello World\"\n   ↑\noriginal still points to \"Hello\"",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-7-2",
        "title": "String Pool",
        "explanations": {
          "english": "Java mein String Pool heap mein ek special memory region hai jahan string literals store aur reuse hote hain memory usage optimize karne ke liye. Jab literal syntax use karke string create karte hain (String s = \"hello\"), JVM pehle pool check karta hai aur existing string ka reference return karta hai agar found ho, ya create aur add karta hai agar nahi. New keyword se create ki gayi strings (new String(\"hello\")) pool bypass karti hai, heap mein duplicate objects create karti hain. Intern() method heap strings ko pool mein add kar sakta hai aur pooled reference return karta hai. Ye optimization immutability ki wajah se safe hai, ensure karta hai shared references doosre code se modify nahi ho sakte. Pool distinction samajhna memory optimization aur correct == versus equals() usage ke liye vital hai."
        },
        "code": {
          "title": "String Pool Behavior",
          "language": "java",
          "content": "// String pool usage\nString s1 = \"Java\";\nString s2 = \"Java\";\nSystem.out.println(s1 == s2); // true - same pool reference\n\n// Heap allocation\nString s3 = new String(\"Java\");\nSystem.out.println(s1 == s3); // false - different objects\nSystem.out.println(s1.equals(s3)); // true - same content\n\n// Interning\nString s4 = s3.intern();\nSystem.out.println(s1 == s4); // true - now in pool"
        },
        "codeExplanations": {
          "english": "Example dikhata hai s1 aur s2 same pooled object ko reference karte hain, == true banata hai. New se create kiya s3 alag heap object hai, isliye == false hai lekin equals() true hai. Intern() s3 pe call karna use pool mein add karta hai aur pooled reference return karta hai, s4 ko s1 identical banaata hai."
        },
        "keyPoints": [
          "String literals automatically interned hain string pool mein reuse ke liye",
          "new String() alag heap objects create karta hai pool bypass karke",
          "Content comparison ke liye equals() use karein; == reference equality check karta hai (pool vs heap)",
          "intern() method manually strings ko pool mein add kar sakta hai memory bachane ke liye"
        ],
        "extras": {
          "flowDiagram": "String Pool: \"Java\" ← s1\n                ↑ s2\n                \nHeap: new String(\"Java\") ← s3",
          "comparisonTable": "Creation|Location|Memory|Use Case\nLiteral \"x\"|String Pool|Shared, efficient|Normal usage\nnew String(\"x\")|Heap|Separate object|Rarely needed\nintern()|String Pool|Adds to pool|Deduplication",
          "examples": []
        }
      },
      {
        "id": "s1-7-3",
        "title": "StringBuilder vs StringBuffer",
        "explanations": {
          "english": "Java mein StringBuilder aur StringBuffer mutable character sequences provide karte hain efficient string manipulation ke liye bina intermediate objects create kiye. StringBuilder, Java 5 mein introduce hua, better performance offer karta hai single-threaded environments ke liye kyunki ye synchronized nahi hai. StringBuffer thread-safe hai method-level synchronization ke through, concurrent environments ke liye suitable hai lekin locking overhead ki wajah se slower hai. Dono append(), insert(), delete(), aur reverse() methods provide karte hain jo directly internal character array modify karte hain. Zyadatar modern applications ke liye StringBuilder preferred hai unless explicit thread safety chahiye. Dono significantly zyada efficient hain string concatenation se loops mein, jo O(n²) temporary objects create karta hai builders ke O(n) ke against."
        },
        "code": {
          "title": "StringBuilder Usage",
          "language": "java",
          "content": "// StringBuilder (non-synchronized, faster)\nStringBuilder sb = new StringBuilder();\nsb.append(\"Hello\");\nsb.append(\" \");\nsb.append(\"World\");\nString result = sb.toString();\n\n// Chaining methods\nString reversed = new StringBuilder(\"Hello\")\n    .reverse()\n    .toString();\n\n// StringBuffer (thread-safe, synchronized)\nStringBuffer sbf = new StringBuffer();\nsbf.append(\"Thread-safe\");\nString bufferResult = sbf.toString();"
        },
        "codeExplanations": {
          "english": "Code StringBuilder ki append chain dikhata hai efficiently string build karte hue bina intermediate objects ke. Method chaining fluent interface usage allow karti hai. StringBuffer identical API demonstrate karta hai lekin internal synchronization ke saath. Dono ko immutable String mein convert karne ke liye toString() chahiye."
        },
        "keyPoints": [
          "StringBuilder faster hai lekin thread-safe nahi; single-threaded code ke liye preferred hai",
          "StringBuffer synchronized aur thread-safe hai lekin locking ki wajah se slower hai",
          "Dono mutable hain; methods object modify karte hain aur chaining ke liye often this return karte hain",
          "Hamesha use karein string concatenation ki jagah loops mein O(n) performance ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Feature|StringBuilder|StringBuffer\nThread-safe|No|Yes\nPerformance|Faster|Slower (synchronization)\nJava Version|1.5+|1.0+\nUse Case|Single-threaded|Multi-threaded\nAPI|Identical|Identical",
          "examples": []
        }
      },
      {
        "id": "s1-7-4",
        "title": "Performance Considerations",
        "explanations": {
          "english": "Java mein string performance optimization samajhna require karta hai ki immutable strings kab use karne hain versus mutable builders. String concatenation + ke saath naya String object create karta hai aur saare characters copy karta hai har baar, n concatenations ke liye O(n²) complexity result karta hai repeated copying ki wajah se. StringBuilder pre-allocate karta hai character buffer jo expand hota hai zaroorat ke hisaab se, append operations ke liye amortized O(n) complexity provide karta hai. Default capacity 16 characters hai; isse exceed karna array copying aur reallocation cause karta hai, isliye expected size constructor mein specify karne se performance improve hoti hai. String.intern() bahut saare duplicate strings ke liye memory reduce kar sakta hai lekin pool lookup overhead badhaata hai. Compile-time constant expressions ke liye, compiler automatically concatenation optimize karta hai, lekin runtime concatenation loops mein hamesha StringBuilder chahiye."
        },
        "code": {
          "title": "Performance Optimization",
          "language": "java",
          "content": "// Bad: O(n²) complexity\nString result = \"\";\nfor (int i = 0; i < 1000; i++) {\n    result += i; // Creates new object each iteration\n}\n\n// Good: O(n) complexity\nStringBuilder sb = new StringBuilder(10000); // Pre-size\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);\n}\nString result = sb.toString();\n\n// Compile-time optimization\nString fast = \"a\" + \"b\" + \"c\"; // Compiled as \"abc\""
        },
        "codeExplanations": {
          "english": "Pehla loop anti-pattern demonstrate karta hai string concatenation loops mein, 1000 temporary objects create karta hai. StringBuilder initial capacity ke saath reallocation overhead eliminate karta hai. Last line compiler optimization dikhata hai jahan literal concatenation compile time pe single pooled string ban jaata hai."
        },
        "keyPoints": [
          "String concatenation loops mein O(n²) hai; StringBuilder O(n) hai",
          "StringBuilder constructor mein initial capacity specify karein resizing avoid karne ke liye",
          "Compiler constant string concatenation ko compile time pe optimize karta hai",
          "Dynamic string construction ke liye StringBuilder use karein; constants ke liye Strings"
        ],
        "extras": {
          "flowDiagram": "String + : Create new array → Copy old + new → Return (repeated)\n\nStringBuilder: Expand buffer if needed → Append to end → Return this",
          "comparisonTable": "Operation|String|StringBuilder\nConcatenation in loop|O(n²), slow|O(n), fast\nMemory usage|Many temporary objects|Single buffer\nThread safety|Immutable (safe)|Not synchronized\nCapacity|Fixed|Auto-expanding",
          "examples": []
        }
      },
      {
        "id": "s1-7-5",
        "title": "Common String Operations",
        "explanations": {
          "english": "Java ki String class text manipulation, searching, aur transformation ke liye extensive methods provide karti hai. Length retrieval (length()), character access (charAt()), aur substring extraction (substring()) fundamental accessor operations hain. Searching methods mein indexOf() aur lastIndexOf() shaamil hain characters ya substrings find karne ke liye, jabki contains(), startsWith(), aur endsWith() boolean checks provide karte hain. Transformation methods jaise toUpperCase(), toLowerCase(), trim(), aur replace() naye modified strings return karte hain. Split() regular expressions use karke strings ko arrays mein divide karta hai, aur join() array elements ko delimiters ke saath concatenate karta hai. Ye operations samajhna efficient text parsing, validation, aur formatting enable karta hai bina manual character iteration ke."
        },
        "code": {
          "title": "String Method Examples",
          "language": "java",
          "content": "String text = \"  Hello, World!  \";\n\n// Inspection\nint len = text.length(); // 17\nchar c = text.charAt(7); // 'o'\n\n// Searching\nint index = text.indexOf(\"World\"); // 9\nboolean has = text.contains(\"Hello\"); // true\n\n// Transformation\nString trimmed = text.trim(); // \"Hello, World!\"\nString upper = text.toUpperCase(); // \"  HELLO, WORLD!  \"\nString replaced = text.replace(\"World\", \"Java\");\n\n// Splitting and joining\nString[] parts = \"a,b,c\".split(\",\");\nString joined = String.join(\"-\", parts); // \"a-b-c\""
        },
        "codeExplanations": {
          "english": "Ye examples essential operations cover karte hain: length aur charAt basic access ke liye, indexOf searching ke liye, trim whitespace remove karne ke liye, case conversion, replacement, aur split/join array conversion ke liye. Saare methods immutability ki wajah se naye strings return karte hain, original unchanged chhod ke."
        },
        "keyPoints": [
          "length(), charAt(), substring() basic string inspection provide karte hain",
          "indexOf(), lastIndexOf(), contains() strings ke andar content search karne ke liye hain",
          "trim(), toUpperCase(), replace() strings ke modified copies create karte hain",
          "split() strings ko arrays mein convert karta hai; join() arrays ko delimiters ke saath combine karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Method|Purpose|Returns\nlength()|Character count|int\ncharAt(i)|Character at index|char\nsubstring(a,b)|Extract portion|String\nindexOf(s)|Find position|int (-1 if not found)\nsplit(regex)|Divide by pattern|String[]\nreplace(a,b)|Swap substrings|String",
          "examples": []
        }
      },
      {
        "id": "s1-8-1",
        "title": "Primitive vs Wrapper Types",
        "explanations": {
          "english": "Java mein wrapper classes eight primitive types ke object representations provide karte hain, allow karte hain primitives ko object-oriented contexts mein use karna. Har primitive ka corresponding wrapper hai: Integer for int, Double for double, Boolean for boolean, etc. Wrappers enable karte hain primitives ko collections mein store karna, generic type parameters ki tarah pass karna, aur reflection mein participate karna. Primitives ke unlike, wrappers null ho sakte hain aur utility methods provide karte hain jaise parseInt() ya toString(). Primitives calculations ke liye zyada memory-efficient aur faster hain, jabki wrappers object behavior offer karte hain. Java ka autoboxing automatically primitives aur wrappers ke beech convert karta hai, lekin is convenience ka performance cost hai aur NullPointerException cause kar sakta hai agar null wrappers unbox kiye jaayein."
        },
        "code": {
          "title": "Primitive and Wrapper Usage",
          "language": "java",
          "content": "// Primitives\nint primitive = 42;\ndouble pi = 3.14;\n\n// Wrappers\nInteger wrapped = Integer.valueOf(42);\nDouble wrappedPi = 3.14; // Autoboxing\n\n// Required for collections\nList<Integer> list = new ArrayList<>();\nlist.add(100); // Autoboxed\nint val = list.get(0); // Unboxed\n\n// Wrapper utilities\nString str = Integer.toString(42);\nint parsed = Integer.parseInt(\"123\");"
        },
        "codeExplanations": {
          "english": "Code efficient storage ke liye primitives aur object contexts ke liye wrappers dikhata hai. Autoboxing automatically int ko Integer mein convert karta hai collections mein add karte waqt, aur unboxing convert karta hai wapas retrieve karte waqt. Wrappers static utility methods provide karte hain string conversion aur parsing ke liye jo primitives pe available nahi hain."
        },
        "keyPoints": [
          "Wrapper classes (Integer, Double, etc.) primitive types ko objectify karte hain",
          "Primitives stack mein store hote hain; wrappers heap objects hain overhead ke saath",
          "Wrappers generics aur collections mein use allow karte hain; primitives nahi",
          "Autoboxing/unboxing automatic conversion provide karta hai lekin performance impact karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Feature|Primitive|Wrapper\nMemory|Stack (efficient)|Heap (object overhead)\nNullability|Cannot be null|Can be null\nGenerics|Not allowed|Required\nMethods|None|Utility methods (parse, toString)\nStorage|In collections via boxing|Directly in collections",
          "examples": []
        }
      },
      {
        "id": "s1-8-2",
        "title": "Autoboxing & Unboxing",
        "explanations": {
          "english": "Java mein autoboxing aur unboxing primitive types aur unke corresponding wrapper classes ke beech automatic conversion provide karte hain. Autoboxing occur hota hai jab primitive wrapper variable ko assign kiya jaata hai ya method ko wrapper expect karte hue pass kiya jaata hai, automatically valueOf() invoke karta hai. Unboxing happen hota hai jab wrapper primitive ko assign kiya jaata hai ya arithmetic operations mein use kiya jaata hai, automatically methods jaise intValue() call karta hai. Ye feature manual conversions eliminate karke code simplify karta hai, lekin subtle issues create karta hai: wrapper equality == se reference compare karta hai cache range ke bahar ki values ke liye, aur null unboxing NullPointerException throw karta hai. Performance-critical code mein loops mein autoboxing avoid karna chahiye object creation overhead ki wajah se."
        },
        "code": {
          "title": "Autoboxing in Practice",
          "language": "java",
          "content": "// Autoboxing\nInteger num = 50; // int automatically boxed to Integer\nDouble price = 19.99;\n\n// Unboxing\nint primitive = num; // Integer unboxed to int\ndouble calc = price + 5.0; // Unboxed for arithmetic\n\n// Method arguments\nprintInteger(100); // Autoboxed\n\n// Potential pitfalls\nInteger a = 1000, b = 1000;\nSystem.out.println(a == b); // false (different objects)\n\nInteger c = 100, d = 100;\nSystem.out.println(c == d); // true (cached objects)"
        },
        "codeExplanations": {
          "english": "Examples automatic conversion assignments aur arithmetic mein dikhate hain. Pitfall section demonstrate karta hai ki == wrappers ke liye object references compare karta hai; chhoti values (-128 se 127) cached hain isliye == kaam lagta hai, lekin badi values same value ke bawajood different objects create karti hain."
        },
        "keyPoints": [
          "Autoboxing: compiler automatically primitive ko wrapper mein convert karta hai (valueOf)",
          "Unboxing: compiler wrapper ko primitive mein convert karta hai (xxxValue methods)",
          "Null wrappers unbox karne se NullPointerException aata hai",
          "== wrappers ke liye references compare karta hai; value comparison ke liye equals() use karein"
        ],
        "extras": {
          "flowDiagram": "Primitive int → Autoboxing → Integer object\nInteger object → Unboxing → Primitive int",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-8-3",
        "title": "Wrapper Caching",
        "explanations": {
          "english": "Java mein wrapper classes frequently used objects cache karke memory efficiency aur autoboxing performance improve karte hain. Byte, Short, Integer, aur Long classes -128 se 127 tak values cache karte hain by default, same object instance return karte hain is range mein values ke liye jab valueOf() ya autoboxing use kiya jaata hai. Character 0 se 127 tak values cache karta hai, aur Boolean TRUE aur FALSE instances cache karta hai. Ye caching explain karta hai ki == chhoti wrapper values ke liye kaise kaam lagta hai lekin bade values ke liye false return karta hai cache range ke bahar. Integer ke liye cache size java.lang.Integer.IntegerCache.high system property se configure ho sakta hai. Caching samajhna reference equality bugs avoid karne aur applications mein memory usage optimize karne ke liye crucial hai jahan bahut saare wrapper instances hain."
        },
        "code": {
          "title": "Wrapper Caching Behavior",
          "language": "java",
          "content": "// Cached (same object)\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b); // true\n\n// Not cached (different objects)\nInteger c = 128;\nInteger d = 128;\nSystem.out.println(c == d); // false\nSystem.out.println(c.equals(d)); // true\n\n// Boolean caching\nBoolean t1 = true;\nBoolean t2 = true;\nSystem.out.println(t1 == t2); // always true\n\n// Explicit valueOf uses cache\nInteger e = Integer.valueOf(100);\nInteger f = Integer.valueOf(100);\nSystem.out.println(e == f); // true"
        },
        "codeExplanations": {
          "english": "Code demonstrate karta hai ki -128 se 127 ke beech ki values identical cached objects return karti hain, == true banata hai. Is range ke bahar naye objects create hote hain, isliye == false return karta hai despite equal values. Value comparison ke liye hamesha equals() use karein, ya valueOf() ensure karne ke liye caching benefits mil sake."
        },
        "keyPoints": [
          "Integer -128 se 127 tak cache karta hai; doosre types ke similar ranges hain",
          "Autoboxing valueOf() use karta hai jo cached instances return karta hai jab available ho",
          "== references compare karta hai; cached objects == se equal appear hote hain, naye nahi",
          "Wrapper objects ke value comparison ke liye hamesha equals() use karein"
        ],
        "extras": {
          "flowDiagram": "valueOf(100) → Check Cache → Found? → Return cached object\n                          ↓ No\n                   Create new Integer → Add to cache? → Return new object",
          "comparisonTable": "Type|Cache Range\nByte|-128 to 127\nShort|-128 to 127\nInteger|-128 to 127 (configurable)\nLong|-128 to 127\nCharacter|0 to 127\nBoolean|TRUE, FALSE",
          "examples": []
        }
      },
      {
        "id": "s1-8-4",
        "title": "Use Cases of Wrapper Classes",
        "explanations": {
          "english": "Wrapper classes Java mein essential roles play karte hain jahan object semantics primitive data ke liye required hoti hain. Ye generic collections (List<Integer>, Map<String, Double>) ke liye mandatory hain kyunki generics primitives support nahi karte. Wrappers utility methods provide karte hain strings ko numbers mein parse karne ke liye (parseInt, parseDouble), doosre bases mein convert karne ke liye (toBinaryString, toHexString), aur values compare karne ke liye (compareTo). Ye nullability allow karte hain missing ya uninitialized data represent karne ke liye, primitives ke unlike jo zero ya false pe default hote hain. Reflection mein, method parameters aur return types Class objects ki tarah represent hote hain, numeric types ke liye wrappers require karte hain. Wrappers serialization bhi facilitate karte hain, jahan object state preserve karni padti hai, aur allow karte hain primitives ko synchronize karna jab locks ki tarah use kiye jaayein multithreading mein."
        },
        "code": {
          "title": "Wrapper Use Cases",
          "language": "java",
          "content": "// Collections require wrappers\nList<Double> prices = new ArrayList<>();\nprices.add(19.99); // Autoboxed\n\n// Parsing strings\nint port = Integer.parseInt(\"8080\");\ndouble rate = Double.parseDouble(\"3.14\");\n\n// Nullability for missing data\nInteger age = null; // Unknown age\n\n// Utility methods\nString binary = Integer.toBinaryString(255); // \"11111111\"\nint max = Integer.max(10, 20); // 20\n\n// Reflection\nClass<?> intClass = int.class; // Primitive\nClass<?> integerClass = Integer.class; // Wrapper"
        },
        "codeExplanations": {
          "english": "Examples wrappers ko ArrayList ke saath generics enable karte hue dikhate hain, configuration strings ko numbers mein parse karte hue, nullable database fields represent karte hue, numbers ko different string representations mein convert karte hue, aur comparison utilities provide karte hue. Reflection primitive aur wrapper class literals ke beech distinction dikhata hai."
        },
        "keyPoints": [
          "Generic collections ke liye required jo primitives use nahi kar sakte",
          "Parsing methods provide karte hain strings ko numeric types mein convert karne ke liye",
          "Undefined ya missing values represent karne ke liye null allow karte hain",
          "Base conversion, comparison, aur constants (MAX_VALUE) ke liye utility methods offer karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Use Case|Example|Primitive Alternative\nCollections|List<Integer>|Not possible\nParsing|Integer.parseInt()|Manual parsing\nNullability|Integer age = null|int defaults to 0\nUtilities|toHexString(), compare()|Not available\nReflection|Method param types|Class objects only",
          "examples": []
        }
      },
      {
        "id": "s1-9-1",
        "title": "Enum Basics",
        "explanations": {
          "english": "Java mein enumerations (enums) special classes hain jo fixed set of named constants define karte hain, discrete values ki type-safe representation provide karte hain. Enum keyword se declare kiye jaate hain, implicitly java.lang.Enum extend karte hain aur compile hote hain classes mein static final instances ke saath har constant ke liye. Enums full-fledged classes hain jinme fields, methods, constructors, aur interfaces implement kar sakte hain, kuchh aur languages mein simple constants ke unlike. Constants implicitly public static final hain aur allowed instances hi hain, har constant ke liye singleton behavior ensure karte hain. Enums built-in methods provide karte hain jaise values() saare constants ka array return karne ke liye, aur valueOf(String) name se lookup ke liye, unhe integer ya string constants se zyada robust banata hai."
        },
        "code": {
          "title": "Basic Enum Declaration",
          "language": "java",
          "content": "public enum Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, \n    THURSDAY, FRIDAY, SATURDAY\n}\n\n// Usage\nDay today = Day.MONDAY;\nif (today == Day.MONDAY) {\n    System.out.println(\"Start of work week\");\n}\n\n// Enum methods\nfor (Day d : Day.values()) {\n    System.out.println(d);\n}\n\nDay parsed = Day.valueOf(\"FRIDAY\");"
        },
        "codeExplanations": {
          "english": "Day enum week ke din represent karne wale seven constants define karta hai. Usage static fields ki tarah lagta hai type safety ke saath. Values() method saare constants iterate karne ke liye hai, aur valueOf() strings ko enum constants mein convert karta hai, invalid names pe IllegalArgumentException throw karta hai."
        },
        "keyPoints": [
          "Enums fixed set of named constants define karte hain type safety ke saath",
          "Implicitly java.lang.Enum extend karte hain; doosri classes extend nahi kar sakte",
          "Constants public static final instances hain enum type ke",
          "Built-in methods: values(), valueOf(), ordinal(), name(), compareTo()"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s1-9-2",
        "title": "Type-safe Constants",
        "explanations": {
          "english": "Enums ke through type-safe constants traditional integer ya string constant patterns ki weaknesses eliminate karte hain, compile time pe invalid values prevent karte hain runtime ki jagah. Public static final int constants ke unlike, enum constants arbitrary integers assign nahi kiye ja sakte ya same value ke unrelated constants ke saath confuse nahi hote hain. Enums switch statements mein participate karte hain compiler checking ke saath exhaustive coverage ke liye, warning dete hain agar cases missing hain. Type system ensure karta hai ki enum parameter accept karne wale methods sirf valid declared constants receive karein, defensive validation ki zaroorat eliminate karta hai. Ye safety serialization mein extend hoti hai, jahan enums singleton guarantees maintain karte hain, aur debugging mein, jahan meaningful names magic numbers replace karte hain."
        },
        "code": {
          "title": "Type Safety Benefits",
          "language": "java",
          "content": "// Integer constants (unsafe)\npublic static final int STATUS_PENDING = 0;\npublic static final int STATUS_ACTIVE = 1;\nsetStatus(999); // Compiles but invalid!\n\n// Enum (type-safe)\npublic enum Status { PENDING, ACTIVE, CLOSED }\n\npublic void setStatus(Status s) { /* ... */ }\n\nsetStatus(Status.PENDING); // Valid\n// setStatus(999); // Compile error!\n// setStatus(\"PENDING\"); // Compile error!\n\n// Switch safety\nswitch (status) {\n    case PENDING: break;\n    case ACTIVE: break;\n    case CLOSED: break;\n    // Missing case causes compiler warning\n}"
        },
        "codeExplanations": {
          "english": "Comparison dikhata hai ki integer constants compile time pe koi bhi int value accept karte hain, runtime validation require karte hain. Enums compile time pe invalid values reject karte hain. Switch statement exhaustiveness checking demonstrate karta hai, jahan compiler verify kar sakta hai ki saare enum constants handled hain."
        },
        "keyPoints": [
          "Compiler invalid values ka assignment prevent karta hai, jaldi errors catch karta hai",
          "Enum constants doosre enums ya arbitrary values ke saath confuse nahi ho sakte",
          "Switch statements enums ke liye exhaustiveness checking provide karte hain",
          "Manual range checking aur validation code ki zaroorat eliminate karte hain"
        ],
        "extras": {
          "flowDiagram": "Integer constant: setStatus(999) → Compile OK → Runtime error/bug\nEnum constant: setStatus(999) → Compile ERROR → Catch early",
          "comparisonTable": "Feature|int Constants|Enums\nType safety|None|Full\nNamespace|Global|Scoped to enum\nSwitch safety|None|Exhaustiveness check\nValidation|Manual|Automatic\nDebugging|Magic numbers|Meaningful names",
          "examples": []
        }
      },
      {
        "id": "s1-9-3",
        "title": "Enum Fields & Methods",
        "explanations": {
          "english": "Java mein enums fields, methods, aur constructors declare kar sakte hain data aur behavior associate karne ke liye constants ke saath, unhe powerful class-like structures banata hai. Har enum constant apni abstract methods ki implementation rakh sakta hai, effectively polymorphic behavior allow karta hai per constant. Constructors private ya package-private hone chahiye, automatically invoke hote hain jab constants class loading ke dauraan create hote hain. Fields state store karte hain specific to har constant instance, jaise display names ya associated values. Methods enum ki state pe operate kar sakte hain ya utility functionality provide kar sakte hain. Ye capability enums ko simple constant lists se rich objects mein transform karta hai encapsulation ke saath, complex domain modeling enable karta hai jaise transition logic ke saath state machines ya associated metadata ke saath configuration."
        },
        "code": {
          "title": "Enum with Fields and Methods",
          "language": "java",
          "content": "public enum Planet {\n    MERCURY(3.303e+23, 2.4397e6),\n    VENUS(4.869e+24, 6.0518e6),\n    EARTH(5.976e+24, 6.37814e6);\n    \n    private final double mass;\n    private final double radius;\n    \n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    \n    public double surfaceGravity() {\n        return 6.67300E-11 * mass / (radius * radius);\n    }\n    \n    public double surfaceWeight(double otherMass) {\n        return otherMass * surfaceGravity();\n    }\n}\n\n// Usage\ndouble weightOnEarth = Planet.EARTH.surfaceWeight(80);"
        },
        "codeExplanations": {
          "english": "Ye enum planets define karta hai mass aur radius fields ke saath private constructor initialize karta hai. Har constant (MERCURY, VENUS, EARTH) apni specific values ke saath constructor call karta hai. Instance methods surface gravity aur weight calculate karte hain, demonstrate karte hain kaise enums regular classes ki tarah data aur behavior encapsulate kar sakte hain."
        },
        "keyPoints": [
          "Enums regular classes ki tarah fields, constructors, aur methods rakh sakte hain",
          "Constructors private hone chahiye; automatically har constant ke liye call hote hain",
          "Har enum constant unique data constructor ke through rakh sakta hai",
          "Abstract methods har constant ke liye override kiye ja sakte hain polymorphic behavior ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "State machine with transitions",
            "Error codes with messages and HTTP status"
          ]
        }
      },
      {
        "id": "s1-9-4",
        "title": "Enum vs Constant Interfaces",
        "explanations": {
          "english": "Constant interfaces ek anti-pattern hain jahan interfaces sirf constants export karne ke liye use hote hain implementing classes ko, ek practice jo Java ki static import feature aur enums ke aane se deprecated ho gayi hai. Enums superior type safety, namespace scoping, aur compile-time checking provide karte hain classes ya interfaces mein scattered constants ki jagah. Constant interfaces implementing class ki public API ko pollute karte hain, implementation details expose karte hain, aur values change hone prevent nahi kar sakte. Enums related constants ko single type ke under group karte hain built-in iteration aur conversion methods ke saath. Jabki constant interfaces early Java mein event codes ya status flags ke liye common the, modern practice discrete value sets ke liye enums favor karta hai ya utility classes mein static final fields un constants ke liye jo type safety require nahi karte."
        },
        "code": {
          "title": "Comparison Patterns",
          "language": "java",
          "content": "// Constant Interface (Anti-pattern)\npublic interface MathConstants {\n    double PI = 3.14159;\n    double E = 2.71828;\n}\n\n// Enum replacement\npublic enum MathConstant {\n    PI(3.14159),\n    E(2.71828);\n    \n    private final double value;\n    MathConstant(double v) { this.value = v; }\n    public double value() { return value; }\n}\n\n// Static import alternative\npublic class Constants {\n    public static final int MAX_SIZE = 100;\n}\n// import static Constants.MAX_SIZE;"
        },
        "codeExplanations": {
          "english": "Constant interface pattern implementers ko constants inherit karne pe force karta hai, unke namespace ko pollute karta hai. Enum version type-safe, scoped constants provide karta hai behavior attach karne ki ability ke saath. Simple constants jo type safety nahi chahiye unke liye utility classes se static imports preferred hain interfaces ke over."
        },
        "keyPoints": [
          "Constant interfaces anti-patterns hain; avoid karein interfaces sirf constants ke liye use karna",
          "Enums type safety aur scoping provide karte hain jo constant interfaces mein missing hai",
          "Static imports namespace access provide karte hain bina interface implementation ke",
          "Enums namespace pollution prevent karte hain aur iteration/lookup utilities provide karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Aspect|Constant Interface|Enum\nType safety|None|Full\nNamespace|Pollutes implementer|Scoped to enum\nIteration|Not possible|values() method\nImplementation|Inheritance required|No inheritance\nCompile-time checking|None|Exhaustive switch checks",
          "examples": []
        }
      }
    ]
  },
  {
    "id": "section-2",
    "title": "Object-Oriented Programming (OOP) Concepts",
    "topics": [
      {
        "id": "s2-1-1",
        "title": "Class Structure",
        "explanations": {
          "english": "Java mein class ek blueprint ya template hai jo objects ki structure aur behavior define karta hai. Ye user-defined data type ki tarah kaam karta hai jo data (fields/attributes) aur operations (methods) ko encapsulate karta hai jo us data pe operate karte hain. Class declaration mein modifiers (public, abstract, final), class keyword, class name, optional inheritance (extends) aur interface implementation (implements) clauses, aur body shaamil hai jo fields, constructors, methods, aur nested types contain karta hai. Class body state variables (instance aur static fields) aur behaviors define karta hai jo class ke instances possess karenge. Well-designed classes Single Responsibility Principle follow karte hain, related data aur behavior ko saath rakhte hue implementation details ko outside access se chhupate hain."
        },
        "code": {
          "title": "Class Declaration Structure",
          "language": "java",
          "content": "public class Employee {\n    // Fields (state)\n    private String name;\n    private int id;\n    private double salary;\n    \n    // Constructor\n    public Employee(String name, int id, double salary) {\n        this.name = name;\n        this.id = id;\n        this.salary = salary;\n    }\n    \n    // Methods (behavior)\n    public void raiseSalary(double percentage) {\n        this.salary += this.salary * (percentage / 100);\n    }\n    \n    public String getDetails() {\n        return id + \": \" + name + \" ($\" + salary + \")\";\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye Employee class standard structure demonstrate karti hai: private fields state encapsulate karte hain, constructor new instances initialize karta hai, aur public methods controlled access provide karte hain behavior ko. raiseSalary method internal state modify karta hai jabki getDetails formatted read access provide karta hai, data hiding with behavior illustrate karte hue."
        },
        "keyPoints": [
          "Classes templates hain jo object structure (fields) aur behavior (methods) define karte hain",
          "Access modifiers visibility control karte hain; private fields with public methods standard hai",
          "Constructors new objects initialize karte hain; multiple constructors overloaded ho sakte hain",
          "Class names PascalCase use karte hain aur typically nouns ya entities represent karte hain"
        ],
        "extras": {
          "flowDiagram": "Class Declaration → Fields → Constructors → Methods → Nested Types",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-1-2",
        "title": "Object Creation",
        "explanations": {
          "english": "Java mein object creation instantiation involve karta hai, jahan 'new' keyword memory allocate karta hai aur constructor ko invoke karta hai new instance initialize karne ke liye. Process new operator se shuru hota hai jo heap memory allocate karta hai object ke instance fields ke liye, phir constructor call karta hai initial state set karne ke liye. 'New' expression ek reference (memory address) return karta hai jo reference variable mein store hota hai, allowing access to object members via dot (.) operator. Har object apni instance variables ki copy maintain karta hai, same class ke doosre instances se separate. Object creation class constructor chain trigger karta hai, potentially parent class constructors ko pehle invoke karta hai implicit ya explicit super() calls ke through."
        },
        "code": {
          "title": "Creating Objects",
          "language": "java",
          "content": "// Declaration and instantiation\nEmployee emp1 = new Employee(\"Alice\", 101, 50000.0);\n\n// Multiple references to same object\nEmployee emp2 = emp1;\nemp2.raiseSalary(10); // Affects emp1 too\n\n// Separate objects\nEmployee emp3 = new Employee(\"Bob\", 102, 60000.0);\n\n// Anonymous object\nnew Employee(\"Temp\", 999, 0.0).getDetails();"
        },
        "codeExplanations": {
          "english": "Code object instantiation with new dikhata hai, references ki assignment, aur references copy karne (emp2=emp1 same object ko point karta hai) aur new objects create karne (emp3 separate hai) ke beech difference. Anonymous objects immediately create aur use hote hain bina references store kiye, one-time operations ke liye useful."
        },
        "keyPoints": [
          "new keyword memory allocate karta hai aur constructor invoke karke instances create karta hai",
          "Object references memory addresses store karte hain jo heap-allocated objects ki taraf point karte hain",
          "Multiple variables same object ko reference kar sakte hain (aliasing)",
          "Har new operation ek distinct object create karta hai apne khud ke field values ke saath"
        ],
        "extras": {
          "flowDiagram": "new Employee() → Heap Allocation → Constructor Execution → Reference Return → Variable Assignment",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-1-3",
        "title": "State vs Behavior",
        "explanations": {
          "english": "State aur behavior OOP mein objects ke do fundamental aspects hain. State object ki current condition ya data represent karta hai, fields (instance variables) mein store hota hai jo har instance ke liye specific values maintain karta hai. Behavior represent karta hai object kya kar sakta hai ya uske saath kya kiya ja sakta hai, methods ke through implement hota hai jo object ki state pe operate karte hain. State (data) aur behavior (operations) ka separation allow karta hai objects ko consistent internal conditions maintain karne mein jabki controlled functionality doosre objects ko expose hoti hai. Well-designed objects apni state chhupate hain (encapsulation) aur behavior expose karte hain well-defined interfaces ke through, ensure karte hue ki state changes sirf validated methods ke through hote hain jo object integrity aur invariants maintain karte hain."
        },
        "code": {
          "title": "State and Behavior Example",
          "language": "java",
          "content": "public class BankAccount {\n    // State (fields)\n    private String accountNumber;\n    private double balance;\n    private boolean active;\n    \n    // Behavior (methods)\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    public boolean withdraw(double amount) {\n        if (amount > 0 && balance >= amount) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}"
        },
        "codeExplanations": {
          "english": "BankAccount state (accountNumber, balance, active) encapsulate karta hai aur behavior (deposit, withdraw, getBalance) expose karta hai. Balance state sirf un methods ke through modify ho sakta hai jo business rules enforce karte hain (positive amounts, sufficient funds), invalid states prevent karte hain jo direct field access allow karega."
        },
        "keyPoints": [
          "State (fields) object data represent karta hai; behavior (methods) operations represent karte hain",
          "State private honi chahiye; behavior public access control ke liye",
          "Methods object invariants maintain karte hain state changes validate karke",
          "Behavior current state pe depend kar sakta hai decisions lene ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Aspect|State|Behavior\nRepresentation|Fields/Variables|Methods\nAccess|Private (encapsulated)|Public (interface)\nPurpose|Store data|Operate on data\nModification|Through methods only|Executes logic",
          "examples": []
        }
      },
      {
        "id": "s2-1-4",
        "title": "Object Lifecycle",
        "explanations": {
          "english": "Java mein object lifecycle creation, usage, aur destruction phases ko encompass karta hai jo JVM manage karta hai. Creation occur hota hai jab 'new' invoke kiya jaata hai, memory allocate hoti hai aur constructors valid state mein lane ke liye run hote hain. Usage ke dauraan, object ko variables reference karte hain aur actively program operations mein participate karta hai, uski state potentially method invocations ke through change hoti hai. Objects destruction ke liye eligible ho jaate hain jab koi live thread unka koi bhi reference hold nahi karta (unreachable). JVM garbage collector automatically ye memory reclaim karta hai, finalize() method call karta hai (modern Java mein deprecated) destruction se pehle agar overridden ho. C++ ke unlike, Java on-demand object destruction support nahi karta, automatic garbage collection pe rely karta hai memory leaks prevent karne ke liye jabki developer responsibility simplify karta hai."
        },
        "code": {
          "title": "Lifecycle Demonstration",
          "language": "java",
          "content": "public class LifecycleDemo {\n    public LifecycleDemo() {\n        System.out.println(\"Object created\");\n    }\n    \n    public void doWork() {\n        System.out.println(\"Object in use\");\n    }\n    \n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"Object being destroyed\");\n    }\n    \n    public static void main(String[] args) {\n        LifecycleDemo obj = new LifecycleDemo(); // Creation\n        obj.doWork(); // Usage\n        obj = null; // Dereference\n        System.gc(); // Suggest garbage collection\n    }\n}"
        },
        "codeExplanations": {
          "english": "Constructor creation pe print karta hai, doWork active phase represent karta hai, aur reference ko null set karna object ko garbage collection ke liye eligible banata hai. finalize() (deprecated) print karega destruction se pehle agar call ho. System.gc() JVM ko hint hai, forced destruction command nahi."
        },
        "keyPoints": [
          "Objects tab shuru hote hain jab new memory allocate karta hai aur constructors run hote hain",
          "Active phase mein method calls aur state modifications involve hote hain",
          "Objects GC ke liye eligible ho jaate hain jab unreachable (no references)",
          "Garbage collector automatically memory reclaim karta hai; destruction timing non-deterministic hai"
        ],
        "extras": {
          "flowDiagram": "new → [Created] → Reference Assigned → [In Use] → Reference Null → [Eligible for GC] → finalize() → [Destroyed]",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-2-1",
        "title": "Single Inheritance",
        "explanations": {
          "english": "Java mein single inheritance allow karta hai ki ek class exactly ek parent class extend kare, 'is-a' relationship establish karta hai jahan subclass superclass se fields aur methods inherit karta hai. Ye multiple inheritance (diamond problem) ki complexity aur ambiguity prevent karta hai jabki code reuse aur hierarchical classification enable karta hai. Subclass inherited members ko access karta hai based on unki visibility (public aur protected members accessible hain, private nahi). Java 'extends' keyword use karta hai ye relationship establish karne ke liye. Single inheritance cleaner class hierarchies promote karta hai aur developers ko force karta hai composition use karne ke liye multiple sources se functionality share karne ke liye, leading to more maintainable aur less coupled designs."
        },
        "code": {
          "title": "Single Inheritance Example",
          "language": "java",
          "content": "// Parent class\npublic class Vehicle {\n    protected String brand;\n    \n    public void honk() {\n        System.out.println(\"Beep beep!\");\n    }\n}\n\n// Child class\npublic class Car extends Vehicle {\n    private int trunkCapacity;\n    \n    public void displayBrand() {\n        System.out.println(\"Brand: \" + brand); // Inherited field\n    }\n}\n\n// Usage\nCar myCar = new Car();\nmyCar.honk(); // Inherited method\nmyCar.displayBrand(); // Own method"
        },
        "codeExplanations": {
          "english": "Vehicle parent hai protected field brand aur method honk() ke saath. Car Vehicle extend karta hai, ye members inherit karta hai aur apna trunkCapacity field add karta hai. Car instance inherited honk() aur apna displayBrand() method use kar sakta hai, is-a relationship demonstrate karte hue."
        },
        "keyPoints": [
          "Java single inheritance support karta hai: ek class sirf ek direct superclass extend kar sakta hai",
          "extends keyword parent-child relationship establish karta hai",
          "Child accessible fields aur methods parent se inherit karta hai",
          "Composition ko promote karta hai multiple inheritance ki jagah cleaner designs ke liye"
        ],
        "extras": {
          "flowDiagram": "Vehicle (superclass)\n    ↑ extends\n   Car (subclass)",
          "comparisonTable": "Feature|Inheritance|Composition\nRelationship|Is-a|Has-a\nKeyword|extends|Instance field\nCoupling|Tight|Loose\nMultiple|Not allowed|Unlimited",
          "examples": []
        }
      },
      {
        "id": "s2-2-2",
        "title": "Multilevel Inheritance",
        "explanations": {
          "english": "Multilevel inheritance ek chain create karta hai inheritance ka jahan ek class subclass extend karti hai, jo turn mein doosri class extend karti hai, multiple levels ke saath hierarchy form karta hai. Jabki ye progressive specialization allow karta hai (e.g., Vehicle → Car → ElectricCar), deep inheritance chains complexity badhate hain aur maintainability reduce karte hain. Har level apne ancestors ke saare accessible members inherit karta hai, potentially leading to fragile base class problems jahan high-level classes mein changes lower-level implementations break kar sakte hain. Java ye pattern allow karta hai lekin recommend karta hai ki inheritance hierarchies shallow rakhein (preferably 3 levels se gehra nahi) code clarity preserve karne aur distant ancestors aur descendants ke beech coupling reduce karne ke liye."
        },
        "code": {
          "title": "Multilevel Chain",
          "language": "java",
          "content": "class Animal {\n    void eat() { System.out.println(\"Eating...\"); }\n}\n\nclass Mammal extends Animal {\n    void breathe() { System.out.println(\"Breathing...\"); }\n}\n\nclass Dog extends Mammal {\n    void bark() { System.out.println(\"Woof!\"); }\n}\n\n// Usage\nDog dog = new Dog();\ndog.eat();      // From Animal\ndog.breathe();  // From Mammal\ndog.bark();     // Own method"
        },
        "codeExplanations": {
          "english": "Inheritance chain teen levels tak extend hoti hai: Animal grandparent hai, Mammal Dog ka parent hai aur Animal ka child, aur Dog grandchild hai. Dog eat() Animal se aur breathe() Mammal se inherit karta hai jabki apna bark() define karta hai. Ye demonstrate karta hai features hierarchy mein kaise accumulate hote hain."
        },
        "keyPoints": [
          "Multilevel inheritance parent-child-grandchild relationships create karta hai",
          "Har class apne immediate parent se inherit karti hai, jo doosri se inherit kar sakta hai",
          "Deep hierarchies maintenance complicate karte hain aur fragility badhate hain",
          "Inheritance chains shallow rakhein (recommended max 3 levels) maintainability ke liye"
        ],
        "extras": {
          "flowDiagram": "Animal\n    ↑\n  Mammal\n    ↑\n    Dog",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-2-3",
        "title": "Hierarchical Inheritance",
        "explanations": {
          "english": "Hierarchical inheritance occur hota hai jab multiple classes ek single parent class extend karti hain, tree-like structure create karta hai jahan ek superclass ke multiple subclasses hote hain. Ye pattern common hai specialized variants create karne ke liye ek general concept ke, jaise different types of BankAccount (SavingsAccount, CheckingAccount, LoanAccount) extending ek base Account class. Har sibling class parent se common functionality inherit karti hai jabki specific features add karti hai. Ye code reuse promote karta hai shared behavior parent mein place karke jabki children mein customization allow karta hai. Parent class general enough design karni chahiye saare child implementations support karne ke liye bina unke specific details jaane, Liskov Substitution Principle follow karte hue."
        },
        "code": {
          "title": "Hierarchical Structure",
          "language": "java",
          "content": "abstract class Shape {\n    protected String color;\n    \n    public abstract double calculateArea();\n    \n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width, height;\n    \n    public double calculateArea() {\n        return width * height;\n    }\n}\n\nclass Triangle extends Shape {\n    private double base, height;\n    \n    public double calculateArea() {\n        return 0.5 * base * height;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Shape parent ke roop mein kaam karta hai common color field aur abstract calculateArea() ke saath. Teen subclasses (Circle, Rectangle, Triangle) color aur setColor() inherit karte hain lekin distinct area calculations provide karte hain. Ye hierarchy allow karta hai saare shapes ko polymorphically treat karna jabki each specific geometry implement karta hai."
        },
        "keyPoints": [
          "Multiple classes same parent class extend karti hain",
          "Parent mein common functionality; children mein specialization",
          "Sibling classes ka polymorphic treatment enable karta hai",
          "Code reuse support karta hai jabki specific implementations allow karta hai"
        ],
        "extras": {
          "flowDiagram": "    Shape\n    /  |  \\\nCircle Rectangle Triangle",
          "comparisonTable": "",
          "examples": [
            "Employee ← Manager/Engineer/SalesPerson",
            "Vehicle ← Car/Truck/Motorcycle"
          ]
        }
      },
      {
        "id": "s2-2-4",
        "title": "super Keyword",
        "explanations": {
          "english": "Java mein super keyword subclass ke andar se superclass members (fields, methods, constructors) ko access karne provide karta hai. super.field hidden parent fields ko access karta hai jab names shadowing ki wajah se conflict karte hain. super.method() overridden parent methods ko invoke karta hai, extension allow karta hai replacement ki jagah. super() parent class constructors ko call karta hai aur subclass constructor mein pehla statement hona chahiye; agar omit kiya jaata hai toh compiler implicitly parent ke no-arg constructor ko call karne ka code insert karta hai. Ye ensure karta hai ki inherited state proper initialize ho subclass initialization se pehle. Super use karna essential hai jab subclass ko parent class functionality leverage ya extend karni ho jabki encapsulation maintain rakhe."
        },
        "code": {
          "title": "Super Keyword Usage",
          "language": "java",
          "content": "class Person {\n    protected String name;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n    \n    public void display() {\n        System.out.println(\"Name: \" + name);\n    }\n}\n\nclass Employee extends Person {\n    private int employeeId;\n    \n    public Employee(String name, int id) {\n        super(name); // Call parent constructor\n        this.employeeId = id;\n    }\n    \n    @Override\n    public void display() {\n        super.display(); // Call parent method\n        System.out.println(\"ID: \" + employeeId);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Employee constructor super(name) use karta hai inherited name field initialize karne se pehle apna employeeId set karta hai. Overridden display() method super.display() use karta hai parent ka name printing logic reuse karne ke liye, phir ID printing add karta hai. Dono super uses code duplication prevent karte hain aur proper initialization ensure karte hain."
        },
        "keyPoints": [
          "super() parent constructor call karta hai; child constructor mein pehla statement hona chahiye",
          "super.method() overridden parent methods ka version invoke karta hai",
          "super.field parent fields ko access karta hai jab child fields se hidden ho",
          "Agar super() omit kiya jaata hai compiler super() (no-arg) implicitly insert karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Usage|Syntax|Purpose\nConstructor call|super(args)|Initialize parent state\nMethod call|super.method()|Access parent method implementation\nField access|super.field|Access hidden parent field",
          "examples": []
        }
      },
      {
        "id": "s2-2-5",
        "title": "Method Overriding",
        "explanations": {
          "english": "Method overriding occur hota hai jab subclass specific implementation provide karta hai ek method ke liye jo already uske parent class mein defined hai identical signature (name, parameter types, return type) ke saath. Override same ya less restrictive access modifier hona chahiye aur same ya fewer checked exceptions throw kar sakta hai (covariant return types allowed). @Override annotation use karna chahiye intent signal karne aur compile-time verification enable karne ke liye. Overriding runtime polymorphism enable karta hai, allow karta hai objects ko different behaviors exhibit karne based on unki actual class rather than reference type. JVM dynamic method dispatch use karta hai determine karne ke liye kaunsa implementation runtime pe invoke karna hai object ki actual class ke based."
        },
        "code": {
          "title": "Method Overriding",
          "language": "java",
          "content": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof\");\n    }\n}\n\n// Usage\nAnimal myPet = new Cat();\nmyPet.makeSound(); // Outputs \"Meow\""
        },
        "codeExplanations": {
          "english": "Animal makeSound() define karta hai, jo Cat aur Dog specific implementations ke saath override karte hain. @Override annotation verify karta hai ki method parent mein exist karta hai. Jab myPet (Animal declare kiya gaya lekin Cat hold karta hai) makeSound() call karta hai, JVM runtime pe Cat's version dispatch karta hai, polymorphic behavior demonstrate karte hue."
        },
        "keyPoints": [
          "Subclass provide karta hai parent method ki specific implementation same signature ke saath",
          "@Override annotation use karein compile time pe signature mismatches catch karne ke liye",
          "Access modifier zyada restrictive nahi ho sakta; return type covariant ho sakta hai",
          "Runtime polymorphism enable karta hai dynamic method dispatch ke through"
        ],
        "extras": {
          "flowDiagram": "Reference: Animal → Object: Cat → Calls Cat.makeSound()\nDespite declared type Animal, runtime type determines method",
          "comparisonTable": "Feature|Overloading|Overriding\nLocation|Same class|Parent-Child classes\nParameters|Must differ|Must be identical\nReturn Type|Can differ|Same or covariant\nBinding|Compile time|Runtime",
          "examples": []
        }
      },
      {
        "id": "s2-3-1",
        "title": "Compile-time Polymorphism",
        "explanations": {
          "english": "Compile-time polymorphism (static polymorphism) Java mein method overloading ke through achieve kiya jaata hai, jahan same class mein multiple methods share karte hain name lekin different parameter lists ke saath. Compiler determine karta hai kaunsa method invoke karna hai method signature ke based compile time pe, hence 'static' binding. Isme differences parameter count, types, ya order mein shaamil hain. Resolution compilation ke dauraan hota hai, execution ko faster banata hai kyunki runtime decision ki zaroorat nahi hoti. Method overloading intuitive APIs provide karta hai jahan similar operations share names lekin different data types ya argument counts handle karte hain. Ye code readability improve karta hai aur related operations ke liye artificially distinct method names ki zaroorat reduce karta hai."
        },
        "code": {
          "title": "Compile-time Polymorphism",
          "language": "java",
          "content": "class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\n// Usage determined at compile time\nCalculator calc = new Calculator();\nint sum1 = calc.add(5, 3);        // Calls int version\ndouble sum2 = calc.add(5.5, 3.2); // Calls double version\nint sum3 = calc.add(1, 2, 3);     // Calls 3-param version"
        },
        "codeExplanations": {
          "english": "Calculator class compile-time polymorphism ko teen add methods ke through demonstrate karta hai. Compiler compilation ke dauraan appropriate method select karta hai based on argument types aur count. Int parameters int version call karte hain, doubles double version ko, aur teen arguments three-parameter version ko resolve karte hain."
        },
        "keyPoints": [
          "Same class mein method overloading ke through achieve kiya jaata hai",
          "Compiler method calls ko definitions se compile time pe bind karta hai",
          "Resolution method signature (name + parameter types/count) ke based hota hai",
          "Static binding ya early binding bhi kaha jaata hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Aspect|Compile-time|Runtime\nBinding time|Compilation|Execution\nMechanism|Overloading|Overriding\nDecision maker|Compiler|JVM\nPerformance|Faster|Runtime overhead",
          "examples": []
        }
      },
      {
        "id": "s2-3-2",
        "title": "Runtime Polymorphism",
        "explanations": {
          "english": "Runtime polymorphism (dynamic polymorphism) Java mein method overriding ke through achieve kiya jaata hai, jahan actual object ki type determine karta hai kaunsa method implementation execute hoga, reference type nahi. Ye allow karta hai parent class reference ko child class objects ki taraf point karne aur unke specific implementations invoke karne. JVM dynamic method dispatch use karta hai runtime pe method call resolve karne ke liye object ki class ko memory mein examine karke. Ye flexible, extensible code likhne allow karta hai superclass references ke saath kaam karte hue jabki subclass-specific behaviors execute hote hain. Ye frameworks, plugin architectures, aur dependency injection ka foundation hai jahan implementations swap ho sakte hain bina client code change kiye."
        },
        "code": {
          "title": "Runtime Polymorphism",
          "language": "java",
          "content": "interface Payment {\n    void process(double amount);\n}\n\nclass CreditCard implements Payment {\n    public void process(double amount) {\n        System.out.println(\"Processing credit card: $\" + amount);\n    }\n}\n\nclass PayPal implements Payment {\n    public void process(double amount) {\n        System.out.println(\"Processing PayPal: $\" + amount);\n    }\n}\n\n// Flexible client code\npublic void checkout(Payment payment, double amount) {\n    payment.process(amount); // Runtime decision\n}\n\n// Usage\ncheckout(new CreditCard(), 100.0); // CreditCard's process\ncheckout(new PayPal(), 50.0);      // PayPal's process"
        },
        "codeExplanations": {
          "english": "Checkout method koi bhi Payment implementation accept karta hai. Runtime pe JVM determine karta hai actual object CreditCard hai ya PayPal aur appropriate process() method invoke karta hai. Same checkout code kisi bhi future Payment implementation ke saath kaam karega bina modification ke, extensibility demonstrate karte hue runtime polymorphism ke through."
        },
        "keyPoints": [
          "Method call runtime pe resolve hota hai actual object type ke based, reference type nahi",
          "Inheritance (class extends) ya interface implementation require karta hai",
          "Different implementations interchangeably substitute karne allow karta hai",
          "Loosely coupled, extensible architectures ka foundation hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "Collections.sort() with different Comparator implementations"
          ]
        }
      },
      {
        "id": "s2-3-3",
        "title": "Method Overloading vs Overriding",
        "explanations": {
          "english": "Method overloading aur overriding distinct polymorphism mechanisms hain different purposes serve karte hue. Overloading same class mein occur karta hai (ya parent-child inheritance ke saath), same method name lekin different parameters use karta hai; ye compile-time concept hai convenience ke liye. Overriding parent aur child classes ke beech occur karta hai identical signatures ke saath, runtime specialization allow karta hai; ye behavioral inheritance ke liye object-oriented concept hai. Overloading 'how many' ya 'what type' arguments ke baare mein hai, jabki overriding 'which implementation' object type ke based hai. Overloading mein parameter differences chahiye, jabki overriding mein identical signatures chahiye. Dono samajhna crucial hai intuitive APIs aur inheritance hierarchies design karne ke liye."
        },
        "code": {
          "title": "Overloading vs Overriding",
          "language": "java",
          "content": "class Parent {\n    // Overloading example\n    public void display(int x) { }\n    public void display(String s) { } // Overloaded\n    \n    public void show() { \n        System.out.println(\"Parent\");\n    }\n}\n\nclass Child extends Parent {\n    // Overriding example\n    @Override\n    public void show() { \n        System.out.println(\"Child\"); // Overridden\n    }\n    \n    // Overloading inherited method\n    public void display(double d) { } // Also overloaded\n}"
        },
        "codeExplanations": {
          "english": "Parent demonstrate karta hai overloading do display methods ke saath jo parameter type mein differ karte hain. Child override karta hai show() specific behavior provide karne ke liye aur overload bhi karta hai display() double version add karke. Ye dikhata hai overloading class mein ya inheritance across ho sakta hai, jabki overriding specific inheritance ko hai."
        },
        "keyPoints": [
          "Overloading: Same name, different parameters, compile-time resolution",
          "Overriding: Same signature, different implementation, runtime resolution",
          "Overloading horizontal hai (same level); overriding vertical hai (hierarchy)",
          "Overloading inheritance se independent hai; overriding require karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Criteria|Overloading|Overriding\nClass scope|Same class|Parent-Child\nParameters|Must differ|Must be identical\nReturn type|Can differ|Same or covariant\nAccess modifier|Any|Cannot be more restrictive\nStatic|Allowed|Not applicable to instance methods\nBinding|Compile time|Runtime",
          "examples": []
        }
      },
      {
        "id": "s2-3-4",
        "title": "Dynamic Method Dispatch",
        "explanations": {
          "english": "Dynamic method dispatch ye mechanism hai jisse JVM determine karta hai kaunsa overridden method runtime pe invoke karna hai object ki actual class ke based, reference type nahi. Jab ek method ko reference pe call kiya jaata hai, JVM heap mein object ki class examine karta hai implementation find karne ke liye, inheritance hierarchy mein upar walk karta hai agar zaroorat ho. Ye late binding polymorphism enable karta hai, allow karta hai methods superclass references ke saath kaam karte hue jabki subclass-specific code execute hota hai. Dispatch method tables (vtables) ke through optimize kiya jaata hai jo har class ke liye methods ko unke implementations se map karte hain. Ye mechanism loose coupling aur dependency inversion achieve karne ke liye fundamental hai object-oriented design mein."
        },
        "code": {
          "title": "Dispatch Mechanism",
          "language": "java",
          "content": "class Animal {\n    void speak() { System.out.println(\"Animal speaks\"); }\n}\n\nclass Dog extends Animal {\n    void speak() { System.out.println(\"Dog barks\"); }\n}\n\nclass Cat extends Animal {\n    void speak() { System.out.println(\"Cat meows\"); }\n}\n\npublic void makeItSpeak(Animal animal) {\n    animal.speak(); // JVM decides at runtime\n}\n\n// Demonstration\nmakeItSpeak(new Dog()); // \"Dog barks\"\nmakeItSpeak(new Cat()); // \"Cat meows\""
        },
        "codeExplanations": {
          "english": "MakeItSpeak Animal reference accept karta hai lekin JVM runtime pe actual object type (Dog ya Cat) inspect karta hai determine karne ke liye kaunsa speak() method execute karna hai. Ye late binding same method call ko different behaviors produce karne allow karta hai bina conditional logic ke, Open/Closed Principle follow karte hue."
        },
        "keyPoints": [
          "JVM runtime pe method implementation determine karta hai actual object class ke based",
          "Parent class references ke through subclass methods call karne allow karta hai",
          "Method resolution hierarchy mein upar walk karta agar child mein nahi milta",
          "Method tables (vtables) ke through efficiently implement kiya jaata hai performance ke liye"
        ],
        "extras": {
          "flowDiagram": "Call animal.speak() → JVM checks object type → \nIf Dog: execute Dog.speak() → \nIf Cat: execute Cat.speak() →\nFallback to Animal.speak() if not overridden",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-4-1",
        "title": "Abstract Classes",
        "explanations": {
          "english": "Java mein abstract classes abstract modifier se declare ki jaati hain aur directly instantiate nahi ho sakti; ye concrete subclasses ke liye templates ki tarah kaam karti hain. Unme abstract methods ho sakte hain (implementation ke bina declare kiye) jo subclasses ko force karte hain specific implementations provide karne ke liye, saath hi concrete methods bhi ho sakte hain default behavior ke saath. Abstract classes mein fields, constructors, aur static methods ho sakte hain, Java 8 se pehle interfaces ke unlike. Ye 'is-a' relationships represent karti hain partial implementation ke saath, useful hain related classes ke beech code share karne ke liye jabki certain methods implement kiye jaane enforce karte hain. Jab ek class abstract class extend karti hai, usse saare abstract methods implement karne honge ya khud abstract declare karni hogi."
        },
        "code": {
          "title": "Abstract Class Implementation",
          "language": "java",
          "content": "abstract class Shape {\n    protected String color;\n    \n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    // Abstract method\n    public abstract double calculateArea();\n    \n    // Concrete method\n    public void displayColor() {\n        System.out.println(\"Color: \" + color);\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Shape abstract hai ek abstract method (calculateArea) jo implementation force karta hai aur ek concrete method (displayColor) jo shared functionality provide karta hai. Circle Shape extend karta hai, calculateArea implement karta hai, aur super constructor call karta hai. Abstract classes 'new' se instantiate nahi ho sakti, sirf subclass ki ja sakti hai."
        },
        "keyPoints": [
          "Instantiate nahi ho sakti; concrete classes se extend karni padti hai",
          "Abstract (no body) aur concrete (with body) methods dono contain kar sakti hain",
          "Fields, constructors, aur initialization blocks ho sakte hain",
          "Subclass implementation abstract methods ki via compilation checks force karti hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-4-2",
        "title": "Interfaces",
        "explanations": {
          "english": "Java mein interfaces contracts define karte hain jo classes implement karne agree karte hain, methods specify karte hain bina implementation provide kiye (Java 8 se pehle). Interface keyword se declare kiye jaate hain, by default method signatures aur static final constants contain karte hain. Java 8 se interfaces mein default methods implementations ke saath aur static methods include ho sakte hain. Java 9 ne private methods add kiye code reuse ke liye interfaces ke andar. Interfaces type ka multiple inheritance support karte hain, allow karte hain ek class ko multiple interfaces implement karne. Ye 'can-do' capabilities represent karte hain (e.g., Comparable, Serializable) aur loose coupling enable karte hain interfaces ko concrete classes ki jagah program karke. Saare methods implicitly public abstract hote hain unless specified otherwise."
        },
        "code": {
          "title": "Interface Definition",
          "language": "java",
          "content": "interface Drawable {\n    // Implicitly public abstract\n    void draw();\n    \n    // Default method (Java 8+)\n    default void printInfo() {\n        System.out.println(\"This is drawable\");\n    }\n    \n    // Static method\n    static void describe() {\n        System.out.println(\"Drawable interface\");\n    }\n}\n\nclass Rectangle implements Drawable {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing rectangle\");\n    }\n}"
        },
        "codeExplanations": {
          "english": "Drawable interface ek contract define karta hai abstract draw() method ke saath jo Rectangle implement karna chahiye. Default method printInfo() shared implementation provide karta hai jo implementing classes use ya override kar sakte hain. Static method describe() interface khud ko belong karta hai, instances nahi. Rectangle abstract method ki concrete implementation provide karta hai."
        },
        "keyPoints": [
          "Method signatures define karte hain bina implementation ke (contracts)",
          "Classes implement keyword use karke interfaces implement karte hain",
          "Multiple inheritance support karte hain (class multiple interfaces implement kar sakta hai)",
          "Java 8+ mein default aur static methods implementations ke saath allow karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "List, Runnable, Comparable, Serializable"
          ]
        }
      },
      {
        "id": "s2-4-3",
        "title": "Abstract Class vs Interface",
        "explanations": {
          "english": "Abstract classes aur interfaces Java mein different design purposes serve karte hain. Abstract classes 'is-a' relationships represent karte hain shared state ya partial implementation ke saath, fields aur constructors allow karte hain. Interfaces 'can-do' capabilities represent karte hain bina state ke, sirf behavior contracts provide karte hain. Ek class sirf ek abstract class extend kar sakta hai (single inheritance) lekin multiple interfaces implement kar sakta hai. Abstract classes closely related classes ke liye ideal hain jo code share karte hain, jabki interfaces unrelated classes ke liye suitable hain jo capabilities share karte hain. Java 8 ke default methods ke saath line blur ho gayi hai, lekin state key differentiator rehta hai—interfaces mein instance fields nahi ho sakte (sirf constants). Abstract classes choose karein class hierarchies ke liye, interfaces cross-cutting concerns aur multiple inheritance of type ke liye."
        },
        "code": {
          "title": "Choosing Between Them",
          "language": "java",
          "content": "// Abstract class for shared state\nabstract class Vehicle {\n    protected String engineType; // State shared\n    \n    public void startEngine() { // Shared behavior\n        System.out.println(\"Engine started\");\n    }\n    \n    public abstract void move();\n}\n\n// Interface for capabilities across hierarchies\ninterface Flyable {\n    void fly(); // No state, just ability\n}\n\ninterface Swimmable {\n    void swim();\n}\n\n// Concrete implementation\nclass AmphibiousPlane extends Vehicle implements Flyable, Swimmable {\n    public void move() { /* ... */ }\n    public void fly() { /* ... */ }\n    public void swim() { /* ... */ }\n}"
        },
        "codeExplanations": {
          "english": "Vehicle abstract class ke roop mein engineType state aur startEngine behavior share karta hai land vehicles ke beech. Flyable aur Swimmable interfaces hain jo capabilities represent karte hain jo inheritance boundaries cross karte hain. AmphibiousPlane Vehicle se state inherit karta hai jabki multiple capabilities interfaces se gain karta hai, demonstrate karte hue kab kya use karna hai."
        },
        "keyPoints": [
          "Abstract classes: State + partial implementation, single inheritance",
          "Interfaces: Behavior contracts only, multiple inheritance allowed",
          "Abstract classes use karein 'is-a' relationships ke liye shared code ke saath",
          "Interfaces use karein 'can-do' capabilities ke liye across class hierarchies"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Feature|Abstract Class|Interface\nInheritance|Single (extends)|Multiple (implements)\nState|Instance fields allowed|Only constants (static final)\nConstructors|Allowed|Not allowed\nMethod implementation|Allowed|Allowed (default/static since Java 8)\nAccess modifiers|Any|Methods implicitly public\nUse case|Shared base code|Capability contracts",
          "examples": []
        }
      },
      {
        "id": "s2-4-4",
        "title": "Default Methods",
        "explanations": {
          "english": "Default methods, Java 8 mein introduce kiye gaye, interfaces ko allow karte hain method implementations contain karne default keyword ke saath, interfaces aur abstract classes ke beech gap bridge karte hain. Ye existing interfaces mein new methods add karne allow karte hain bina backward compatibility break kiye, kyunki implementing classes default implementation inherit kar lete hain. Default methods default access hote hain (implicitly public) aur implementing classes se overridden ho sakte hain agar specific behavior chahiye. Ye Object methods (equals, hashCode, toString) override nahi kar sakte aur sirf static interface members access kar sakte hain. Jab ek class multiple interfaces implement karti hai conflicting default methods ke saath, usse method override karke ambiguity resolve karni padti hai. Default methods API evolution facilitate karte hain jabki functional interfaces maintain rakhte hain."
        },
        "code": {
          "title": "Default Method Usage",
          "language": "java",
          "content": "interface Logger {\n    void log(String message);\n    \n    default void logInfo(String message) {\n        log(\"[INFO] \" + message);\n    }\n    \n    default void logError(String message) {\n        log(\"[ERROR] \" + message);\n    }\n}\n\nclass ConsoleLogger implements Logger {\n    public void log(String message) {\n        System.out.println(message);\n    }\n    // Inherits logInfo and logError automatically\n}\n\nclass FileLogger implements Logger {\n    public void log(String message) {\n        // Write to file\n    }\n    \n    @Override\n    public void logError(String message) {\n        // Custom error handling with timestamp\n        log(\"[ERROR] \" + System.currentTimeMillis() + \" \" + message);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Logger interface define karta hai abstract log() jo saare implementers provide karna chahiye, jabki default methods logInfo aur logError standard formatting provide karte hain jo classes inherit kar sakte hain. ConsoleLogger inherited defaults use karta hai, jabki FileLogger logError override karta hai timestamps add karne ke liye. Ye interface extension allow karta hai bina saare implementers ko update karne ke force kiye."
        },
        "keyPoints": [
          "Interfaces ko allow karte hain method implementations provide karne default keyword ke saath",
          "Java 8 mein add kiye gaye interface evolution enable karne ke liye bina existing code break kiye",
          "Implementing classes automatically default implementation inherit karte hain",
          "Override kar sakte hain jab custom behavior chahiye; conflicts agar multiple interfaces same default define karein toh resolve karni padti hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "List.sort() default method in Collections API"
          ]
        }
      },
      {
        "id": "s2-5-1",
        "title": "Private Fields",
        "explanations": {
          "english": "Java mein private fields object state ko encapsulate karte hain by restricting direct access class ke bahar se, data hiding aur integrity enforce karte hain. Private modifier se declare kiye jaate hain, ye fields sirf declaring class ke andar accessible hain, external code ko invalid values set karne ya object state corrupt karne se prevent karte hain. Ye encapsulation allow karta hai class ko invariants maintain karne—conditions jo hamesha true rehni chahiye—sab modifications ko un methods ke through control karke jo changes validate karte hain. Private fields internal implementation details represent karte hain jo bina client code affect kiye change ho sakte hain, loose coupling ka principle follow karte hue. Proper encapsulation private fields ke saath robust object-oriented design ka fundamental hai, ensure karta hai ki objects apni state consistently manage karein."
        },
        "code": {
          "title": "Private Field Encapsulation",
          "language": "java",
          "content": "public class BankAccount {\n    private String accountNumber;\n    private double balance;\n    private int transactionCount;\n    \n    public BankAccount(String accountNumber, double initialBalance) {\n        if (accountNumber == null || accountNumber.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid account number\");\n        }\n        if (initialBalance < 0) {\n            throw new IllegalArgumentException(\"Initial balance cannot be negative\");\n        }\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n        this.transactionCount = 0;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            transactionCount++;\n        }\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Saare fields private hain, direct external modification prevent karte hue. Constructor valid initial state establish karne ke liye inputs validate karta hai. deposit() method control karta hai kaise balance change hota hai, ensure karta hai sirf positive amounts add hote hain aur transaction count track hota hai. External code ko methods use karne ki zaroorat hai state interact karne ke liye, data integrity maintain karte hue."
        },
        "keyPoints": [
          "Private fields internal state ko external access se chhupate hain",
          "Access sirf same class ke methods tak restricted hota hai",
          "Validation aur control enable karte hain saare state changes pe",
          "Class invariants protect karte hain aur internal implementation changes allow karte hain"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Modifier|Class|Package|Subclass|World\nprivate|Yes|No|No|No\nprotected|Yes|Yes|Yes|No\npublic|Yes|Yes|Yes|Yes\ndefault|Yes|Yes|No|No",
          "examples": []
        }
      },
      {
        "id": "s2-5-2",
        "title": "Getters & Setters",
        "explanations": {
          "english": "Getters (accessors) aur setters (mutators) private fields ko controlled access provide karte hain, standard JavaBeans pattern form karte hain property access ke liye. Getters field values retrieve karte hain, typically getFieldName() naam hote hain objects ke liye/isFieldName() booleans ke liye, read access allow karte hain bina field directly expose kiye. Setters field values modify karte hain, setFieldName() naam hote hain, validation, logging, ya side effects trigger karne enable karte hain modification ke dauraan. Ye indirection internal representation change karne allow karta hai (e.g., age store karne se birth year store karna) jabki same public interface maintain rakhta hai. Modern IDEs ye methods automatically generate karti hain, aur setters mein validation ensure karta hai objects valid states maintain karein. Ye foundation hain read-only (sirf getter), write-only (sirf setter), ya calculated properties ke liye."
        },
        "code": {
          "title": "Getter and Setter Pattern",
          "language": "java",
          "content": "public class Person {\n    private String name;\n    private int age;\n    private boolean active;\n    \n    // Getter\n    public String getName() {\n        return name;\n    }\n    \n    // Setter with validation\n    public void setAge(int age) {\n        if (age < 0 || age > 150) {\n            throw new IllegalArgumentException(\"Invalid age\");\n        }\n        this.age = age;\n    }\n    \n    // Getter for boolean (is convention)\n    public boolean isActive() {\n        return active;\n    }\n    \n    // Read-only property (no setter)\n    public int getBirthYear(int currentYear) {\n        return currentYear - age;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Standard naming conventions: getName name field return karta hai, setAge validate karta hai pehle set karne se ensure karne ke liye valid data. Boolean property isActive() convention use karta hai. Read-only calculated property getBirthYear age se value compute karta hai bina separate field store kiye. Name ka koi setter nahi hai isse effectively immutable banaata hai construction ke baad."
        },
        "keyPoints": [
          "Getters private fields ko read access provide karte hain get/is prefix ke saath",
          "Setters controlled write access provide karte hain validation logic ke saath",
          "Calculated properties aur internal representation changes enable karte hain",
          "Naming conventions follow karein: getX(), setX(), isX() booleans ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Type|Method|Access\nRead/Write|getX() + setX()|Full access\nRead-only|getX() only|Immutable after construction\nWrite-only|setX() only|Rare, for dependency injection\nCalculated|getX() computes|Virtual property, no backing field",
          "examples": []
        }
      },
      {
        "id": "s2-5-3",
        "title": "Data Hiding",
        "explanations": {
          "english": "Data hiding ek OOP principle hai jo internal object state aur implementation details ko external access se conceal karta hai, sirf necessary functionality expose karta hai well-defined interfaces ke through. Fields ko private banaake aur public methods se access provide karke, classes apne invariants protect karte hain aur invalid states prevent karte hain jo direct manipulation se arise ho sakte hain. Ye abstraction allow karta hai internal representations change karne—jaise full name store karne se first aur last names separately store karna—bina client code ko affect kiye jo class use karta hai. Data hiding system complexity reduce karta hai direct dependencies ko implementation details pe prevent karke aur changes ke ripple effect minimize karke. Ye encapsulation enforce karta hai, ensure karta hai ki objects consistent states mein rahein aur behavior primary interaction mechanism ho."
        },
        "code": {
          "title": "Data Hiding Implementation",
          "language": "java",
          "content": "public class CreditCard {\n    // Hidden implementation details\n    private String cardNumber;\n    private String encryptedData;\n    private LocalDate expiryDate;\n    \n    public CreditCard(String cardNumber, LocalDate expiry) {\n        this.cardNumber = maskNumber(cardNumber);\n        this.encryptedData = encrypt(cardNumber);\n        this.expiryDate = expiry;\n    }\n    \n    public String getMaskedNumber() {\n        return cardNumber; // Returns masked version only\n    }\n    \n    public boolean isValid() {\n        return expiryDate.isAfter(LocalDate.now());\n    }\n    \n    private String maskNumber(String number) {\n        return \"****-****-****-\" + number.substring(12);\n    }\n    \n    private String encrypt(String data) {\n        // Encryption logic\n        return \"encrypted_\" + data;\n    }\n}"
        },
        "codeExplanations": {
          "english": "CreditCard sensitive data chhupata hai: raw card number kabhi expose nahi hota; sirf masked version getter ke through available hai. Internal storage encryption use karta hai, lekin ye detail clients se hidden hai. isValid() behavior-based access provide karta hai date expose karne ki jagah. Implementation encryption algorithm change kar sakta hai bina users ko affect kiye."
        },
        "keyPoints": [
          "Internal state aur implementation complexity ko clients se chhupate hain",
          "Unauthorized ya invalid state modifications prevent karte hain",
          "Internal representation changes allow karte hain bina client code break kiye",
          "Sirf necessary operations public methods ke through expose karte hain"
        ],
        "extras": {
          "flowDiagram": "Client Code → Public Methods (Getters/Setters/Business Logic) → Private Fields/Implementation\nDirect access to fields blocked: X",
          "comparisonTable": "Aspect|Without Hiding|With Hiding\nState access|Direct, uncontrolled|Via methods only\nValidation|In client code|In class methods\nCoupling|Tight|Loose\nMaintenance|Changes break clients|Internal changes hidden",
          "examples": []
        }
      },
      {
        "id": "s2-5-4",
        "title": "Benefits of Encapsulation",
        "explanations": {
          "english": "Encapsulation numerous software engineering benefits provide karta hai data aur behavior bundle karke jabki direct internal state access restrict karta hai. Ye modularity enable karta hai self-contained units clear interfaces ke saath create karke, system complexity reduce karta hai. Maintenance aasaan ho jaata hai kyunki internal implementations change ho sakte hain bina dependent code affect kiye, provided public interface stable rahe. Encapsulation validation support karta hai ensure karke ki saare state changes un methods se hote hain jo business rules aur invariants enforce karte hain. Ye security enhance karta hai sensitive data ko external tampering se protect karke. Principle debugging bhi facilitate karta hai state management ko class ke andar localize karke, modifications track karna aasaan banata hai. Overall, encapsulation robust, flexible systems create karta hai jo requirements changes withstand kar sakein aur defect introduction reduce karein evolution ke dauraan."
        },
        "code": {
          "title": "Encapsulation Benefits",
          "language": "java",
          "content": "public class Temperature {\n    private double celsius;\n    \n    // Validation benefit: reject invalid temperatures\n    public void setCelsius(double value) {\n        if (value < -273.15) {\n            throw new IllegalArgumentException(\"Below absolute zero\");\n        }\n        this.celsius = value;\n    }\n    \n    // Flexibility benefit: change representation, keep interface\n    public double getFahrenheit() {\n        return (celsius * 9/5) + 32;\n    }\n    \n    public void setFahrenheit(double f) {\n        this.celsius = (f - 32) * 5/9;\n    }\n    \n    // Read-only calculated property\n    public boolean isFreezing() {\n        return celsius <= 0;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye class encapsulation benefits demonstrate karta hai: validation physically impossible temperatures ko setCelsius mein prevent karta hai. Flexibility dono Celsius aur Fahrenheit interfaces offer karne allow karta hai jabki internally sirf Celsius store karta hai—Kelvin storage pe switch kar sakta hai bina public API change kiye. isFreezing() derived information provide karta hai bina raw data expose kiye."
        },
        "keyPoints": [
          "Interface ko implementation se decouple karta hai, internal changes allow karta hai",
          "Input validation aur invariant enforcement enable karta hai class boundaries pe",
          "Modular, self-contained components create karta hai clear contracts ke saath",
          "Object integrity protect karta hai aur maintenance facilitate karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Benefit|Description\nFlexibility|Change internals without breaking clients\nValidation|Centralize business rules in setters\nSecurity|Protect sensitive data from direct access\nDebugging|Control points for state changes\nMaintenance|Localized impact of modifications",
          "examples": []
        }
      },
      {
        "id": "s2-6-1",
        "title": "Default Constructor",
        "explanations": {
          "english": "Java mein default constructor ek no-argument constructor hai jo compiler automatically provide karta hai jab koi constructor explicitly class mein define nahi kiya jaata. Ye objects ko default values (zero numbers ke liye, false booleans ke liye, null references ke liye) se initialize karta hai aur superclass no-arg constructor ko implicitly call karta hai. Agar koi constructor explicitly define kiya jaata hai, compiler default constructor generate nahi karta, explicit definition chahiye agar no-arg instantiation chahiye ho. Default constructor ka same access modifier hota hai jo class ka hai. Jabki convenient hai, default constructors pe rely karna often objects ko invalid states mein lead karta hai; explicit parameters ke saath constructors preferred hain proper initialization ensure karne ke liye. Samajhna zaroori hai ki compiler kab defaults provide karta hai aur kab explicit definition chahiye."
        },
        "code": {
          "title": "Default Constructor Behavior",
          "language": "java",
          "content": "public class Employee {\n    private String name;\n    private int id;\n    \n    // No constructors defined - compiler provides:\n    // public Employee() { super(); }\n}\n\npublic class Manager {\n    private String department;\n    \n    // Explicit constructor prevents default\n    public Manager(String department) {\n        this.department = department;\n    }\n    \n    // Must explicitly define if needed\n    public Manager() {\n        this.department = \"Unassigned\";\n    }\n}\n\n// Usage\nEmployee emp = new Employee(); // Works - default constructor\nManager mgr = new Manager();   // Works - explicit no-arg constructor"
        },
        "codeExplanations": {
          "english": "Employee mein koi constructor defined nahi hai, isliye Java public default constructor provide karta hai new Employee() allow karne ke liye. Manager originally sirf parameterized constructor tha, jo default instantiation prevent karta tha jab tak explicit no-arg constructor add nahi kiya gaya. Ye dikhata hai ki dono instantiation patterns provide karna zaroori hai jab dono chahiye hote hain."
        },
        "keyPoints": [
          "Compiler no-arg constructor provide karta hai sirf agar koi constructor define nahi kiya gaya ho",
          "Fields ko default values (0, false, null) se initialize karta hai",
          "super() implicitly call karta hai parent class initialize karne ke liye",
          "Ek baar aap koi constructor define kar dete hain, default generate nahi hota"
        ],
        "extras": {
          "flowDiagram": "new Employee()\n    ↓\nProvided by compiler:\nEmployee() {\n    super();\n    name = null;\n    id = 0;\n}",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-6-2",
        "title": "Parameterized Constructor",
        "explanations": {
          "english": "Parameterized constructors arguments accept karte hain object state ko specific values ke saath initialize karne ke liye defaults ki jagah, ensure karte hain ki objects valid states mein create hote hain. Ye allow karte hain mandatory data ko instantiation time pe require karna, null ya invalid values prevent karte hain jo setters se ho sakte hain agar construction ke baad call kiye jaayein. Multiple parameterized constructors overloading ke through provide kiye ja sakte hain, different initialization options offer karte hain based on available data. 'this' keyword parameters aur fields ko same naam se distinguish karta hai. Parameterized constructors arguments validate karne chahiye aur invalid inputs pe exceptions throw karne chahiye. Ye essential hain immutable objects ke liye jahan saari state creation ke dauraan set karni padti hai, aur ye class invariants immediately establish karte hain."
        },
        "code": {
          "title": "Parameterized Constructor Usage",
          "language": "java",
          "content": "public class Book {\n    private final String isbn;\n    private String title;\n    private int pageCount;\n    \n    // Primary constructor\n    public Book(String isbn, String title, int pages) {\n        if (isbn == null || isbn.isEmpty()) {\n            throw new IllegalArgumentException(\"ISBN required\");\n        }\n        if (pages <= 0) {\n            throw new IllegalArgumentException(\"Invalid page count\");\n        }\n        this.isbn = isbn;\n        this.title = title;\n        this.pageCount = pages;\n    }\n    \n    // Overloaded constructor\n    public Book(String isbn, String title) {\n        this(isbn, title, 0); // Delegate to primary\n    }\n}\n\n// Usage\nBook book = new Book(\"978-0134685991\", \"Clean Code\", 464);"
        },
        "codeExplanations": {
          "english": "Primary constructor saare inputs validate karta hai, ensure karta hai non-null ISBN aur positive page count, immediately valid state establish karta hai. Overloaded constructor primary ko using this() delegate karta hai, flexibility provide karte hue jabki validation ek jagah maintain karta hai. Final field isbn constructor mein set karna chahiye, us field ke liye immutability enforce karta hai."
        },
        "keyPoints": [
          "Parameters accept karte hain objects ko specific values ke saath initialize karne ke liye",
          "Inputs validate karne chahiye ensure karne ke liye objects valid states mein shuru hote hain",
          "Multiple constructors overloaded ho sakte hain flexibility ke liye",
          "this() use karein initialization primary constructor ko delegate karne ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Type|Parameters|Use Case\nDefault|None|Simple objects with defaults\nParameterized|Required fields|Objects requiring specific initial state\nCopy|Object to copy|Creating duplicates\nBuilder pattern|Multiple optional|Complex objects with many options",
          "examples": []
        }
      },
      {
        "id": "s2-6-3",
        "title": "Constructor Chaining",
        "explanations": {
          "english": "Constructor chaining Java mein ek constructor ko doosre se call karna involve karta hai same class ke andar using this(), ya subclass se using super(). Ye technique initialization logic ko single primary constructor mein consolidate karti hai jabki convenience constructors provide karti hai with fewer parameters. Call constructor body mein pehla statement hona chahiye aur circular references create nahi kar sakti. Chaining ensure karta hai ki saari validation aur setup code ek location mein exist karta hai, duplication aur maintenance overhead reduce karta hai. Subclass constructors ko super() call karna padta hai as their first statement (explicitly ya implicitly) ensure karne ke liye ki parent class initialization child se pehle ho. Proper chaining clean initialization hierarchies create karta hai aur code duplication overloaded constructors mein prevent karta hai."
        },
        "code": {
          "title": "Constructor Chaining Patterns",
          "language": "java",
          "content": "public class Rectangle {\n    private int width;\n    private int height;\n    private String color;\n    \n    // Primary constructor\n    public Rectangle(int width, int height, String color) {\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Dimensions must be positive\");\n        }\n        this.width = width;\n        this.height = height;\n        this.color = color;\n    }\n    \n    // Chain to primary\n    public Rectangle(int width, int height) {\n        this(width, height, \"White\");\n    }\n    \n    // Chain again\n    public Rectangle() {\n        this(10, 10);\n    }\n}\n\n// Parent-child chaining\nclass Square extends Rectangle {\n    public Square(int side) {\n        super(side, side); // Chain to parent\n    }\n}"
        },
        "codeExplanations": {
          "english": "Rectangle this() chaining demonstrate karta hai: do-arg constructor primary teen-arg ko default color ke saath delegate karta hai, aur no-arg constructor default dimensions ke saath do-arg ko delegate karta hai. Ye validation logic ko ek jagah rakhta hai. Square super() chaining dikhata hai, side do baar Rectangle ke constructor ko pass karke square create karta hai."
        },
        "keyPoints": [
          "this() use karein doosre constructor ko call karne ke liye same class mein",
          "super() use karein parent class constructor ko call karne ke liye (pehla statement hona chahiye)",
          "Initialization logic consolidate karta hai duplication avoid karne ke liye",
          "Constructor mein pehla statement; this() aur super() saath mein nahi ho sakte"
        ],
        "extras": {
          "flowDiagram": "Rectangle() → this(10,10) → Rectangle(10,10) → this(10,10,\"White\") → Rectangle(10,10,\"White\") → Initialize\n\nSquare(side) → super(side,side) → Rectangle(width,height)",
          "comparisonTable": "Keyword|Calls|Location|Restriction\nthis()|Another constructor same class|First statement|Cannot coexist with super()\nsuper()|Parent constructor|First statement|Implicit if omitted (no-arg)",
          "examples": []
        }
      },
      {
        "id": "s2-6-4",
        "title": "Copy Constructor Pattern",
        "explanations": {
          "english": "Copy constructor pattern ek new object create karta hai existing object ki copy ke roop mein, field values ko deep ya shallow copy karta hai. Jabki Java C++ ki tarah built-in copy constructors provide nahi karta, pattern implement kiya jaata hai same class ka instance parameter ke roop mein accept karke aur uske fields copy karke. Ye approach copying behavior pe control allow karta hai—references copy karne (shallow) ya new objects create karne (deep)—aur final fields ko handle karta hai jo construction ke baad set nahi kiye ja sakte. Copy constructors Cloneable interface se preferable hain kyunki unhe throws clauses nahi chahiye, final fields ke saath kaam karte hain, aur casting nahi require karte. Ye explicit, readable object duplication provide karte hain aur essential hain immutable objects ke liye jo modified copies chahiye hote hain."
        },
        "code": {
          "title": "Copy Constructor Implementation",
          "language": "java",
          "content": "public class Address {\n    private final String street;\n    private final String city;\n    private final List<String> residents;\n    \n    public Address(String street, String city, List<String> residents) {\n        this.street = street;\n        this.city = city;\n        this.residents = new ArrayList<>(residents);\n    }\n    \n    // Copy constructor (deep copy)\n    public Address(Address other) {\n        this.street = other.street;\n        this.city = other.city;\n        // Deep copy of mutable field\n        this.residents = new ArrayList<>(other.residents);\n    }\n    \n    public List<String> getResidents() {\n        return new ArrayList<>(residents); // Defensive copy\n    }\n}\n\n// Usage\nAddress original = new Address(\"123 Main\", \"NYC\", Arrays.asList(\"Alice\"));\nAddress copy = new Address(original); // Independent copy"
        },
        "codeExplanations": {
          "english": "Copy constructor ek naya Address existing se create karta hai, primitive values directly copy karta hai lekin mutable residents field ke liye naya ArrayList create karta hai (deep copy). Ye shared mutable state ko original aur copy ke beech prevent karta hai. Getter mein defensive copying internal list ko external modification se protect karta hai."
        },
        "keyPoints": [
          "Same class instance ko parameter ke roop mein accept karta hai copy create karne ke liye",
          "Explicit control allow karta hai shallow vs deep copying pe",
          "clone() se preferred hai kyunki ye final fields handle karta hai aur casting nahi chahiye",
          "Immutable objects ke modified copies create karne enable karta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Approach|Pros|Cons\nCopy Constructor|Explicit, handles finals, no casting|Manual implementation\nclone()|Standard interface|Shallow by default, requires Cloneable, checked exception\nSerialization|Deep copy easy|Performance, all fields must be serializable",
          "examples": []
        }
      },
      {
        "id": "s2-7-1",
        "title": "Packages in Java",
        "explanations": {
          "english": "Java mein packages namespaces hain jo related classes aur interfaces ko hierarchical groups mein organize karte hain, naming conflicts prevent karte hain aur access control karte hain. File system mein folders ki tarah similar, packages large applications ke liye structure provide karte hain, classes ko functionality ke hisaab se group karte hain (e.g., java.util, java.io). Package declaration source file mein pehla statement hona chahiye, class ka fully qualified name determine karta hai. Packages directory structures correspond karte hain, dots subdirectories represent karte hain. Ye encapsulation enable karte hain class level se bhi, kyunki package-private (default) access allow karta hai classes ko same package mein ek doosre ke members access karne mein jabki external packages se chhupate hain. Proper package organization code maintainability, reusability improve karta hai aur modular architecture enable karta hai."
        },
        "code": {
          "title": "Package Organization",
          "language": "java",
          "content": "// File: src/com/example/banking/Account.java\npackage com.example.banking;\n\nimport com.example.common.Validator;\nimport java.math.BigDecimal;\n\npublic class Account {\n    private BigDecimal balance;\n    \n    public void deposit(BigDecimal amount) {\n        Validator.validatePositive(amount);\n        balance = balance.add(amount);\n    }\n}\n\n// File: src/com/example/banking/Transaction.java\npackage com.example.banking;\n\n// Same package, no import needed for Account\npublic class Transaction {\n    private Account fromAccount;\n    private Account toAccount;\n}"
        },
        "codeExplanations": {
          "english": "Package declaration reverse domain notation use karta hai (com.example.banking) uniqueness ensure karne ke liye. Same package mein classes (Account aur Transaction) ek doosre ke package-private members access kar sakte hain bina imports ke. Doosre package classes ko import statements ya fully qualified names (java.math.BigDecimal) chahiye."
        },
        "keyPoints": [
          "Classes ko namespaces mein organize karte hain naming conflicts prevent karne ke liye",
          "Package declaration directory structure match karti hai (com.example → com/example)",
          "Same package mein classes ke special access privileges hain (package-private)",
          "Reverse domain naming convention use karein uniqueness ke liye (com.company.project)"
        ],
        "extras": {
          "flowDiagram": "com\n └── example\n      ├── banking\n      │    ├── Account.java\n      │    └── Transaction.java\n      └── common\n           └── Validator.java",
          "comparisonTable": "",
          "examples": [
            "java.util",
            "java.lang",
            "org.springframework.core"
          ]
        }
      },
      {
        "id": "s2-7-2",
        "title": "private",
        "explanations": {
          "english": "Private access modifier Java mein sabse restrictive visibility provide karta hai, access declaring class tak limit karta hai. Private members (fields, methods, constructors, nested classes) completely doosri classes se hidden hain, including subclasses aur same package mein classes. Ye strict encapsulation ensure karta hai ki implementation details externally access ya modify nahi ho sakte, object invariants maintain karte hue aur internal changes allow karte hue bina client code affect kiye. Private constructors outside se instantiation prevent karte hain, singleton patterns ya utility classes enable karte hain. Jabki private members override nahi ho sakte, unhe same top-level class ke andar access kiya ja sakta hai, even different instances se. Ye modifier information hiding aur robust encapsulation ka fundamental hai."
        },
        "code": {
          "title": "Private Access Usage",
          "language": "java",
          "content": "public class SecureData {\n    private String secretKey;\n    private int accessCount;\n    \n    private void logAccess() {\n        accessCount++;\n    }\n    \n    public String decrypt(String data) {\n        logAccess(); // Internal use only\n        // Decryption logic\n        return \"decrypted\";\n    }\n    \n    // Private constructor pattern\n    private SecureData(String key) {\n        this.secretKey = key;\n    }\n    \n    public static SecureData create(String key) {\n        if (key == null) throw new IllegalArgumentException();\n        return new SecureData(key);\n    }\n}"
        },
        "codeExplanations": {
          "english": "secretKey aur accessCount completely external access se hidden hain. logAccess() ek private helper method hai sirf internal use ke liye. Private constructor factory method create() ko force karta hai, jo parameters validate kar sakta hai instantiation se pehle, ensure karta hai objects sirf valid states mein hi create hote hain."
        },
        "keyPoints": [
          "Access strictly declaring class tak restricted hota hai",
          "Subclasses, package mates, ya external classes ko visible nahi",
          "Complete encapsulation implementation details ka enable karta hai",
          "Private constructors instantiation control karte hain (singleton, factory patterns)"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Modifier|Same Class|Same Package|Subclass|Universe\nprivate|Yes|No|No|No\n(default)|Yes|Yes|No|No\nprotected|Yes|Yes|Yes|No\npublic|Yes|Yes|Yes|Yes",
          "examples": []
        }
      },
      {
        "id": "s2-7-3",
        "title": "default",
        "explanations": {
          "english": "Default access (package-private) occur hota hai jab koi access modifier specify nahi kiya jaata, same package mein classes ko visibility grant karta hai sirf. Ye protected se zyada restrictive hai lekin public se kam. Package-private access useful hai implementation classes ke liye jo package ke bahar expose nahi honi chahiye, jaise helper classes ya strategy implementations. Ye related classes ko closely cooperate karne allow karta hai jabki external code se implementation chhupata hai. Ye level often use hota hai modular design mein jahan package specific public APIs export karta hai certain classes ke through jabki supporting classes package-private rakhta hai. Careful use of default access public API surface reduce karta hai, maintenance burden minimize karta hai aur internal refactoring allow karta hai bina breaking changes."
        },
        "code": {
          "title": "Package-Private Pattern",
          "language": "java",
          "content": "// In package com.example.service\npublic class UserService {\n    // Package-private helper\n    UserValidator validator = new UserValidator();\n    \n    public void createUser(String email) {\n        if (validator.isValid(email)) {\n            // Create user\n        }\n    }\n}\n\n// Package-private class (no modifier)\nclass UserValidator {\n    boolean isValid(String email) {\n        return email != null && email.contains(\"@\");\n    }\n}\n\n// Different package cannot access UserValidator:\n// import com.example.service.UserValidator; // Compile error!"
        },
        "codeExplanations": {
          "english": "UserValidator ka default access hai, isliye ye sirf com.example.service package mein visible hai. UserService ise instantiate aur use kar sakta hai, lekin external packages ise dekh bhi nahi sakte. Ye implementation details chhupata hai jabki related classes ko same package mein cooperation allow karta hai."
        },
        "keyPoints": [
          "Koi modifier keyword nahi; sirf same package mein accessible",
          "Helper classes ke liye useful jo external use ke liye nahi hain",
          "Public API surface area reduce karta hai",
          "Package-internal collaboration allow karta hai jabki encapsulation maintain rakhta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-7-4",
        "title": "protected",
        "explanations": {
          "english": "Protected access modifier visibility provide karta hai declaring class, same-package classes, aur subclasses (even different packages mein) ko. Ye inheritance scenarios ke liye design kiya gaya hai, allow karta hai parent classes ko members expose karne specifically child class extension ke liye jabki general external use se chhupate hain. Protected members subclasses mein accessible hain inheritance ke through, lekin parent class instances ke references se access nahi kiye ja sakte external packages se. Ye modifier encapsulation aur extensibility ke beech balance karta hai, template method patterns enable karta hai jahan subclasses protected methods override karte hain jo public parent methods call karte hain. Careful use chahiye kyunki protected members API contract ka part ban jaate hain subclasses ke liye, backward compatibility considerations require karte hain."
        },
        "code": {
          "title": "Protected Access Pattern",
          "language": "java",
          "content": "package com.example.framework;\n\npublic class Controller {\n    protected void beforeAction() {\n        // Hook for subclasses\n    }\n    \n    protected void afterAction() {\n        // Hook for subclasses\n    }\n    \n    public final void process() {\n        beforeAction();\n        doAction();\n        afterAction();\n    }\n    \n    protected abstract void doAction();\n}\n\n// Different package\npackage com.example.app;\n\npublic class UserController extends Controller {\n    @Override\n    protected void beforeAction() {\n        // Valid override\n        System.out.println(\"Preparing user action\");\n    }\n    \n    @Override\n    protected void doAction() {\n        // Implementation\n    }\n}"
        },
        "codeExplanations": {
          "english": "Controller protected hook methods define karta hai (beforeAction, afterAction) jo subclasses different packages mein override kar sakte hain, lekin public final process() use karta hai algorithm structure enforce karne ke liye. Ye template method pattern allow karta hai customization extension points mein jabki overall process flow modification prevent karta hai."
        },
        "keyPoints": [
          "Package aur subclasses (doosre packages mein bhi) ke liye accessible",
          "Inheritance ke liye design kiya gaya hai: parent allow karta hai children ko members expose karna",
          "Subclass inherited protected members access kar sakta hai parent se",
          "Parent reference se protected members access nahi kiye ja sakte external package se"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-7-5",
        "title": "public",
        "explanations": {
          "english": "Public access modifier unrestricted visibility provide karta hai, members ko kisi bhi class se kisi bhi package se accessible banata hai. Classes, methods, aur fields jo external code ke liye intended hain public hone chahiye, library ya module ka published API form karte hain. Public classes unki files matching names mein declare kiye jaane chahiye, aur ek compilation unit mein sirf ek public class ho sakti hai. Jab interfaces ke liye necessary hai, excessive public members use se encapsulation reduce hoti hai aur maintenance burden badhta hai, kyunki public APIs backward compatibility require karte hain. Public fields encapsulation break karte hain aur avoid karne chahiye private fields aur public getters/setters ki favor mein. Modifier entry points, service interfaces, aur widespread use ke liye constants ke liye appropriate hai."
        },
        "code": {
          "title": "Public API Design",
          "language": "java",
          "content": "public class Calculator {\n    // Public constant\n    public static final double PI = 3.14159;\n    \n    // Public API method\n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    // Private implementation detail\n    private double internalPrecision = 0.0001;\n    \n    // Package-private for testing\n    void setPrecision(double p) {\n        this.internalPrecision = p;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Calculator PI ko public constant aur add() ko public API ke roop mein expose karta hai. internalPrecision private rehta hai, aur setPrecision package-private hai test access ke liye. Ye demonstrate karta hai minimal necessary visibility select karna: API ke liye public, internals ke liye private, test helpers ke liye default."
        },
        "keyPoints": [
          "Kisi bhi class se kisi bhi package se unrestricted access",
          "Public API form karta hai; backward compatibility maintenance require karta hai",
          "Public class filename se match karni chahiye; ek per file",
          "Public fields avoid karein; private fields with accessors use karein"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-7-6",
        "title": "Package Design Best Practices",
        "explanations": {
          "english": "Effective package design classes ko type se zyada functionality aur layer ke hisaab se organize karta hai, high cohesion aur low coupling jaise principles follow karta hai. Packages related concepts encapsulate karte hain aur minimal public interfaces expose karte hain, implementation classes ko package-private chhupate hue. 'Separation of concerns' principle suggest karta hai organize karna feature ke hisaab se (user management, order processing) rather than technical layers (controllers, services). Stability rules indicate karte hain ki less stable packages zyada stable ones pe depend karne chahiye; stable packages interfaces aur abstract classes contain karte hain. Package naming reverse domain notation follow karta hai (com.company.project.module) global uniqueness ensure karne ke liye. Packages ke beech circular dependencies avoid karein, kyunki ye maintenance aur testing complicate karte hain. Well-designed packages modular deployment aur clear dependency management enable karte hain."
        },
        "code": {
          "title": "Package Structure Example",
          "language": "java",
          "content": "com.example.ecommerce\n    ├── customer\n    │    ├── Customer.java (public)\n    │    ├── CustomerRepository.java (public)\n    │    └── CustomerValidator.java (package-private)\n    ├── order\n    │    ├── Order.java (public)\n    │    ├── OrderService.java (public)\n    │    └── OrderCalculator.java (package-private)\n    └── common\n         ├── exception\n         └── util\n\n// customer package uses order package\nimport com.example.ecommerce.order.Order;\n\npublic class Customer {\n    // Avoid depending on internal details of other packages\n    // Use public OrderService, not package-private OrderCalculator\n}"
        },
        "codeExplanations": {
          "english": "Structure domain feature (customer, order) se organize hai layer (dao, service) ki jagah. Har package public classes export karta hai (Customer, OrderService) jabki implementation (Validator, Calculator) package-private chhupata hai. Shared utilities common mein jaate hain. Customer sirf public Order pe depend karta hai, doosre package ke internal package-private classes nahi, encapsulation boundaries maintain karte hue."
        },
        "keyPoints": [
          "Feature/domain se organize karein, technical layer se nahi",
          "Implementation classes chhupayein; minimal public interfaces export karein",
          "Reverse domain naming convention follow karein",
          "Packages ke beech circular dependencies avoid karein"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Anti-Pattern|Better Approach\ncom.example.dao, com.example.service|com.example.user, com.example.product\ncom.example.controllers.UserController, ProductController|Feature packages with internal layers\nDeep nesting (a.b.c.d.e)|Flat structure (max 3-4 levels)",
          "examples": []
        }
      },
      {
        "id": "s2-8-1",
        "title": "Static Variables & Methods",
        "explanations": {
          "english": "Java mein static members class khud ko belong karte hain kisi specific instance ki jagah, class ke saare objects mein shared hote hain. Static variables (class variables) data store karte hain jo saare instances common hain, jaise counters ya configuration constants. Static methods class-level data pe operate karte hain aur ClassName.method() syntax se bina object create kiye invoke kiye ja sakte hain. Ye directly instance fields ya methods access nahi kar sakte kyunki ye kisi bhi object state se independently exist karte hain. Static members method area (metaspace) mein allocate hote hain jab class load hoti hai aur program duration tak persist karte hain. Utility classes jaise Math ya Collections entirely static members se bane hain. Jabki shared functionality ke liye convenient hain, static state ka overuse testing mein difficulty create kar sakta hai aur classes ke beech hidden dependencies create kar sakta hai."
        },
        "code": {
          "title": "Static Members Usage",
          "language": "java",
          "content": "public class Counter {\n    // Static variable - shared across all instances\n    private static int totalCount = 0;\n    \n    // Instance variable - per object\n    private int instanceCount = 0;\n    \n    public void increment() {\n        instanceCount++;\n        totalCount++;\n    }\n    \n    // Static method\n    public static int getTotalCount() {\n        return totalCount;\n        // Cannot access instanceCount here\n    }\n}\n\n// Usage\nCounter c1 = new Counter();\nCounter c2 = new Counter();\nc1.increment();\nc2.increment();\nSystem.out.println(Counter.getTotalCount()); // 2"
        },
        "codeExplanations": {
          "english": "totalCount static hai aur shared hai; dono increments same variable affect karte hain. instanceCount per-object hai. getTotalCount() static hai aur class pe call kiya jaata hai, instance pe nahi. Static methods instance variables access nahi kar sakte kyunki ye bina instance context ke operate karte hain."
        },
        "keyPoints": [
          "Class ko belong karte hain, instances ko nahi; saare objects mein shared",
          "ClassName.member se access; instance se bhi access kar sakte hain (discouraged)",
          "Static methods instance fields ya methods directly access nahi kar sakte",
          "Class load hone pe initialize hote hain, object create hone pe nahi"
        ],
        "extras": {
          "flowDiagram": "Class Area (Method Area):\nCounter.totalCount = 2\n\nHeap Objects:\nc1: instanceCount = 1\nc2: instanceCount = 1",
          "comparisonTable": "Aspect|Instance|Static\nBelongs to|Object|Class\nMemory|Heap|Metaspace\nAccess|object.field|Class.field\nLifetime|Object exists|Program duration\nCan access instance?|Yes|No",
          "examples": []
        }
      },
      {
        "id": "s2-8-2",
        "title": "Static Blocks",
        "explanations": {
          "english": "Static initialization blocks Java mein execute hote hain jab class pehli baar memory mein load hoti hai, static variables ki one-time initialization perform karte hain. Ye koi bhi static method call hone se pehle ya instances create hone se pehle run hote hain, complex static initialization ke liye ideal hain jo single expressions mein nahi ho sakti. Multiple static blocks unke appearance ki order mein execute hote hain. Ye exceptions throw kar sakte hain lekin checked exceptions handle karne padenge ya class signature mein declare karne padenge. Static blocks commonly use hote hain native libraries load karne, database connections initialize karne, ya complex static data structures setup karne ke liye. Java 8 se, static methods combined with private static helpers often static blocks replace karte hain better readability aur testability ke liye."
        },
        "code": {
          "title": "Static Initialization",
          "language": "java",
          "content": "public class DatabaseConfig {\n    private static final String URL;\n    private static final int MAX_CONNECTIONS;\n    private static final Map<String, String> properties;\n    \n    static {\n        // Complex initialization\n        URL = System.getenv(\"DB_URL\");\n        MAX_CONNECTIONS = Integer.parseInt(System.getenv(\"DB_MAX_CONN\"));\n        \n        properties = new HashMap<>();\n        properties.put(\"timeout\", \"30\");\n        properties.put(\"encoding\", \"UTF-8\");\n        \n        System.out.println(\"DatabaseConfig initialized\");\n    }\n    \n    public static String getUrl() {\n        return URL;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Static block ek baar run karta hai jab class load hoti hai, environment variables read karta hai aur map populate karta hai. Ye complex initialization logic handle karta hai jo simple assignment se nahi ho sakta. Final variables use se pehle initialize hone ki guarantee hai, aur block kisi bhi static method call ya instance creation se pehle execute hota hai."
        },
        "keyPoints": [
          "Execute ek baar jab class load hoti hai, koi bhi instance create hone se pehle",
          "Complex static variable initialization ke liye use hote hain",
          "Declaration order mein execute hote hain",
          "Exceptions handle kar sakte hain lekin checked exceptions catch ya declare karne padenge"
        ],
        "extras": {
          "flowDiagram": "Class Loading → Static Blocks Execute (in order) → Class Ready → Static Methods/Instances Available",
          "comparisonTable": "Block Type|Execution|Use Case\nStatic|Once per class loading|Class-level setup\nInstance|Each new object|Object-level setup\nConstructor|Each new object|Parameterized initialization",
          "examples": []
        }
      },
      {
        "id": "s2-8-3",
        "title": "Final Variables",
        "explanations": {
          "english": "Final variables Java mein constants represent karte hain jo sirf ek baar assign ho sakte hain, initialization ke baad immutability ensure karte hain. Primitives ke liye, final matlab value change nahi ho sakti; references ke liye, reference different object ki taraf point nahi kar sakta, lekin object ka internal state abhi bhi mutable ho sakta hai agar ye immutable nahi hai. Final instance variables constructor complete hone tak initialize hone chahiye, ya toh declaration pe, instance initializer block mein, ya har constructor mein. Static final variables compile-time ya runtime constants create karte hain. Blank finals (bina initialization ke declare kiye) allow karte hain different constructors ko alag values initialize karne. Final variables safe publication allow karte hain values across threads mein bina synchronization ke aur compilers ko code optimize karne mein help karte hain."
        },
        "code": {
          "title": "Final Variable Patterns",
          "language": "java",
          "content": "public class Configuration {\n    // Compile-time constant\n    public static final int MAX_SIZE = 100;\n    \n    // Runtime constant\n    public static final String VERSION = loadVersion();\n    \n    // Blank final - set in constructor\n    private final String instanceId;\n    \n    // Reference final - object mutable, reference fixed\n    private final List<String> tags = new ArrayList<>();\n    \n    public Configuration(String id) {\n        this.instanceId = id; // Must assign blank final\n    }\n    \n    public void addTag(String tag) {\n        tags.add(tag); // Legal - mutating object\n        // tags = new ArrayList<>(); // Illegal - cannot reassign reference\n    }\n}"
        },
        "codeExplanations": {
          "english": "MAX_SIZE ek compile-time constant hai. VERSION static final hai runtime pe load kiya jaata hai. instanceId ek blank final hai jo constructor mein assign kiya jaata hai, har instance ka permanent ID ensure karta hai. tags ek final reference hai—ArrayList object modify ho sakta hai (addTag kaam karta hai) lekin reference different list point nahi kar sakta."
        },
        "keyPoints": [
          "Exactly ek baar assign ho sakte hain; immutable reference/value initialization ke baad",
          "Final reference pointer change prevent karta hai, object mutation nahi",
          "Instance finals constructor complete hone se pehle assign hone chahiye",
          "Static finals constants create karte hain; conventionally uppercase with underscores"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Type|Primitive|Object Reference\nfinal int|Value cannot change|N/A\nfinal List|N/A|Reference fixed, object mutable\nImmutable List|N/A|Reference fixed, object immutable",
          "examples": []
        }
      },
      {
        "id": "s2-8-4",
        "title": "Final Methods",
        "explanations": {
          "english": "Final methods Java mein subclasses se override nahi ho sakte, critical algorithm steps ya security-sensitive operations ko modification se prevent karte hain. Jab ek method final declare kiya jaata hai, compiler method call inline kar sakta hai performance optimization ke liye, virtual method lookup ka overhead eliminate karta hai. Final methods appropriate hain template methods ke liye jahan overall algorithm fixed rehna chahiye jabki extension allow karte hain non-final protected methods ke through jo wo call karte hain. Ye class contracts ko breaking se through accidental overriding se protect karte hain aur malicious subclassing ko prevent karte hain security-sensitive classes mein. Halaanki, excessive final methods use se polymorphism flexibility reduce hoti hai; unhi methods ke liye reserve karein jinka behavior saare subclasses mein consistent rehna chahiye."
        },
        "code": {
          "title": "Final Method Protection",
          "language": "java",
          "content": "public class SecureHasher {\n    // Algorithm must not be modified for security\n    public final String hash(String input) {\n        String salted = addSalt(input);\n        return computeHash(salted);\n    }\n    \n    // Protected helper can be overridden\n    protected String addSalt(String input) {\n        return \"salt_\" + input;\n    }\n    \n    private String computeHash(String data) {\n        // Hash computation\n        return Integer.toHexString(data.hashCode());\n    }\n}\n\n// Subclass\npublic class AdvancedHasher extends SecureHasher {\n    @Override\n    protected String addSalt(String input) {\n        return \"advanced_\" + super.addSalt(input);\n    }\n    \n    // Cannot override hash() - final method\n}"
        },
        "codeExplanations": {
          "english": "hash() final hai security algorithm ke saath tamper hone se prevent karne ke liye jabki addSalt() customization allow karta hai via protected helper. Subclass salt generation customize karne ke liye helper override kar sakta hai lekin main hash method nahi alter kar sakta, consistent security behavior ensure karte hue customizable parameters ke saath."
        },
        "keyPoints": [
          "Subclasses se override nahi ho sakte",
          "Compiler optimizations allow karte hain jaise method inlining",
          "Critical algorithms ya security requirements wale methods ke liye use karein",
          "Protected helper methods override ho sakte hain jabki final method structure fixed rehta hai"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "java.lang.Math methods",
            "Security class verification methods"
          ]
        }
      },
      {
        "id": "s2-8-5",
        "title": "Final Classes",
        "explanations": {
          "english": "Final classes Java mein extend ya inherit nahi ho sakti, subclassing entirely prevent karte hain. Ye appropriate hain utility classes (jaise java.lang.Math ya java.lang.System), immutable classes (jaise java.lang.String, java.time.LocalDate), aur security-sensitive classes ke liye jahan subclassing behavior compromise kar sakta hai. Final classes implicitly unke saare methods final hain (kyunki override nahi ho sakte), lekin methods explicitly final mark karna redundant hai. Ek class final banana sabse strongest form hai restriction ka, polymorphic extension ki possibility eliminate karta hai. Design considerations mein evaluate karna chahiye ki composition purpose serve kar sakti hai inheritance ki jagah. Final classes abhi bhi interfaces implement kar sakte hain aur doosri non-final classes extend kar sakte hain (unless pehle se hi final class extend kar rahe hain)."
        },
        "code": {
          "title": "Final Class Examples",
          "language": "java",
          "content": "// Utility class - should not be instantiated or extended\npublic final class StringUtils {\n    private StringUtils() {} // Private constructor\n    \n    public static boolean isEmpty(String s) {\n        return s == null || s.isEmpty();\n    }\n}\n\n// Immutable class - final fields and final class\npublic final class Point {\n    private final int x;\n    private final int y;\n    \n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    public int getX() { return x; }\n    public int getY() { return y; }\n}\n\n// Cannot do: public class MutablePoint extends Point {} // Compile error"
        },
        "codeExplanations": {
          "english": "StringUtils final hai private constructor ke saath, dono extension aur instantiation prevent karta hai—pure utility class. Point final immutable class hai final fields ke saath, ensure karta hai state creation ke baad change nahi ho sakta ya malicious subclassing ke through. Dono patterns demonstrate karte hain jahan immutability ya utility semantics preserve kiye jaane chahiye."
        },
        "keyPoints": [
          "Extend nahi ho sakti; saari inheritance prevent karta hai",
          "Implicitly apne saare methods final bana deti hai (override nahi ho sakte)",
          "Immutable data classes aur utility classes ke liye use karein",
          "Complete restriction allow karta hai maximum class behavior pe control"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Restriction|Effect\nfinal class|No extension allowed\nfinal method|No overriding allowed\nfinal variable|No reassignment allowed\nprivate constructor|No instantiation (for utilities)",
          "examples": [
            "java.lang.String",
            "java.time.LocalDateTime",
            "java.lang.Math"
          ]
        }
      },
      {
        "id": "s2-9-1",
        "title": "Static Nested Classes",
        "explanations": {
          "english": "Static nested classes Java mein doosri class ke andar static modifier ke saath declare ki jaati hain, top-level classes ki tarah behave karti hain logically unke outer class ke saath grouped. Ye enclosing class ke instance ka implicit reference maintain nahi karti, allow karti hain independent instantiation: OuterClass.NestedClass obj = new OuterClass.NestedClass(). Ye independence unhe memory-efficient banati hai jab nested class ko outer class instance fields access nahi chahiye. Ye outer class ke static members access kar sakti hain lekin instance fields ya methods directly access nahi kar sakti. Static nested classes appropriate hain helper classes, builders, ya components ke liye jo outer class ke saath tightly coupled hain lekin instance context nahi chahiye, jaise Map interfaces mein Entry."
        },
        "code": {
          "title": "Static Nested Class Pattern",
          "language": "java",
          "content": "public class Department {\n    private static String companyName = \"TechCorp\";\n    private String departmentName;\n    \n    // Static nested class\n    public static class Employee {\n        private String name;\n        private int id;\n        \n        public void work() {\n            // Can access static members of outer class\n            System.out.println(\"Working at \" + companyName);\n            // Cannot access departmentName directly (non-static)\n        }\n    }\n}\n\n// Usage\nDepartment.Employee emp = new Department.Employee();\n// No Department instance required"
        },
        "codeExplanations": {
          "english": "Employee static hai aur Department instance exist karna require nahi karti. Ye static field companyName access kar sakti hai lekin instance field departmentName nahi. Instantiation Outer.Inner syntax use karti hai bina outer object ki zaroorat ke, regular class ki tarah behave karti hai with namespace organization."
        },
        "keyPoints": [
          "Static declare ki jaati hai; koi implicit reference outer class instance ko nahi",
          "Bina outer class instance ke instantiate ho sakti hai",
          "Sirf outer class ke static members access kar sakti hai",
          "Related classes group karne ke liye use hoti hai (e.g., Builder pattern)"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Type|Instance Reference|Access to Outer|Instantiation\nStatic Nested|No|Static only|new Outer.Inner()\nInner|Yes|All members|outer.new Inner()\nLocal|Yes|All members|Within method only\nAnonymous|Yes|All members|At creation point only",
          "examples": [
            "Map.Entry",
            "Builder patterns"
          ]
        }
      },
      {
        "id": "s2-9-2",
        "title": "Non-static Inner Classes",
        "explanations": {
          "english": "Non-static inner classes (member inner classes) doosri class ke andar bina static modifier ke define ki jaati hain, enclosing class ke instance ka implicit reference maintain karti hain. Ye link allow karta hai unhe outer class ke saare members access karne mein, including private fields aur methods. Ye outer class ke instance ke through instantiate hoti hain: OuterClass.InnerClass inner = outer.new InnerClass(). Har inner class instance ek specific outer instance se tied hoti hai aur independently exist nahi kar sakti. Inner classes use hoti hain jab ek class logically doosri ko belong karti hai aur direct access chahiye uski implementation details ko, jaise collections mein iterators ya UI event handlers. Ye memory leaks lead kar sakti hain agar inner class outer instance se zyada time tak survive karti hai, kyunki ye reference retain karti hai."
        },
        "code": {
          "title": "Inner Class Usage",
          "language": "java",
          "content": "public class Car {\n    private String model;\n    private boolean engineRunning;\n    \n    // Non-static inner class\n    public class Engine {\n        private int horsepower;\n        \n        public void start() {\n            // Access outer class private members directly\n            engineRunning = true;\n            System.out.println(model + \" engine started\");\n        }\n        \n        public Car getCar() {\n            return Car.this; // Explicit outer reference\n        }\n    }\n}\n\n// Usage\nCar myCar = new Car();\nCar.Engine engine = myCar.new Engine(); // Bound to myCar instance\nengine.start();"
        },
        "codeExplanations": {
          "english": "Engine ek member inner class hai implicit access ke saath Car ke private fields model aur engineRunning ko. Instantiation existing Car object (myCar.new Engine()) require karti hai. Car.this explicit reference provide karta hai outer instance ko agar chahiye. Ye tight coupling represent karta hai engine ka specific car ka part hone ko."
        },
        "keyPoints": [
          "Outer class instance ka implicit reference maintain karti hain",
          "Outer class ke saare members including private access kar sakti hain",
          "Outer instance via instantiate karni padti hai: outer.new Inner()",
          "Har inner instance specific outer instance se bound hoti hai"
        ],
        "extras": {
          "flowDiagram": "Car object (outer)\n    ↓ reference\nEngine object (inner)\n    ↓ implicit access\nCar fields/methods",
          "comparisonTable": "",
          "examples": [
            "Iterator implementations",
            "UI event listeners"
          ]
        }
      },
      {
        "id": "s2-9-3",
        "title": "Local Inner Classes",
        "explanations": {
          "english": "Local inner classes method ya block scope ke andar define ki jaati hain, sirf us block ki execution context mein exist karti hain. Unke paas outer class ke saare members aur containing method ke final ya effectively final local variables access karne ka access hota hai (closure requirements ki wajah se). Local classes outer class ke members nahi hain aur unke paas access modifiers (public, private) ya static modifiers nahi ho sakte. Ye useful hain jab ek class sirf specific method mein chahiye temporary functionality ke liye, jaise custom data structures ya action handlers. Method mein confined hone se class namespace pollution reduce hoti hai aur implementation details jo class level pe visible nahi hone chahiye unhe encapsulate karti hai."
        },
        "code": {
          "title": "Local Class Implementation",
          "language": "java",
          "content": "public class ProcessManager {\n    private int processId = 100;\n    \n    public void startProcess(final String processName) {\n        int timeout = 30; // Effectively final\n        \n        // Local class defined inside method\n        class ProcessRunner {\n            public void run() {\n                System.out.println(\"Starting \" + processName + \n                                 \" with ID \" + processId);\n                System.out.println(\"Timeout: \" + timeout);\n            }\n        }\n        \n        ProcessRunner runner = new ProcessRunner();\n        runner.run();\n        \n        // Class not accessible outside this method\n    }\n    \n    public void stopProcess() {\n        // ProcessRunner not visible here\n    }\n}"
        },
        "codeExplanations": {
          "english": "ProcessRunner startProcess method ke liye local hai, outer class field processId aur final parameter processName plus effectively final local variable timeout access karti hai. Class method ke bahar access nahi kiya ja sakta, complete encapsulation provide karti hai helper class ki jo sirf method scope mein chahiye thi."
        },
        "keyPoints": [
          "Method ya block ke andar define ki jaati hain, class members nahi hain",
          "Koi access modifiers allowed nahi; scope enclosing block tak limited",
          "Final/effectively final local variables aur saare outer class members access kar sakti hain",
          "Sirf us method mein temporarily helper classes ke liye useful hai jahan defined hai"
        ],
        "extras": {
          "flowDiagram": "Method Execution:\nstartProcess()\n    ↓\n    Define Local Class ProcessRunner\n    ↓\n    Instantiate and use\n    ↓\nMethod Ends → Class scope ends → Not accessible elsewhere",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s2-9-4",
        "title": "Anonymous Inner Classes",
        "explanations": {
          "english": "Anonymous inner classes unnamed local classes hain jo declare aur instantiate ek hi expression mein hoti hain, typically interfaces implement karne ya classes extend karne ke liye exactly jahan chahiye. Syntax class definition ko instantiation ke saath combine karta hai: new Interface() { implementation }. Unke paas local classes jaise hi access rules hain (final variables aur outer members) lekin sirf creation point pe exist karti hain. Commonly use hoti hain event listeners, Runnable implementations, ya Comparator definitions ke liye. Jabki concise hain, ye readability reduce kar sakti hain agar complex hain; lambdas (Java 8+) often replace karte hain anonymous classes functional interfaces ke liye. Anonymous classes ke paas constructors nahi ho sakte (except instance initializers) aur compile hokar separate class files ban jaati hain named OuterClass$1.class."
        },
        "code": {
          "title": "Anonymous Class Patterns",
          "language": "java",
          "content": "// Implementing interface anonymously\nRunnable task = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Running in thread\");\n    }\n};\n\n// Extending class anonymously\nList<String> list = new ArrayList<String>() {\n    @Override\n    public boolean add(String s) {\n        System.out.println(\"Adding: \" + s);\n        return super.add(s);\n    }\n};\n\n// As argument (common for listeners)\nbutton.addActionListener(new ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"Clicked\");\n    }\n});"
        },
        "codeExplanations": {
          "english": "Pehla example ek anonymous Runnable implementation create karta hai. Doosra ArrayList ka anonymous subclass create karta hai jo add() override karta hai. Teesra common pattern dikhata hai anonymous listener implementation directly method ko pass karte hue. Har ek one-time use class create karta hai bina named declaration ke."
        },
        "keyPoints": [
          "Unnamed class declare aur instantiate ek hi expression mein",
          "Class extend ya interface implement karni chahiye",
          "Explicit constructors nahi ho sakte; instance initializers use karein",
          "Lambas se replace ho sakte hain functional interfaces ke liye (Java 8+)"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Feature|Anonymous|Lambda (Java 8+)\nSyntax|new Type() { }|(params) -> expression\nType|Class or interface|Functional interface only\nthis reference|Anonymous class instance|Enclosing class instance\nCapturing|Same as local class|Same (effectively final)\nReadability|Verbose for simple cases|Concise for simple cases",
          "examples": [
            "Thread creation",
            "Event handlers",
            "Comparator implementations"
          ]
        }
      }
    ]
  },
  {
    "id": "section-3",
    "title": "Memory Management",
    "topics": [
      {
        "id": "s3-1-1",
        "title": "Stack Memory Usage",
        "explanations": {
          "english": "Stack memory JVM ke andar static memory allocation aur thread execution ke liye use hota hai. Har thread ke paas apna private stack hota hai jo tab create hota hai jab thread start hota hai. Isme local primitive variables, method parameters, return addresses, aur intermediate calculation results store hote hain. Stack memory LIFO (Last-In-First-Out) order follow karta hai - jab method call hota hai toh naya frame push hota hai top pe, aur jab complete hota hai toh pop ho jata hai. Ye automatic cleanup ki wajah se stack memory management bahut efficient hota hai, kyunki variables apne scope se bahar jaane pe automatically destroy ho jate hain. Lekin stack ki size limited hoti hai, aur deep recursion ya excessive method nesting se StackOverflowError aa sakta hai."
        },
        "code": {
          "title": "Stack Frame Example",
          "language": "java",
          "content": "public class StackDemo {\n    public static void main(String[] args) {\n        int x = 10;              // Stored in main's stack frame\n        int result = calculate(x); // New frame pushed for calculate\n        System.out.println(result);\n    }\n    \n    static int calculate(int value) { // Parameter in calculate's frame\n        int temp = value * 2;    // Local variable in calculate's frame\n        return add(temp);        // New frame pushed for add\n    }\n    \n    static int add(int n) {      // New frame\n        int sum = n + 5;         // Local variable\n        return sum;              // Frame popped, value returned\n    }\n}"
        },
        "codeExplanations": {
          "english": "Is code mein dikhaya gaya hai ki stack frames kaise create aur destroy hote hain. Jab main calculate ko call karta hai, toh ek naya frame parameter value aur local variable temp ke saath push hota hai. Jab calculate add ko call karta hai, toh ek aur frame upar push hota hai. Jab har method return hota hai, uska frame pop ho jata hai aur local variables automatically clean up ho jate hain."
        },
        "keyPoints": [
          "Each thread has its own private stack memory created at thread startup",
          "Stores local variables, method parameters, and return addresses in stack frames",
          "LIFO structure: frames pushed on method call, popped on return",
          "Limited size; deep recursion causes StackOverflowError"
        ],
        "extras": {
          "flowDiagram": "Thread Stack:\n[add(): n, sum] ← Top (current)\n[calculate(): value, temp]\n[main(): x, result, args] ← Bottom",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-1-2",
        "title": "Heap Memory Usage",
        "explanations": {
          "english": "Heap memory wo runtime data area hai jo sabhi threads ke beech shared hota hai, jahan par saare Java objects aur arrays allocate hote hain. Stack ke opposite, heap mein banaye gaye objects uss method ke scope se bahar bhi zinda rehte hain, jab tak unka reference exist karta hai. Memory 'new' keyword use karke dynamically allocate hoti hai aur automatically garbage collector se deallocate hoti hai jab objects unreachable ban jate hain. Heap typically stack se bahut bada hota hai lekin slower access hota hai synchronization aur garbage collection overhead ki wajah se. Isse generations mein divide kiya gaya hai (Young aur Old) taaki object lifetime ke hisaab se garbage collection performance optimize ho sake."
        },
        "code": {
          "title": "Heap Allocation Example",
          "language": "java",
          "content": "public class HeapDemo {\n    public static void main(String[] args) {\n        // Object created in heap, reference stored in stack\n        Person person = new Person(\"Alice\", 30);\n        \n        // Method returns object allocated in heap\n        Person newPerson = modifyPerson(person);\n        \n        // Both references exist after method returns\n        System.out.println(person.getName());      // Alice\n        System.out.println(newPerson.getName());   // Bob\n    }\n    \n    static Person modifyPerson(Person p) {\n        // New object in heap, survives method return\n        return new Person(\"Bob\", 25);\n    }\n}\n\nclass Person {\n    private String name; // reference in heap (object in heap)\n    private int age;     // primitive in heap\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() { return name; }\n}"
        },
        "codeExplanations": {
          "english": "Person objects heap memory mein allocate hote hain. Person reference variable main ke stack frame mein store hota hai lekin point heap memory mein karta hai. Jab modifyPerson ek naya Person return karta hai, wo object heap mein bana rehta hai method frame ke pop hone ke baad bhi, aur newPerson reference ke through main mein accessible hota hai."
        },
        "keyPoints": [
          "Shared among all threads; stores all objects and arrays created with 'new'",
          "Managed by garbage collector; objects persist while referenced",
          "Larger than stack but slower access due to GC and synchronization",
          "Divided into generations (Young/Old) to optimize collection efficiency"
        ],
        "extras": {
          "flowDiagram": "Heap Memory:\n[Person object: name→\"Alice\", age=30]\n[Person object: name→\"Bob\", age=25]\n[String object: \"Alice\"]\n[String object: \"Bob\"]\n\nStack (main):\nperson → ref to Alice\nnewPerson → ref to Bob",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-1-3",
        "title": "Object References vs Actual Objects",
        "explanations": {
          "english": "Java memory management mein object references aur actual objects ke beech difference samajhna bahut zaroori hai. Reference variable stack mein store hota hai (ya registers mein) aur usme memory address hota hai jo heap mein object ko point karta hai, jabki object khud actual data aur state hold karta hai. Jab aap ek reference variable ko doosre mein assign karte ho, toh aap memory address copy karte ho, ek alias bana dete hain jo same object ko point karta hai, na ki object ki copy. Multiple references ek single heap object ko point kar sakte hain, matlab ek reference se ki gayi changes doosre references se bhi dikhayi deti hain. Ye distinction samajhne se pass-by-value semantics aur object mutation ke baare mein confusion nahi hota."
        },
        "code": {
          "title": "Reference vs Object Demonstration",
          "language": "java",
          "content": "public class ReferenceDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder(\"Hello\");\n        StringBuilder sb2 = sb1; // Copy reference, not object\n        \n        // Both references point to same object in heap\n        sb2.append(\" World\");\n        System.out.println(sb1); // Hello World\n        System.out.println(sb1 == sb2); // true (same reference)\n        \n        // Reassigning reference doesn't affect object\n        sb2 = new StringBuilder(\"New\");\n        System.out.println(sb1); // Still Hello World\n        System.out.println(sb2); // New\n    }\n}"
        },
        "codeExplanations": {
          "english": "sb1 mein heap mein StringBuilder object ka reference hai. Jab sb1 ko sb2 mein assign karte hain toh reference address copy hota hai, toh dono same object ko point karte hain. Sb2 se append karne se shared object modify hota hai, jo sb1 se bhi visible hota hai. Sb2 ko naya object assign karne se sirf sb2 ka reference change hota hai, na ki sb1 ka reference ya original object."
        },
        "keyPoints": [
          "Reference variables store memory addresses; objects store actual data in heap",
          "Assignment copies the reference value, creating aliases to the same object",
          "Multiple references can point to one object; changes affect all references",
          "Reassigning a reference variable changes what object it points to, not the object itself"
        ],
        "extras": {
          "flowDiagram": "Before sb2 = new StringBuilder:\nsb1 ───→ [StringBuilder: \"Hello World\"]\nsb2 ───→ (same object)\n\nAfter reassignment:\nsb1 ───→ [StringBuilder: \"Hello World\"]\nsb2 ───→ [StringBuilder: \"New\"]",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-1-4",
        "title": "Common Memory Issues",
        "explanations": {
          "english": "Java mein common memory issues mein StackOverflowError, OutOfMemoryError, aur memory leaks shaamil hain. StackOverflowError tab aata hai jab stack apni limit cross kar jata hai infinite recursion ya excessively deep method call chains ki wajah se. Heap mein OutOfMemoryError tab hota hai jab objects allocate nahi ho paate insufficient space ki wajah se, aksar memory leaks ya inadequate heap size settings ki wajah se. Memory leaks tab hote hain jab objects ab required nahi hain lekin accidental pointers (jaise static collections jo unbounded grow kar rahe hain) ki wajah se referenced hain, jisse garbage collection roak hota hai. NullPointerExceptions tab aate hain jab null references use karne ki koshish ki jati hai. In issues ko samajhne ke liye heap dumps, stack traces, aur profiling tools ka use karna padta hai."
        },
        "code": {
          "title": "Memory Problem Examples",
          "language": "java",
          "content": "// StackOverflowError - infinite recursion\npublic void infiniteRecursion() {\n    infiniteRecursion(); // Stack frames grow until overflow\n}\n\n// Memory Leak - growing static collection\npublic class Cache {\n    private static List<Object> leak = new ArrayList<>();\n    \n    public void add(Object obj) {\n        leak.add(obj); // Never removed, grows forever\n    }\n}\n\n// OutOfMemoryError - heap exhaustion\npublic void heapExhaustion() {\n    List<byte[]> list = new ArrayList<>();\n    while (true) {\n        list.add(new byte[1024 * 1024]); // 1MB chunks\n    }\n}"
        },
        "codeExplanations": {
          "english": "Infinite recursion se stack frames lagatar bante hain jab tak StackOverflowError nahi aa jata. Static Cache list added objects ka garbage collection roak deti hai, jisse memory leak hota hai jab yeh grow karti hai. Heap exhaustion loop large byte arrays continuously allocate karti hai jab tak heap full nahi ho jata aur OutOfMemoryError throw nahi hota."
        },
        "keyPoints": [
          "StackOverflowError: Stack exceeds maximum depth (infinite recursion)",
          "OutOfMemoryError: Heap cannot allocate new objects",
          "Memory leaks: Unnecessary references prevent GC (static collections, listeners)",
          "Use profilers and heap dumps (-XX:+HeapDumpOnOutOfMemoryError) to diagnose"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Error|Cause|Solution\nStackOverflowError|Deep recursion, cyclic calls|Increase stack (-Xss) or fix logic\nOutOfMemoryError|Heap full, memory leaks|Increase heap (-Xmx) or fix leaks\nMemory Leak|Accidental references|Remove references, use weak references",
          "examples": []
        }
      },
      {
        "id": "s3-2-1",
        "title": "What is Garbage Collection",
        "explanations": {
          "english": "Garbage Collection (GC) Java mein automatic memory management process hai jo identify aur remove karta hai wo objects jo program ke liye ab reachable nahi hain. JVM object references track karta hai GC roots se shuru karke (local variables, static fields, active threads), aur reachable objects ko alive mark karta hai. Unmarked objects ko garbage consider kiya jata hai aur unki memory reclaim ho jati hai. Ye automation manual memory management errors ko eliminate karta hai jaise ki memory free karna bhool jana, double-freeing, ya dangling pointers. GC background mein daemon threads ki tarah chalta hai, trigger hota hai jab heap space low ho ya explicitly System.gc() se request ki jaye. Different collectors alag algorithms use karte hain (mark-sweep, copying, mark-compact) jo alag application needs ke liye optimize hain."
        },
        "code": {
          "title": "Garbage Collection Trigger",
          "language": "java",
          "content": "public class GCDemo {\n    public static void main(String[] args) {\n        for (int i = 0; i < 100000; i++) {\n            // Temporary objects become eligible for GC\n            String temp = new String(\"Object \" + i);\n            // temp goes out of scope, becomes unreachable\n        }\n        \n        // Suggest GC (not guaranteed to run immediately)\n        System.gc();\n        \n        // Force finalization (deprecated in modern Java)\n        Runtime.getRuntime().runFinalization();\n    }\n    \n    @Override\n    protected void finalize() throws Throwable {\n        // Called before object destruction (deprecated since Java 9)\n        System.out.println(\"Object being garbage collected\");\n    }\n}"
        },
        "codeExplanations": {
          "english": "Loop bahut saare temporary String objects banata hai jo har iteration ke baad garbage collection ke liye eligible ho jate hain jab reference overwrite hota hai ya scope se bahar jaata hai. System.gc() sirf JVM ko suggestion hota hai ki GC chalay, command nahi. Finalize() method (ab deprecated) override hone pe destruction se pehle call hota tha."
        },
        "keyPoints": [
          "Automatic process that reclaims memory from unreachable objects",
          "Identifies garbage by tracing from GC roots (stack, statics, registers)",
          "Runs in background threads; System.gc() is only a hint",
          "Prevents memory leaks and eliminates manual deallocation errors"
        ],
        "extras": {
          "flowDiagram": "GC Roots → Reachable Objects (Marked Alive)\n      ↓\nUnreachable Objects → Marked for Collection → Memory Freed",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-2-2",
        "title": "Generational Garbage Collection",
        "explanations": {
          "english": "Generational garbage collection weak generational hypothesis pe based hai: zyadatar objects jaldi mar jate hain jabki kuch long-term survive karte hain. Heap ko Young Generation (new objects ke liye) aur Old Generation (Tenured) mein divide kiya gaya hai long-lived objects ke liye. Young Generation mein Eden space aur do Survivor spaces (S0, S1) hain. Naye objects Eden mein allocate hote hain; jab yeh fill ho jata hai, Minor GC surviving objects ko Survivor spaces mein move karta hai. Multiple Minor GC cycles survive karne ke baad objects Old Generation mein promote ho jate hain. Major GC (Full GC) Old space mein kam frequently hota hai. Ye separation short-lived objects ko efficiently collect karne allow karta hai fast copying algorithms use karke bina long-lived objects ko baar baar scan kiye."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "Heap divided into Young (new objects) and Old (long-lived objects) generations",
          "Young Generation contains Eden and two Survivor spaces (S0, S1)",
          "Minor GC cleans Young space frequently; Major GC cleans Old space occasionally",
          "Objects promoted to Old space after surviving threshold (default 15) Minor GCs"
        ],
        "extras": {
          "flowDiagram": "New Object → Eden Space\n                ↓ Full\n         Minor GC\n                ↓\n    [Dead]    [Alive]\n      ↓         ↓\n   Freed    Survivor S0\n                ↓\n           Minor GC × 15\n                ↓\n         Old Generation (Tenured)\n                ↓\n          Major GC/Full GC",
          "comparisonTable": "Generation|Contents|Collection Frequency|Algorithm\nYoung|New objects|Very frequent|Copying (fast)\nOld|Long-lived objects|Rare|Mark-sweep-compact (slower)",
          "examples": []
        }
      },
      {
        "id": "s3-2-3",
        "title": "G1 Garbage Collector",
        "explanations": {
          "english": "Garbage-First (G1) collector ek server-style, regionalized collector hai jo large memory heaps (kai gigabytes) ke liye design kiya gaya hai. Ye heap ko multiple equal-sized regions mein divide karta hai (typically 1MB se 32MB tak) jo dynamically Eden, Survivor, ya Old generation regions ban sakte hain. G1 concurrent global marking perform karta hai live data track karne ke liye, phir priority deta hai un regions ko collect karne mein jahan sabse zyada garbage hai (isiliye 'Garbage-First'), jisse reclamation efficiency maximize hoti hai. Ye user-defined pause times (default 200ms) target karta hai by incrementally regions select karke collection ke liye. G1 heap ko compact karta hai evacuation ke time fragmentation prevent karne ke liye, aur Concurrent Mark Sweep (CMS) collector ko replace karta hai as default in Java 9+."
        },
        "code": {
          "title": "G1 Configuration",
          "language": "java",
          "content": "// JVM Arguments for G1\n// -XX:+UseG1GC\n// -XX:MaxGCPauseMillis=200\n// -XX:InitiatingHeapOccupancyPercent=35\n// -XX:G1HeapRegionSize=16m\n\n// Enable GC logging (Java 9+)\n// -Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=100m"
        },
        "codeExplanations": {
          "english": "G1 ko -XX:+UseG1GC se enable kiya jata hai. MaxGCPauseMillis target pause time set karta hai (default 200ms) jo G1 appropriate number of regions select karke meet karne ki koshish karta hai. InitiatingHeapOccupancyPercent marking trigger karta hai jab heap 35% occupancy reach karta hai. Region size manually set kiya ja sakta hai ya heap size ke hisaab se auto-tuned hota hai."
        },
        "keyPoints": [
          "Regionalized collector dividing heap into equal-sized regions (1-32MB)",
          "Prioritizes regions with most garbage for collection efficiency",
          "Targets pause time goals through incremental collection",
          "Replaces CMS; default collector from Java 9"
        ],
        "extras": {
          "flowDiagram": "Heap divided into regions:\n[E][E][S][O][O][E][E][O][S][E]\n    \nConcurrent Marking → Identify mostly garbage regions\n    ↓\nEvacuate (copy live objects) → Compact selected regions\n    ↓\nFree space reclaimed",
          "comparisonTable": "Feature|CMS|G1\nHeap Structure|Contiguous|Regionalized\nCompaction|No (fragmentation)|Yes\nPause Time Target|No|Yes (configurable)\nDefault (Java 9+)|No|Yes",
          "examples": []
        }
      },
      {
        "id": "s3-2-4",
        "title": "ZGC Overview",
        "explanations": {
          "english": "Z Garbage Collector (ZGC) ek scalable, low-latency collector hai jo heaps handle kar sakta hai from small to terabytes of memory. Java 11 mein experimental introduce hua aur Java 15 mein production-ready, ye sabhi heavy work ko application threads ke saath concurrently perform karta hai, pause times ko 10 milliseconds se bhi kam rakhte hue chahe heap size kuchh bhi ho. ZGC colored pointers use karta hai (metadata 64-bit pointers mein) aur load barriers taaki concurrent relocation ho sake objects ka bina threads ko roke. Ye non-generational hai (single generation) aur reference processing use karta hai relocation ke time. ZGC ideal hai latency-sensitive applications ke liye jaise financial trading, gaming servers, aur large-scale web applications jahan consistent response times critical hain."
        },
        "code": {
          "title": "ZGC Configuration",
          "language": "java",
          "content": "// Enable ZGC (Java 15+)\n// -XX:+UseZGC\n\n// Optional: Set max heap size\n// -Xmx16G\n\n// ZGC specific options\n// -XX:ZCollectionInterval=5 (seconds)\n// -XX:ZAllocationSpikeTolerance=2"
        },
        "codeExplanations": {
          "english": "ZGC ko -XX:+UseZGC flag se enable kiya jata hai. Ye large heaps ke saath best kaam karta hai aur 64-bit JVM require karta hai. G1 ke opposite, ZGC ko pause time goals set karne ki zaroorat nahi hai kyunki ye consistently sub-10ms pauses achieve karta hai. Collection interval aur allocation spike tolerance specific allocation patterns ke liye tune kiye ja sakte hain."
        },
        "keyPoints": [
          "Ultra-low latency: sub-10ms pause times regardless of heap size",
          "Handles heaps from small to terabytes effectively",
          "Uses colored pointers and load barriers for concurrent operations",
          "Non-generational; single generation heap layout"
        ],
        "extras": {
          "flowDiagram": "Application Threads Running\n      ↓\nConcurrent Mark (remap pointers)\n      ↓\nConcurrent Relocate (move objects)\n      ↓\nLoad Barriers fix references on access\n      ↓\nApplication Threads Running (minimal pause)",
          "comparisonTable": "Feature|G1|ZGC\nPause Time|~200ms target|<10ms guaranteed\nHeap Size|Large|Massive (TB)\nGenerations|Yes|No\nJava Version|9+|15+ (production)\nBest For|Balanced|Ultra-low latency",
          "examples": []
        }
      },
      {
        "id": "s3-2-5",
        "title": "GC Tuning Basics",
        "explanations": {
          "english": "GC tuning mein appropriate collectors select karna aur heap parameters configure karna shaamil hai taaki throughput, latency, aur memory footprint balance ho sake aapki application ke liye. Key JVM flags mein -Xms (initial heap size), -Xmx (maximum heap size), aur -XX:+UseG1GC ya -XX:+UseZGC collectors select karne ke liye shaamil hain. Throughput-intensive batch jobs ke liye ParallelGC kafi ho sakta hai; responsive web services ke liye G1 ya ZGC preferable hain. Monitoring tools jaise VisualVM, JConsole, ya GC logs (-Xlog:gc) collection frequency aur pause times analyze karne mein help karte hain. Optimal configuration depend karti hai application behavior pe: allocation rate, object lifetime distribution, aur acceptable pause times. Profiling help karta hai memory leaks aur excessive GC overhead identify karne mein jo indicate karta hai undersized heaps ya code issues."
        },
        "code": {
          "title": "Common GC Flags",
          "language": "java",
          "content": "// Heap sizing\n// -Xms2G -Xmx2G (fixed 2GB heap prevents resizing pauses)\n\n// GC selection\n// -XX:+UseG1GC (Java 8+)\n// -XX:+UseZGC (Java 15+)\n// -XX:+UseParallelGC (throughput)\n\n// Logging (Java 9+)\n// -Xlog:gc*:file=gc.log:time,uptime,level,tags\n\n// G1 specific\n// -XX:MaxGCPauseMillis=100\n// -XX:G1HeapRegionSize=4m\n\n// OOM handling\n// -XX:+HeapDumpOnOutOfMemoryError\n// -XX:HeapDumpPath=/path/to/dumps"
        },
        "codeExplanations": {
          "english": "Xms ko Xmx ke equal set karne se heap resizing pauses prevent hote hain. G1 balanced workloads ke liye select kiya jata hai, ZGC latency-sensitive ke liye, aur Parallel throughput ke liye. GC logging production mein behavior analyze karne mein help karta hai. Heap dumps on OOM memory issues ki post-mortem analysis enable karte hain Eclipse MAT jaise tools use karke."
        },
        "keyPoints": [
          "Balance three metrics: throughput, latency, memory footprint",
          "Size heap appropriately: Xmx should be less than physical RAM to avoid swapping",
          "Use GC logs and monitoring to measure pause times and frequency",
          "Choose collector based on application requirements and Java version"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Collector|Best For|Pause Time|Throughput\nSerial|Single thread|High|Low\nParallel|Batch processing|Medium|High\nG1|General server|Low (configurable)|Medium\nZGC|Low latency apps|Very low (<10ms)|Medium",
          "examples": []
        }
      },
      {
        "id": "s3-3-1",
        "title": "Class Loader Types",
        "explanations": {
          "english": "Java Virtual Machine ek hierarchical delegation system use karta hai teen built-in class loaders ke saath. Bootstrap Class Loader (primordial) native code mein likha hai aur core Java classes (java.lang, java.util) load karta hai bootstrap classpath se (rt.jar/modules). Platform/Extension Class Loader (Java 9 se Extension se change hua) extension directories ya platform modules se classes load karta hai. Application/System Class Loader application classes load karta hai classpath se jo -cp ya CLASSPATH environment variable se specify hota hai. Ye loaders ek parent-child hierarchy form karte hain jahan requests upward delegate hoti hain. Developers custom class loaders bana sakte hain java.lang.ClassLoader extend karke taaki hot-swapping, modular isolation, ya non-standard sources jaise networks ya databases se classes load kar sakein."
        },
        "code": {
          "title": "Class Loader Hierarchy",
          "language": "java",
          "content": "public class ClassLoaderDemo {\n    public static void main(String[] args) {\n        // Show class loader hierarchy\n        ClassLoader appLoader = ClassLoaderDemo.class.getClassLoader();\n        System.out.println(\"Application: \" + appLoader);\n        \n        ClassLoader platformLoader = appLoader.getParent();\n        System.out.println(\"Platform: \" + platformLoader);\n        \n        ClassLoader bootstrapLoader = platformLoader.getParent();\n        System.out.println(\"Bootstrap: \" + bootstrapLoader); // null (native)\n        \n        // String class loaded by bootstrap\n        System.out.println(\"String loader: \" + String.class.getClassLoader()); // null\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye code three-level hierarchy display karta hai: Application loader (sun.misc.Launcher$AppClassLoader), Platform loader (sun.misc.Launcher$ExtClassLoader/PlatformClassLoader), aur Bootstrap loader (null represent karta hai kyunki native code hai). Core classes jaise String getClassLoader() ke liye null return karti hain jo indicate karta hai bootstrap origin."
        },
        "keyPoints": [
          "Bootstrap: Loads core JDK classes from rt.jar/modules, native code",
          "Platform/Extension: Loads extension classes from lib/ext",
          "Application/System: Loads application classpath classes",
          "Custom: User-defined loaders for special loading requirements (OSGi, Tomcat)"
        ],
        "extras": {
          "flowDiagram": "Custom Loader\n      ↓ delegates\nApplication Loader\n      ↓ delegates\nPlatform Loader\n      ↓ delegates\nBootstrap Loader (native)",
          "comparisonTable": "Loader|Loads From|Language\nBootstrap|rt.jar, core modules|Native (C++)\nPlatform|lib/ext, platform modules|Java\nApplication|CLASSPATH, -cp|Java\nCustom|Network, DB, encrypted|Java (extends ClassLoader)",
          "examples": []
        }
      },
      {
        "id": "s3-3-2",
        "title": "Loading Phase",
        "explanations": {
          "english": "Loading phase class loading ka pehla step hai jahan ClassLoader locate aur read karta hai binary bytecode ko filesystem, network, ya other sources se. JVM ek java.lang.Class object create karta hai loaded type ko represent karne ke liye aur class metadata (method bytecode, field data, constant pool) store karta hai Metaspace mein (ya PermGen mein Java 7 aur pehle). Ye phase basic format verification perform karti hai - magic numbers check karna, version compatibility, aur structural integrity - lekin full bytecode verification nahi karti. Loaded class abhi use ke liye ready nahi hai; ye linking phase mein enter karti hai next. Loading explicitly trigger ho sakti hai via Class.forName() ya implicitly jab execution ke time class references encounter hote hain."
        },
        "code": {
          "title": "Loading Trigger Examples",
          "language": "java",
          "content": "// Explicit loading\nClass<?> clazz = Class.forName(\"java.util.ArrayList\");\n\n// Loading with specific loader\nClassLoader cl = Thread.currentThread().getContextClassLoader();\nClass<?> loaded = cl.loadClass(\"com.example.MyClass\");\n\n// Implicit loading occurs when:\n// - Creating new instances (new MyClass())\n// - Accessing static members (MyClass.staticMethod())\n// - Using class literals (MyClass.class)"
        },
        "codeExplanations": {
          "english": "Class.forName() explicitly loading phase trigger karta hai. Thread context class loader web application contexts mein loading ke liye use kiya ja sakta hai. Implicit loading automatically hota hai jab JVM un references ko encounter karta hai jo already loaded nahi hain, ensure karte hue ki classes available hain jab zaroorat ho."
        },
        "keyPoints": [
          "Reads .class file bytes and creates Class object in Metaspace",
          "Performs basic format verification (magic number 0xCAFEBABE, version)",
          "Does not perform full bytecode verification (happens in Linking)",
          "Triggered explicitly by Class.forName() or implicitly by first usage"
        ],
        "extras": {
          "flowDiagram": "findClass() → Locate .class file → Read bytes → Define Class Object → Store in Metaspace",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-3-3",
        "title": "Linking Phase",
        "explanations": {
          "english": "Linking loaded class ko execution ke liye prepare karta hai by combining it with runtime state. Ismein three sequential steps hain: Verification bytecode check karta hai type safety, operand stack consistency, aur valid control flow using Bytecode Verifier; Preparation memory allocate karta hai static fields ke liye aur unhe default values pe initialize karta hai (0, false, null); Resolution symbolic references ko constant pool mein transform karta hai (class names, field/method references) direct memory addresses mein jo actual classes/methods ko point karte hain. Resolution eager (immediate) ya lazy (jab pehli baar use ho) ho sakta hai. Linking ensure karta hai ki class safe hai aur correctly connected hai dependent classes se initialization se pehle."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "Verification: Bytecode checking for safety and structural correctness",
          "Preparation: Allocate static field memory, set default values",
          "Resolution: Convert symbolic references to direct memory pointers",
          "Can occur lazily (on first use) or eagerly (during loading)"
        ],
        "extras": {
          "flowDiagram": "Loaded Class → Verification (safe?) → Preparation (alloc statics) → Resolution (fix pointers) → Ready for Init",
          "comparisonTable": "Step|Action|Checks\nVerification|Bytecode analysis|Type safety, stack consistency\nPreparation|Memory allocation|None (just zero memory)\nResolution|Reference binding|Class existence, access rights",
          "examples": []
        }
      },
      {
        "id": "s3-3-4",
        "title": "Initialization Phase",
        "explanations": {
          "english": "Initialization final phase hai jahan JVM static initializers aur static field assignments execute karta hai source code mein jo order mein appear karte hain. Ye tab hota hai jab class first actively use hoti hai: new se instantiate karke, static member access karke (constants ke alawa), static methods call karke, ya reflection use karke. JVM ensure karta hai ki parent classes fully initialized hain subclasses se pehle. Static blocks aur field initializers textual order mein run karte hain class ke andar. Initialization thread-safe hai; JVM Class object ko lock karta hai initialization ke time pe concurrent initialization issues prevent karne ke liye. Agar initialization exception fail hota hai, toh class erroneous mark ho jata hai aur future attempts mein NoClassDefFoundError throw hota hai original exception ke saath suppressed."
        },
        "code": {
          "title": "Initialization Order",
          "language": "java",
          "content": "public class InitDemo {\n    static {\n        System.out.println(\"Static block 1\");\n    }\n    \n    static int value = initialize();\n    \n    static {\n        System.out.println(\"Static block 2\");\n    }\n    \n    static int initialize() {\n        System.out.println(\"Initializing value\");\n        return 42;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Main started\");\n        System.out.println(InitDemo.value);\n    }\n}\n// Output order:\n// Static block 1\n// Initializing value\n// Static block 2\n// Main started\n// 42"
        },
        "codeExplanations": {
          "english": "Ye example demonstrate karta hai ki static initialization textual order mein hota hai jab class first access hoti hai (main mein). Pehle static block 1 run hota hai, phir field initializer (jo initialize() call karta hai), phir static block 2. Initialization complete hone ke baad hi main method execution continue hota hai."
        },
        "keyPoints": [
          "Executes static blocks and static field initializers in source order",
          "Triggered by first active use (new, static access, reflection)",
          "Parent classes initialized before child classes",
          "Thread-safe: JVM locks Class object during initialization"
        ],
        "extras": {
          "flowDiagram": "First Active Use → Parent Initialized? → Execute Static Blocks (in order) → Execute Static Field Initializers → Class Ready",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-3-5",
        "title": "Delegation Model",
        "explanations": {
          "english": "Delegation model wo class loading mechanism hai jahan class loader class loading request ko apne parent loader ko delegate karta hai pehle, before attempting to load itself. Jab loadClass() invoke hota hai, loader pehle parent.loadClass() call karta hai; agar parents null return karte hain, toh wo findClass() call karta hai locally load karne ke liye. Ye ensure karta hai ki core Java classes Bootstrap loader se load hote hain, preventing rogue code from replacing java.lang.Object jaise classes with malicious versions. Ye model security aur uniqueness guarantees provide karta hai. Lekin kuch containers (jaise Tomcat) delegation break karte hain web applications ke liye isolation provide karne ke liye, child-first loading use karke taaki parent classes override ho sakein jabki system classes abhi bhi delegate hoti hain."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "ClassLoader delegates to parent before attempting to load class itself",
          "Parents check bootstrap → platform → then return down the chain",
          "Prevents duplicate loading and ensures core classes loaded by bootstrap",
          "Breakable for special cases like servlet container isolation"
        ],
        "extras": {
          "flowDiagram": "loadClass() called\n    ↓\nCheck if already loaded? → Yes → Return Class\n    ↓ No\nDelegate to parent\n    ↓\nParent loaded? → Yes → Return Class\n    ↓ No\nfindClass() locally\n    ↓\nReturn Class or ClassNotFoundException",
          "comparisonTable": "Model|Behavior|Use Case\nParent-first (standard)|Delegate up then load|Security, consistency\nChild-first (break)|Load locally first|Web app isolation\nOSGi|Network of loaders|Modular systems",
          "examples": []
        }
      },
      {
        "id": "s3-4-1",
        "title": "Program Counter (PC) Register",
        "explanations": {
          "english": "Program Counter Register ek chhota, thread-private memory area hai jo har thread ke currently executing JVM instruction (opcode) ka address contain karta hai. Kyunki JVM stack-based hai, PC method area ke andar execution flow track karta hai by pointing to next instruction jo bytecode stream mein execute karni hai. Agar current method native (non-Java) hai, toh PC value undefined hoti hai. PC register thread switching aur resumption enable karta hai by exactly yaad rakhna kahan execution chhoda tha. Ye only memory area hai jo OutOfMemoryError nahi throw karta kyunki ye sirf ek chhota fixed amount of memory require karta hai per thread."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "Thread-private register storing current instruction address",
          "Points to next instruction in method bytecode",
          "Undefined when executing native methods",
          "Smallest memory area; never throws OutOfMemoryError"
        ],
        "extras": {
          "flowDiagram": "Thread Execution:\nPC = 0: iload_1\nPC = 1: iload_2  \nPC = 2: iadd\nPC = 3: istore_3",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-4-2",
        "title": "Java Stack",
        "explanations": {
          "english": "Java Virtual Machine Stack (Java Stack) ek thread-private memory area hai jo store karta hai stack frames for method invocations. Har frame mein local variables, operand stack, dynamic linking information, aur return address hota hai. Jab method call hota hai, ek naya frame push hota hai; jab complete hota hai, frame pop hota hai. Stack size thread creation pe fixed hoti hai (-Xss flag) aur StackOverflowError generate kar sakti hai agar exceeded ho (infinite recursion) ya OutOfMemoryError agar new thread create karne ki koshish ki jaye jab insufficient memory ho uske stack ke liye. Stack frames efficiently allocate hote hain aur automatically clean up jab methods return, jisse heap allocation se faster allocation hota hai."
        },
        "code": {
          "title": "Stack Frame Contents",
          "language": "java",
          "content": "public int calculate(int a, int b) {\n    int c = a + b;  // Local variables a, b, c stored in frame\n    return c * 2;   // Operand stack used for calculation\n}\n\n// Frame contains:\n// - Local variable array: [a, b, c]\n// - Operand stack: push a, push b, iadd, push 2, imul\n// - Constant pool reference for dynamic linking\n// - Return address to caller"
        },
        "codeExplanations": {
          "english": "Har method invocation ek frame create karta hai jo space contain karta hai parameters aur local variables ke liye local variable array mein. Operand stack use hota hai intermediate calculations ke liye bytecode execution ke time. Return address batata hai JVM ko kahan continue karna hai method complete hone ke baad."
        },
        "keyPoints": [
          "Thread-private; one Java Stack per thread",
          "Stores frames with local variables, operand stack, return address",
          "Fixed size per thread; StackOverflowError if exceeded",
          "Faster allocation/deallocation than heap (simple pointer bump)"
        ],
        "extras": {
          "flowDiagram": "Thread 1 Stack:\n[calculate frame: locals=[a,b,c], operands=[]]\n[main frame: locals=[args, result]]\n\nThread 2 Stack:\n[run frame: ...]\n[main frame: ...]",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-4-3",
        "title": "Heap",
        "explanations": {
          "english": "Heap primary, shared runtime data area hai jo JVM startup pe allocate hoti hai aur saare object instances aur arrays store karti hai. Ye largest memory area hai aur automatically garbage collector se manage hoti hai. Heap generations mein divided hai (Eden, Survivor, Old/Tenured) ya regions (G1) taaki garbage collection optimize ho sake. Objects tab tak persist karte hain jab tak referenced hain; jab unreachable ho jate hain toh GC ke liye eligible ho jate hain. Heap size -Xms (initial) aur -Xmx (maximum) se control hoti hai. Stack ke opposite, heap allocation slower hoti hai synchronization requirements aur GC management ki wajah se, lekin objects method se jo create kiye gaye hain unse zyada survive kar sakte hain."
        },
        "code": {
          "title": "",
          "language": "",
          "content": ""
        },
        "codeExplanations": {
          "english": ""
        },
        "keyPoints": [
          "Shared among all threads; stores all objects and arrays",
          "Managed by garbage collector; objects survive while referenced",
          "Sized by -Xms (initial) and -Xmx (maximum)",
          "Divided into generations/regions for GC efficiency"
        ],
        "extras": {
          "flowDiagram": "Heap Structure (Generational):\n[Young Gen]: Eden Space [E][E][E...]\n           Survivor 0 [S]\n           Survivor 1 [S]\n[Old Gen]: Tenured Space [O][O][O...]",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s3-4-4",
        "title": "Metaspace",
        "explanations": {
          "english": "Metaspace, Java 8 mein introduce hua, Permanent Generation (PermGen) ko replace kiya class metadata storage area ke roop mein. Ye runtime constant pool, field aur method data, constructor bytecode, aur class-level information store karta hai. Fixed-size PermGen jisse OutOfMemoryError aata tha jab full hota tha, uske opposite Metaspace native memory use karta hai (Java heap ke bahar) aur dynamically expand hota hai, sirf available system memory se limited unless capped with -XX:MaxMetaspaceSize. Class metadata garbage collected hota hai jab unke defining class loaders unload hote hain, jo leaks prevent karta hai dynamic class loading scenarios mein (jaise app servers redeploys). PermGen errors eliminate karne ke bawajood native memory exhaust hone se bachne ke liye monitoring zaroori hai."
        },
        "code": {
          "title": "Metaspace Configuration",
          "language": "java",
          "content": "// JVM Flags for Metaspace\n// -XX:MetaspaceSize=64m (initial size)\n// -XX:MaxMetaspaceSize=256m (max limit, default unlimited)\n// -XX:MinMetaspaceFreeRatio=40\n// -XX:MaxMetaspaceFreeRatio=80\n\n// Check Metaspace usage\n// jcmd <pid> VM.metaspace"
        },
        "codeExplanations": {
          "english": "MetaspaceSize initial committed space set karta hai, heap ke liye -Xms ki tarah. MaxMetaspaceSize unbounded growth prevent karta hai jo native memory exhaust kar sakta hai. Ratio settings control karte hain kab resize karna hai free space percentage ke basis pe. Monitoring commands production mein class loading issues diagnose karne mein help karte hain."
        },
        "keyPoints": [
          "Stores class metadata (methods, fields, constant pool) replacing PermGen",
          "Uses native memory (off-heap), expands automatically",
          "No default limit (unlike PermGen's fixed 64MB default), set MaxMetaspaceSize to cap",
          "Garbage collected when class loaders are unloaded"
        ],
        "extras": {
          "flowDiagram": "Class Loaders → Load Classes → Store metadata in Metaspace\n                            ↓\nClass Loader Unloaded → Metaspace GC reclaims metadata",
          "comparisonTable": "Feature|PermGen (Java 7)|Metaspace (Java 8+)\nLocation|Heap|Native memory\nSize|Fixed, -XX:MaxPermSize|Dynamic, -XX:MaxMetaspaceSize\nGC|Rare|When classloader unloads\nOutOfMemory|Yes (common)|Only if native memory exhausted",
          "examples": []
        }
      },
      {
        "id": "s3-4-5",
        "title": "Native Method Stack",
        "explanations": {
          "english": "Native Method Stack (C Stack) C ya C++ jaise languages mein likhe hue native methods ko execute karne ko support karta hai using Java Native Interface (JNI). Jab thread ek native method invoke karta hai, wo Java Stack se Native Method Stack pe switch karta hai, jo standard C stack convention use karta hai rather than Java's stack frame structure. Ye area thread-private hai aur tab create hoti hai jab thread start hota hai. Native stacks directly configurable nahi hain standard JVM flags jaise -Xss (jo Java Stack configure karta hai) se. Ye StackOverflowError generate kar sakti hai agar native code deeply recurse karta hai ya large stack frames allocate karta hai. Size implementation-dependent hai, typically process stack size ke barabar hoti hai."
        },
        "code": {
          "title": "Native Method Usage",
          "language": "java",
          "content": "public class NativeDemo {\n    // Native method declaration\n    public native void nativeMethod();\n    \n    static {\n        // Load native library\n        System.loadLibrary(\"nativeLib\");\n    }\n    \n    public void callNative() {\n        // Switch to native stack here\n        nativeMethod();\n        // Return to Java stack\n    }\n}"
        },
        "codeExplanations": {
          "english": "Jab nativeMethod() call hota hai, JVM Java bytecode execution se native code execution pe switch karta hai Native Method Stack pe. Library containing native implementation System.loadLibrary() se load hoti hai. Native stacks C-style calling conventions aur memory management handle karte hain Java Stack se alag."
        },
        "keyPoints": [
          "Separate stack for native (JNI) method execution using C conventions",
          "Thread-private; switches from Java Stack when calling native code",
          "Size typically not independently configurable; uses OS process stack",
          "Can throw StackOverflowError from deep recursion in native code"
        ],
        "extras": {
          "flowDiagram": "Thread:\n[Java Stack] → Call nativeMethod() → [Native Stack (C code)]\n                                          ↓\n                                    Return to Java Stack",
          "comparisonTable": "Stack Type|Language|Frame Structure|Config\nJava Stack|Java|JVM specific (locals, operands)|-Xss\nNative Stack|C/C++|Platform ABI (registers, C locals)|OS dependent",
          "examples": []
        }
      }
    ]
  },
  {
    "id": "section-4",
    "title": "Exception Handling",
    "topics": [
      {
        "id": "s4-1-1",
        "title": "Throwable",
        "explanations": {
          "english": "Throwable Java mein sabhi error aur exception classes ka root superclass hai, jo poori exception hierarchy ka starting point hai. Sirf wahi objects jo Throwable ya uske subclasses ke instance hain, JVM throw kar sakta hai ya catch blocks catch kar sakte hain. Ye basic error handling mechanisms provide karta hai - jaise stack trace information (fillInStackTrace ke through), detail messages, aur cause chaining (wrapped exceptions). Throwable ke do direct subclasses hain: Error jo unrecoverable system failures ke liye hai, aur Exception jo application-level conditions ke liye hai jo programs ko catch karna chahiye. Throwable ko samajhna zaroori hai robust error handling strategies design karne ke liye, kyunki ye common interface define karta hai sabhi exceptional conditions ke liye - message retrieval, stack trace printing, aur exception chaining."
        },
        "code": {
          "title": "Throwable Hierarchy",
          "language": "java",
          "content": "// Throwable is checked; must be caught or declared\npublic void riskyMethod() throws Throwable {\n    throw new Throwable(\"Something went wrong\");\n}\n\n// Catching base Throwable (usually not recommended in production)\ntry {\n    riskyMethod();\n} catch (Throwable t) {\n    System.out.println(\"Message: \" + t.getMessage());\n    t.printStackTrace(); // Print full stack trace\n    \n    // Cause chaining\n    Throwable cause = t.getCause();\n    if (cause != null) {\n        System.out.println(\"Caused by: \" + cause);\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye example dikhata hai Throwable ko as a base type jo throw aur catch ho sakta hai. While possible hai Throwable ko catch karna, ye generally bad practice hai except thread execution ke bilkul top level pe, kyunki ye sab kuch catch kar lega including Errors (jaise OutOfMemoryError) jo applications typically handle nahi kar sakti meaningfully tareeke se. Example mein common Throwable methods dikhaye gaye hain: getMessage(), printStackTrace(), aur getCause()."
        },
        "keyPoints": [
          "Java mein sabhi errors aur exceptions ka root superclass",
          "Sirf Throwable objects ko JVM throw kar sakta hai ya catch blocks catch kar sakte hain",
          "Common functionality provide karta hai: message, stack trace, cause chaining",
          "Do main subclasses: Error (unrecoverable) aur Exception (application-level)"
        ],
        "extras": {
          "flowDiagram": "Throwable (abstract/base)\n    ├── Error (unchecked)\n    │   ├── OutOfMemoryError\n    │   ├── StackOverflowError\n    │   └── ...\n    └── Exception\n        ├── RuntimeException (unchecked)\n        │   ├── NullPointerException\n        │   └── IllegalArgumentException\n        └── Other Exceptions (checked)\n            ├── IOException\n            └── SQLException",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s4-1-2",
        "title": "Error",
        "explanations": {
          "english": "Error un serious aur unrecoverable problems ko represent karta hai jo applications ko attempt nahi karna chahiye catch karne ka, jo external factors se aate hain jo program ke control ke bahar hain. Inmein conditions include hain jaise OutOfMemoryError, StackOverflowError, LinkageError, aur VirtualMachineError jo fundamental system failures, resource exhaustion, ya internal JVM errors indicate karte hain. Exceptions ke unlike, errors typically immediate application termination warrant karte hain kyunki recovery usually impossible ya dangerous hota hai. For example, OutOfMemoryError ka matlab hai heap exhaust ho gaya hai; isse catch karne se code thodi der chal sakta hai but likely immediately phir se fail ho jayega. While technically catch kiya ja sakta hai, Errors ko catch karna strongly discouraged hai except logging ke liye ya critical resources ka graceful shutdown attempt karne ke liye before termination."
        },
        "code": {
          "title": "Error Handling (Anti-pattern)",
          "language": "java",
          "content": "// Do NOT do this in production\npublic void dangerousCatch() {\n    try {\n        causeStackOverflow();\n    } catch (Error e) { // Bad practice\n        System.out.println(\"Caught error: \" + e);\n        // Application state may be corrupted; continuing is dangerous\n    }\n}\n\n// Acceptable: Top-level thread exception handler\nThread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {\n    if (throwable instanceof Error) {\n        // Log the error\n        logger.error(\"Fatal JVM error\", throwable);\n        // Attempt graceful shutdown\n        shutdownCriticalResources();\n        // Exit the application\n        System.exit(1);\n    }\n});"
        },
        "codeExplanations": {
          "english": "Pehla example dikhata hai Error ko directly catch karna, jo dangerous hai kyunki JVM unstable state mein ho sakta hai. Doosra example acceptable pattern dikhata hai: top-level uncaught exception handler jo Errors sirf log karne ke liye catch karta hai aur emergency cleanup karke process terminate kar deta hai, acknowledging ki recovery impossible hai."
        },
        "keyPoints": [
          "Serious, unrecoverable problems indicate karta hai (system failures, resource exhaustion)",
          "Subclasses mein include hain OutOfMemoryError, StackOverflowError, VirtualMachineError",
          "Applications ko Errors catch nahi karna chahiye; JVM ko terminate hone do",
          "Error catch karne se OutOfMemoryError capture ho sakta hai but recovery usually impossible hota hai"
        ],
        "extras": {
          "flowDiagram": "System Failure → Error Thrown → (Do Not Catch) → JVM terminates\n                                    ↓\n                           Catch for logging only → Immediate shutdown",
          "comparisonTable": "Aspect|Error|Exception\nRecovery|None|Possible\nCatching|Discouraged|Expected\nExamples|OutOfMemoryError|IOException\nHandling|Log and exit|Recover and continue",
          "examples": [
            "OutOfMemoryError",
            "StackOverflowError",
            "NoClassDefFoundError",
            "VirtualMachineError"
          ]
        }
      },
      {
        "id": "s4-1-3",
        "title": "Exception",
        "explanations": {
          "english": "Exception un sabhi application-level conditions ka superclass hai jo programs ko catch aur handle karna chahiye, jo unhe fatal Errors se distinguish karta hai. Ye scenarios represent karta hai jaise file not found, network timeouts, ya invalid user input jahan recovery possible hai aur program execution meaningfully continue kar sakta hai. Exception khud aur uske non-RuntimeException subclasses checked exceptions hain, matlab compiler require karta hai ki unhe ya to try-catch se catch kiya jaye ya method signature mein throws clause se declare kiya jaye. Ye developers ko force karta hai ki potential failures ko acknowledge karein aur appropriate error handling strategies design karein. Well-designed applications specific Exception subclasses (jaise IOException ya SQLException) use karti hain rather than generic Exception taaki precise error context provide ho sake."
        },
        "code": {
          "title": "Exception Handling Pattern",
          "language": "java",
          "content": "// Checked exception must be caught or declared\npublic void readConfig() throws FileNotFoundException {\n    FileInputStream fis = new FileInputStream(\"app.config\");\n}\n\n// Proper handling\ntry {\n    readConfig();\n    processConfig();\n} catch (FileNotFoundException e) {\n    // Specific handling for missing config\n    useDefaultConfig();\n} catch (IOException e) {\n    // Broader handling for other IO issues\n    logger.error(\"IO error\", e);\n    throw new ApplicationException(\"Config failed\", e);\n}"
        },
        "codeExplanations": {
          "english": "FileNotFoundException checked Exception subclass hai. Method isse throws ke saath declare karta hai, forcing callers ko ise handle karna. Try-catch mein specific exception handling dikhayi gayi hai (FileNotFoundException) general (IOException) se pehle, proper ordering demonstrate karke. Recovery strategies (useDefaultConfig) allow karti hain program ko exception ke baad bhi continue karne."
        },
        "keyPoints": [
          "Application-level conditions ka superclass jo catch kiye jaane chahiye",
          "Compiler se checked: catch karna ya throws clause mein declare karna mandatory hai",
          "Recovery possible hai; program execution continue kar sakta hai",
          "Specific subclasses ko prefer karo generic Exception ke comparison mein precise handling ke liye"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "",
          "examples": [
            "IOException",
            "SQLException",
            "ClassNotFoundException",
            "ParseException"
          ]
        }
      },
      {
        "id": "s4-1-4",
        "title": "RuntimeException",
        "explanations": {
          "english": "RuntimeException un sabhi unchecked exceptions ka superclass hai jo programming errors aur precondition violations represent karte hain jo typically code mein bugs indicate karte hain. Ye exceptions (NullPointerException, IllegalArgumentException, IndexOutOfBoundsException) unchecked hain, matlab compiler explicit catch ya throws declarations require nahi karta, though unhe catch karna desired ho to kiya ja sakta hai. Ye usually improper API usage, invalid assumptions, ya logic errors se result karte hain jo fix kiye jaane chahiye rather than catch kiye jaane. Checked exceptions jo external conditions represent karte hain unke unlike, RuntimeExceptions internal program state violations represent karte hain. Best practices suggest karte hain ki inputs validate karo in exceptions ko prevent karne ke liye rather than catching them, though defensive programming specific ones ko catch kar sakta hai jaise NumberFormatException user input parsing ke liye."
        },
        "code": {
          "title": "RuntimeException Examples",
          "language": "java",
          "content": "// Programming errors - should fix code, not catch\npublic void process(String data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    int value = Integer.parseInt(data); // NumberFormatException possible\n}\n\n// Defensive handling for user input\ntry {\n    int age = Integer.parseInt(userInput);\n} catch (NumberFormatException e) {\n    // Expected possible user error\n    showError(\"Please enter a valid number\");\n}"
        },
        "codeExplanations": {
          "english": "Pehla example dikhata hai proper validation throwing IllegalArgumentException (RuntimeException) API contract violations ke liye. Doosra dikhata hai NumberFormatException (bhi RuntimeException) ko catch karna user input parsing ke liye, jo acceptable hai kyunki user input unpredictable hota hai, internal programming errors ke unlike."
        },
        "keyPoints": [
          "Unchecked exceptions ka superclass jo programming errors indicate karta hai",
          "Unchecked: compiler catching ya declaration enforce nahi karta",
          "Precondition violations, invalid arguments, null dereferences represent karta hai",
          "Usually bugs indicate karte hain; code fix karo rather than exception catch karo"
        ],
        "extras": {
          "flowDiagram": "",
          "comparisonTable": "Exception Type|Checked|Cause|Handling\nException|Yes|External conditions|Catch and recover\nRuntimeException|No|Programming errors|Fix the bug\nError|No|System failure|Do not catch",
          "examples": [
            "NullPointerException",
            "IllegalArgumentException",
            "IndexOutOfBoundsException",
            "NumberFormatException"
          ]
        }
      },
      {
        "id": "s4-2-1",
        "title": "Compile-time Checking",
        "explanations": {
          "english": "Compile-time checking matlab compiler ka enforcement of checked exceptions, jo require karta hai ki koi bhi method jo checked exception throw karta hai, usse ya to try-catch block se catch kiya jaye ya method signature mein throws clause se declare kiya jaye. Ye ek compile-time contract create karta hai jo document karta hai ki kaunse exceptions method se propagate ho sakti hain, forcing developers ko error handling ke baare mein development ke time par sochna rather than runtime par failures discover karna. Compiler verify karta hai ki checked exceptions throws clause mein ya to callers ke dwara caught ho ya unke apne throws clauses mein declared ho, accountability chain create karke up to appropriate handler tak. Ye mechanism ensure karta hai ki recoverable error conditions (I/O failures, database errors, missing files) explicitly acknowledged ho API design mein."
        },
        "code": {
          "title": "Checked Exception Enforcement",
          "language": "java",
          "content": "// Method declares checked exception\npublic void readFile(String path) throws IOException {\n    FileReader reader = new FileReader(path);\n    // ...\n}\n\n// Caller must handle or declare\npublic void processFile(String path) {\n    // Compiler error if try-catch missing\n    try {\n        readFile(path);\n    } catch (IOException e) {\n        // Must handle\n        log.error(\"Read failed\", e);\n    }\n}\n\n// OR declare it\npublic void processFile(String path) throws IOException {\n    readFile(path); // OK, declares throws\n}"
        },
        "codeExplanations": {
          "english": "readFile method IOException ko throws ke saath declare karta hai. Compiler force karta hai callers (processFile) ko ki ya to IOException ko try-catch block mein catch karein ya throws IOException apne signature mein add karein. Ye explicit handling obligations ki chain create karta hai up the call stack jab tak koi isse catch nahi kar leta."
        },
        "keyPoints": [
          "Compiler verify karta hai ki checked exceptions catch ki gayi hain ya declare ki gayi hain",
          "Potential failure modes ko APIs mein explicitly document karne par force karta hai",
          "Recoverable error conditions ke liye compile-time safety create karta hai",
          "Unchecked exceptions (RuntimeException/Error) is checking ko bypass karte hain"
        ],
        "extras": {
          "flowDiagram": "Method A throws IOException → Method B calls A → Compile Error unless: \n    ↓\nMethod B catches OR Method B declares throws IOException",
          "comparisonTable": "Checking Type|When|Exceptions|Action Required\nChecked|Compile time|IOException, SQLException|Catch or declare\nUnchecked|Runtime|RuntimeException, Error|Optional handling",
          "examples": []
        }
      },
      {
        "id": "s4-2-2",
        "title": "Runtime Exceptions",
        "explanations": {
          "english": "Runtime exceptions programming errors aur precondition violations represent karte hain jo program execution ke dauran occur hote hain but compiler se check nahi kiye jaate. Ye typically logic errors, invalid assumptions, ya improper API usage se result karte hain jo proper validation se prevent kiye jaane chahiye rather than caught. Common examples mein include hain NullPointerException jab null ko dereference kiya jaye, IllegalArgumentException invalid parameters ke liye, aur IndexOutOfBoundsException array/string access violations ke liye. Kyunki ye bugs indicate karte hain, recommended approach hai ki inputs aur state proactively validate karo rather than catching these exceptions. However, unhe high-level boundaries pe (jaise controller layers) catch kiya ja sakta hai user-friendly error messages mein convert karne ya debugging ke liye log karne ke liye, business logic flow control ke liye nahi."
        },
        "code": {
          "title": "Runtime Exception Prevention",
          "language": "java",
          "content": "// Bad: Relying on catch for flow control\ntry {\n    int value = Integer.parseInt(input);\n} catch (NumberFormatException e) {\n    value = 0; // Using exception for logic\n}\n\n// Good: Validation before operation\nif (input != null && input.matches(\"\\\\d+\")) {\n    int value = Integer.parseInt(input);\n} else {\n    value = 0; // Explicit handling\n}\n\n// Guard clauses to prevent NPE\npublic void processUser(User user) {\n    if (user == null) {\n        throw new IllegalArgumentException(\"User required\");\n    }\n    if (user.getEmail() == null) {\n        throw new IllegalStateException(\"Email required\");\n    }\n    // Process safely\n}"
        },
        "codeExplanations": {
          "english": "Pehla example anti-pattern dikhata hai: exceptions ka use flow control ke liye. Improved version format validate karta hai parsing se pehle. Guard clause pattern preconditions validate karta hai aur IllegalArgumentException (RuntimeException) immediately throw karta hai agar contract violate hota hai, downstream NullPointerExceptions prevent karke aur failures explicit bana ke."
        },
        "keyPoints": [
          "Unchecked: compiler handling enforce nahi karta",
          "Programming errors aur precondition violations indicate karte hain",
          "Validation se prevent karo rather than catching",
          "Boundaries pe logging/user messages ke liye catch kiya ja sakta hai"
        ],
        "extras": {
          "flowDiagram": "Invalid Input → NullPointerException → (Should have validated)\nValid Input → Process → Success",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s4-2-3",
        "title": "When to Use Which",
        "explanations": {
          "english": "Checked aur unchecked exceptions ke beech choose karna depend karta hai ki kya caller condition se reasonably recover kar sakta hai aur kya exception programming error represent karta hai ya external failure. Use checked exceptions un recoverable conditions ke liye jahan caller se expect kiya jata hai ki failure handle kare (IOException, SQLException, ParseException). Use unchecked exceptions (RuntimeException) programming errors, precondition violations, ya conditions ke liye jahan recovery impossible ya unlikely hai (NullPointerException, IllegalStateException). Custom exceptions ko Exception extend karna chahiye business errors ke liye jo explicit handling require karte hain, ya RuntimeException API contract violations ke liye. Checked exceptions ka overuse APIs ko burden karta hai unnecessary handling code se, jabki underuse critical error conditions miss karne ka risk create karta hai."
        },
        "code": {
          "title": "Exception Selection Guidelines",
          "language": "java",
          "content": "// Checked: Recoverable external condition\npublic class PaymentProcessingException extends Exception {\n    public PaymentProcessingException(String msg, Throwable cause) {\n        super(msg, cause);\n    }\n}\n\n// Unchecked: Programming error\npublic class InvalidCurrencyException extends RuntimeException {\n    public InvalidCurrencyException(String currency) {\n        super(\"Unsupported currency: \" + currency);\n    }\n}\n\n// Usage\npublic void processPayment(PaymentRequest request) \n    throws PaymentProcessingException { // Checked: network might fail\n    \n    if (!isValidCurrency(request.getCurrency())) {\n        throw new InvalidCurrencyException(request.getCurrency()); \n        // Unchecked: caller should validate before calling\n    }\n    // ...\n}"
        },
        "codeExplanations": {
          "english": "PaymentProcessingException checked hai kyunki network/DB failures external hain aur possibly recoverable (retry, alternate payment). InvalidCurrencyException unchecked hai kyunki callers ko currency validate karni chahiye call karne se pehle; invalid currency pass karna programming error hai (precondition violation). Ye distinction API users ko help karta hai samajhne mein ki kaunse failures expect aur handle karne hain."
        },
        "keyPoints": [
          "Checked: Recoverable conditions, external resources, handling expect karte hain",
          "Unchecked: Programming errors, precondition violations, unrecoverable",
          "Custom types ke liye Exception extend karo checked ke liye, RuntimeException unchecked ke liye",
          "Programming logic errors ke liye checked exceptions avoid karo"
        ],
        "extras": {
          "flowDiagram": "External Resource Failure (IO, DB, Network) → Checked Exception\nInvalid Argument/State (null, range, format) → Unchecked Exception",
          "comparisonTable": "Scenario|Type|Example\nFile not found|Checked|IOException\nNetwork timeout|Checked|SocketTimeoutException\nNull argument|Unchecked|IllegalArgumentException\nArray index wrong|Unchecked|IndexOutOfBoundsException\nBusiness rule violation|Checked/Design choice|InsufficientFundsException",
          "examples": []
        }
      },
      {
        "id": "s4-3-1",
        "title": "Multiple Catch Blocks",
        "explanations": {
          "english": "Java multiple catch blocks allow karta hai different exception types handle karne ke liye specific recovery strategies ke saath har failure mode ke liye. Blocks order mein evaluate hote hain, aur pehla matching catch exception handle karta hai, isliye specific exception types ko more general ones se pehle hona chahiye taaki unreachable code compilation errors avoid ho sakein. Java 7 ne multi-catch syntax introduce kiya (catch (Exception1 | Exception2 e)) jo shared handling allow karta hai unrelated exception types ke liye same recovery logic ke saath, code duplication reduce karke. Har catch block isolated scope represent karta hai; ek mein declare kiye variables doosre mein visible nahi hote. Proper ordering hierarchy follow karti hai most specific (FileNotFoundException) se most general (IOException) tak."
        },
        "code": {
          "title": "Multiple Catch Patterns",
          "language": "java",
          "content": "try {\n    processFile();\n} catch (FileNotFoundException e) {\n    // Specific: create default file\n    createDefaultFile();\n} catch (IOException e) {\n    // General: log and retry\n    logger.error(\"IO error\", e);\n    retryOperation();\n} catch (Exception e) {\n    // Catch-all for unexpected\n    logger.fatal(\"Unexpected error\", e);\n    throw e;\n}\n\n// Java 7+ Multi-catch\ntry {\n    processData();\n} catch (SQLException | IOException e) {\n    // Common handling for different exception types\n    logger.error(\"Data access failed\", e);\n    throw new DataAccessException(e);\n}"
        },
        "codeExplanations": {
          "english": "Pehla example ordered catches dikhata hai: FileNotFoundException (specific) IOException (general) se pehle. Unhe reverse karna FileNotFoundException ko unreachable bana dega. Multi-catch example dikhata hai SQLException aur IOException ko identically handle karna without code duplication, common supertype (Exception/Throwable) ko variable 'e' ko implicitly assign karte hue."
        },
        "keyPoints": [
          "Catch blocks ko most specific se most general tak order karo",
          "Unreachable catch blocks compilation errors cause karte hain",
          "Multi-catch (Java 7+) multiple unrelated exceptions ko same logic se handle karta hai",
          "Har catch block apna scope rakhta hai; local variables shared nahi hain"
        ],
        "extras": {
          "flowDiagram": "Exception Thrown → Match FileNotFoundException? → Yes → Execute Block 1\n                ↓ No\n         Match IOException? → Yes → Execute Block 2\n                ↓ No\n         Match Exception? → Yes → Execute Block 3",
          "comparisonTable": "Approach|Syntax|Use Case\nSequential catch|catch(A) catch(B)|Different handling per type\nMulti-catch|catch(A | B)|Same handling for multiple types",
          "examples": []
        }
      },
      {
        "id": "s4-3-2",
        "title": "Exception Propagation",
        "explanations": {
          "english": "Exception propagation wo process hai jahan exception method call stack upar move karta hai jab current method mein catch nahi kiya jata. Jab koi method exception encounter karta hai jo handle nahi karta, execution immediately stop ho jata hai aur exception calling method ko pass ho jata hai. Ye continue karta hai up the stack jab tak ya to koi method exception catch nahi kar le appropriate catch block se ya top-level tak nahi pahonch jata (main thread ya ThreadGroup), resulting in thread termination aur stack trace printing. Methods propagated checked exceptions ko throws clause se declare karte hain, documenting kaunse exceptions escape ho sakti hain. Propagation allow karta hai errors ko appropriate levels pe handle karne (e.g., UI layer user errors handle kare, service layer business logic errors handle kare) rather than har intermediate level pe."
        },
        "code": {
          "title": "Stack Unwinding",
          "language": "java",
          "content": "// Method 3: Originates exception\nprivate void method3() throws IOException {\n    throw new IOException(\"Disk full\");\n}\n\n// Method 2: Passes through\nprivate void method2() throws IOException {\n    method3(); // Propagates up\n}\n\n// Method 1: Handles\nprivate void method1() {\n    try {\n        method2();\n    } catch (IOException e) {\n        // Caught here after propagating through method2\n        handleError(e);\n    }\n}\n\n// Stack trace shows:\n// java.io.IOException: Disk full\n// at method3(...)\n// at method2(...)\n// at method1(...)"
        },
        "codeExplanations": {
          "english": "method3 throw karta hai IOException bina catch kiye. method2 bhi isse catch nahi karta, isliye ye further propagate hota hai (throws IOException declare karna padta hai). method1 isse catch karta hai, propagation rok ke. Stack trace origin (method3) aur call chain preserve karta hai, debug enable karke ki exception kahan se originate hua."
        },
        "keyPoints": [
          "Uncaught exceptions automatically call stack upar propagate hote hain",
          "Methods propagated checked exceptions ko throws clause se declare karte hain",
          "Execution current method mein stop hota hai; control handler ko upar stack mein pass hota hai",
          "Stack trace origin aur call chain information preserve karta hai"
        ],
        "extras": {
          "flowDiagram": "method1() calls → method2() calls → method3() throws IOException\n        ↑                       ↑\n        ↓                       ↓\n    Catch here ← Propagates ← Throw\n    (Stack unwinds)",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s4-3-3",
        "title": "Suppressed Exceptions",
        "explanations": {
          "english": "Suppressed exceptions wo secondary exceptions hain jo resource cleanup ke dauran try-finally ya try-with-resources blocks mein occur hote hain, but primary exception se mask ho jate hain. Java 7 se pehle, agar exception try block aur finally block dono mein occur hota, finally exception original ko overwrite kar deta, root cause lose ho jata. Java 7 ne addSuppressed() introduce kiya additional exceptions ko primary exception se attach karne ke liye, saari error information preserve karke. Try-with-resources automatically suppression handle karta hai; agar try block aur resource close() dono throw karte hain, close exception try block exception ke suppressed ke roop mein add ho jata hai. Jab logs analyze karte hain, suppressed exceptions complete context provide karte hain cleanup operations ke dauran failures ke baare mein."
        },
        "code": {
          "title": "Handling Suppressed Exceptions",
          "language": "java",
          "content": "try (Resource res = new Resource()) {\n    res.doWork(); // Throws WorkException\n} catch (WorkException e) {\n    // Primary exception\n    System.out.println(\"Primary: \" + e.getMessage());\n    \n    // Check for suppressed (close failures)\n    for (Throwable suppressed : e.getSuppressed()) {\n        System.out.println(\"Suppressed: \" + suppressed.getMessage());\n    }\n}\n\n// Manual suppression (before try-with-resources)\npublic void manualClose() {\n    Exception primary = null;\n    Resource res = null;\n    try {\n        res = new Resource();\n        res.doWork();\n    } catch (Exception e) {\n        primary = e;\n        throw e;\n    } finally {\n        try {\n            res.close();\n        } catch (Exception closeEx) {\n            if (primary != null) {\n                primary.addSuppressed(closeEx);\n            }\n        }\n    }\n}"
        },
        "codeExplanations": {
          "english": "Try-with-resources example dikhata hai ki agar doWork() aur close() dono throw karte hain, to close exception work exception ke suppressed ke roop mein add ho jata hai. Catch block dono ko access karta hai getSuppressed() ke through. Manual example dikhata hai kaise suppression logic manually implement kiya ja sakta hai addSuppressed() use karke, saari error information preserve karke."
        },
        "keyPoints": [
          "Secondary exceptions jo cleanup ke dauran occur hote hain primary exception se attach ho jate hain",
          "Original exception ko lose hone se prevent karta hai jab bhi cleanup bhi fail hota hai",
          "Try-with-resources automatically suppression manage karta hai",
          "Access karo Throwable.getSuppressed() aur Throwable.addSuppressed() ke through"
        ],
        "extras": {
          "flowDiagram": "Try block: throws Exception A\n    ↓\nFinally/Close: throws Exception B\n    ↓\nResult: Exception A with Exception B as suppressed (not lost)",
          "comparisonTable": "Java Version|Behavior\nPre-Java 7|Finally exception overwrites try exception (lost)\nJava 7+|Suppressed exceptions preserve both",
          "examples": []
        }
      },
      {
        "id": "s4-3-4",
        "title": "finally Block Behavior",
        "explanations": {
          "english": "Finally block execute hota hai chahe try block normally complete ho, exception throw kare, ya return, break, ya continue statement use kare. Ye essential cleanup operations ke liye designed hai jaise resources close karna, locks release karna, ya connections pools mein return karna. Chahe exception throw ho aur catch ho, ya method try block mein return kare, finally run karta hai control method chhodne se pehle. However, agar JVM exit kare (System.exit()) ya thread abruptly interrupt/kill ho jaye, finally execute nahi ho sakta. Dhyan rakhna zaroori hai kyunki finally mein throw hone wala exception try block ke exception ko mask kar dega. Finally blocks ko avoid karna chahiye throwing exceptions ya unhe internally handle karna chahiye original error context preserve karne ke liye."
        },
        "code": {
          "title": "Finally Execution Guarantees",
          "language": "java",
          "content": "public int testFinally() {\n    try {\n        return 1; // Finally runs before return\n    } finally {\n        System.out.println(\"Finally executes\");\n        // If this threw exception, it would mask the return\n    }\n}\n\n// Resource cleanup pattern\nConnection conn = null;\ntry {\n    conn = getConnection();\n    processData(conn);\n} catch (SQLException e) {\n    handleError(e);\n} finally {\n    // Always executes, even if return/break/continue/exception\n    if (conn != null) {\n        try {\n            conn.close();\n        } catch (SQLException e) {\n            // Log but don't throw to preserve original exception\n            logger.error(\"Close failed\", e);\n        }\n    }\n}"
        },
        "codeExplanations": {
          "english": "Pehla example dikhata hai finally execute hota hai even when try returns 1. Doosre example mein, connection close in finally mein hota hai chahe processData succeed kare, SQLException throw kare, ya early return kare. Close exception log ki jaati hai rather than throw ki, taaki original SQL exception jo processData mein occur ho sakta hai mask na ho."
        },
        "keyPoints": [
          "Hamesha execute hota hai (unless JVM abruptly exit ho)",
          "Try complete hone, return execute hone, ya catch handle karne ke baad run karta hai",
          "Cleanup ke liye use karo jo zaroori hai: files close karna, locks release karna, resources return karna",
          "Finally mein exceptions throw karna avoid karo; original exceptions mask ho jayenge"
        ],
        "extras": {
          "flowDiagram": "Try Block:\n    Normal completion → Finally → Continue\n    Exception thrown → Catch (if exists) → Finally → Propagate if uncaught\n    Return statement → Finally → Return",
          "comparisonTable": "Scenario|Finally Executes?\nTry completes|Yes\nException caught|Yes\nException uncaught|Yes\nReturn in try|Yes\nSystem.exit()|No\nThread killed|No",
          "examples": []
        }
      },
      {
        "id": "s4-4-1",
        "title": "Explicit Exception Throwing",
        "explanations": {
          "english": "Throw statement explicitly exception object raise karta hai, immediately control nearest enclosing catch block ko transfer karke ya call stack upar propagate karke. Koi bhi Throwable object throw kiya ja sakta hai, though typically Error ya Exception subclasses use hote hain. Throw karte waqt, exception object current stack trace capture karta hai throw point pe, debugging enable karke. Throwing use hota hai program logic ke dwara detect kiye gaye exceptional conditions signal karne ke liye (jaise invalid arguments) aur caught exceptions ko re-throw karne ke liye partial handling ya wrapping ke baad. Thrown exceptions current method execution immediately terminate kar dete hain, making throw useful for guard clauses jo early exit karte hain jab preconditions violate hoti hain."
        },
        "code": {
          "title": "Throw Statement Usage",
          "language": "java",
          "content": "public void withdraw(double amount) {\n    // Guard clause with explicit throw\n    if (amount <= 0) {\n        throw new IllegalArgumentException(\"Amount must be positive: \" + amount);\n    }\n    if (amount > balance) {\n        throw new InsufficientFundsException(\"Balance: \" + balance + \", Requested: \" + amount);\n    }\n    \n    balance -= amount;\n}\n\n// Re-throwing exceptions\ntry {\n    process();\n} catch (ServiceException e) {\n    // Wrap and throw with context\n    throw new BusinessException(\"Processing failed for order \" + orderId, e);\n}"
        },
        "codeExplanations": {
          "english": "Withdraw method throw use karta hai precondition validation ke liye, descriptive messages ke saath immediately exit karte hue jab conditions fail hoti hain. Pehla throw standard IllegalArgumentException use karta hai API violations ke liye; doosra custom InsufficientFundsException use karta hai domain errors ke liye. Doosra example dikhata hai catching aur wrapping (chaining) context add karne ke liye re-throw karne se pehle."
        },
        "keyPoints": [
          "throw statement immediately control handler ko transfer karta hai",
          "Throw point pe stack trace create karta hai; current method execution terminate karta hai",
          "Guard clauses, validation failures, aur wrapped exceptions re-throw karne ke liye use hota hai",
          "Koi bhi Throwable throw kar sakta hai, typically Exception ya RuntimeException subclasses"
        ],
        "extras": {
          "flowDiagram": "Check Condition → If invalid → throw NewException → Control to Catch Block\n                ↓ Valid\n        Continue Processing",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s4-4-2",
        "title": "Declaring Exceptions",
        "explanations": {
          "english": "Method declaration mein throws clause specify karta hai kaunse checked exceptions method throw kar sakta hai, alerting callers ki unhe in exceptions ko handle karna hoga ya apne signatures mein declare karna hoga. Ye method contract ke failure modes document karta hai, API ka part jo backward compatibility maintain karna padta hai. Methods multiple exception types comma se separate karke declare kar sakte hain, aur subclasses overriding methods same ya more specific (subclass) exceptions declare kar sakte hain, but broader ones nahi. Unchecked exceptions (RuntimeException subclasses) declare karna allowed hai but discouraged hai kyunki ye unchecked hote hain. Interface methods jo checked exceptions declare karte hain force karte hain implementations ko unhe handle ya declare karne, ensuring consistent error handling contracts across polymorphic types."
        },
        "code": {
          "title": "Throws Clause Usage",
          "language": "java",
          "content": "// Declare multiple checked exceptions\npublic void parseFile(String path) \n    throws FileNotFoundException, ParseException, IOException {\n    \n    FileReader reader = new FileReader(path); // FNFException\n    Parser p = new Parser(reader);\n    p.parse(); // ParseException\n}\n\n// Overriding: can declare same or subclass (covariant)\n@Override\npublic void parseFile(String path) throws FileNotFoundException {\n    // OK: IOException and ParseException are omitted (not broader)\n}\n\n// Cannot declare broader exception in override\n// @Override\n// public void parseFile(String path) throws Exception { // Compile error!"
        },
        "codeExplanations": {
          "english": "parseFile teen checked exceptions declare karta hai jo throw ho sakti hain. Callers ko inhe catch ya declare karna padta hai. Override karte waqt, method subset declare kar sakta hai (sirf FileNotFoundException) kyunki ye parent ke declared exceptions se more specific hai. Exception (declared exceptions ka superclass) declare karna broader hoga aur overrides mein illegal hai."
        },
        "keyPoints": [
          "Checked exceptions document karta hai jo method throw kar sakta hai",
          "Caller ko checked exceptions catch ya declare karni padti hain jo listed hain",
          "Override same ya subset/subclass of parent's exceptions declare kar sakta hai\n            Not broader",
          "Method contract ka part; declaration change karna API compatibility break karta hai"
        ],
        "extras": {
          "flowDiagram": "Method Declaration: throws ExceptionA, ExceptionB\n    ↓\nCaller must:\n    - Catch in try-catch, OR\n    - Declare in own throws clause",
          "comparisonTable": "Declares|Checked Exceptions|Unchecked Exceptions\nRequired|Yes|Optional (discouraged)\nOverride rule|Same or subset|No restriction\nAPI Impact|Breaking change|Non-breaking",
          "examples": []
        }
      },
      {
        "id": "s4-4-3",
        "title": "Chained Exceptions",
        "explanations": {
          "english": "Exception chaining original exception preserve karta hai jab usse higher-level exception mein wrap kiya jata hai, abstraction boundaries across complete error context maintain karke. Low-level cause (jaise SQLException) high-level exception constructor ko pass kiya jata hai (jaise RepositoryException), jo initCause() ke through store karta hai. Chaining prevent karta hai root cause information loss ko jab exceptions architectural layers ke beech translate hote hain (persistence se service se UI tak). Complete causal chain access ki ja sakti hai getCause() ke through aur stack traces mein 'Caused by' ke roop mein appear hota hai. Ye crucial hai multi-layer applications debug karne ke liye jahan original error deep infrastructure code mein occur hota hai but several abstraction layers se report karna padta hai."
        },
        "code": {
          "title": "Exception Chaining Pattern",
          "language": "java",
          "content": "try {\n    executeQuery();\n} catch (SQLException e) {\n    // Wrap low-level exception with context\n    throw new DataAccessException(\"Failed to fetch user \" + userId, e);\n}\n\n// Custom exception supporting chaining\npublic class DataAccessException extends RuntimeException {\n    public DataAccessException(String message, Throwable cause) {\n        super(message, cause); // Chains cause\n    }\n}\n\n// Accessing the chain\ntry {\n    process();\n} catch (DataAccessException e) {\n    System.out.println(\"Message: \" + e.getMessage());\n    \n    Throwable cause = e.getCause();\n    while (cause != null) {\n        System.out.println(\"Caused by: \" + cause.getClass().getName());\n        cause = cause.getCause();\n    }\n}"
        },
        "codeExplanations": {
          "english": "SQLException catch karke DataAccessException mein wrap kiya jata hai added context (userId) ke saath. Original exception cause parameter ke roop mein pass kiya jata hai. Custom exception constructors ko Throwable cause accept karna chahiye aur superclass ko pass karna chahiye. Jab print ya log karte hain, stack trace full causal chain dikhata hai, debugging enable karke high-level error se original database failure tak trace karne mein."
        },
        "keyPoints": [
          "Original exception preserve karta hai jab wrap kiya jaye higher-level exception mein",
          "Original exception ko constructor parameter (cause) ke roop mein pass karo",
          "Access karo getCause() ke through aur 'Caused by' ke roop mein stack traces mein display hota hai",
          "Architectural layers across debugging ke liye essential hai"
        ],
        "extras": {
          "flowDiagram": "BusinessException: \"Payment failed\"\n    ↑ getCause()\nServiceException: \"Transaction rolled back\"\n    ↑ getCause()\nSQLException: \"Connection timeout\" ← Root cause",
          "comparisonTable": "Without Chaining|With Chaining\nMessage only|Full stack trace preserved\nRoot cause lost|getCause() traces origin\nHard to debug|Complete context",
          "examples": []
        }
      },
      {
        "id": "s4-5-1",
        "title": "Creating Custom Exceptions",
        "explanations": {
          "english": "Custom exceptions domain-specific error types provide karte hain jo precise failure information communicate karte hain application-specific vocabulary mein, code clarity improve karte hain generic exceptions jaise Exception ya RuntimeException ke comparison mein. Ye Exception extend karte hain checked business rule violations ke liye jo callers ko handle karna padta hai, ya RuntimeException programming errors ke liye. Well-designed custom exceptions multiple constructors include karte hain Throwable ko match karte hue: no-arg, message only, cause only, aur message+cause. Unmein fields hone chahiye context data ke liye (jaise account numbers, error codes) aur descriptive messages jo explain karein kya galat hua aur potentially kaise fix karein. Naming convention 'Exception' se end hone wali follow karni chahiye (e.g., InsufficientFundsException) aur clearly error condition communicate karni chahiye."
        },
        "code": {
          "title": "Custom Exception Implementation",
          "language": "java",
          "content": "// Checked exception for business rules\npublic class InsufficientFundsException extends Exception {\n    private final String accountId;\n    private final double requested;\n    private final double available;\n    \n    // Standard constructors\n    public InsufficientFundsException(String accountId, double requested, double available) {\n        super(String.format(\"Account %s: requested %.2f, available %.2f\", \n              accountId, requested, available));\n        this.accountId = accountId;\n        this.requested = requested;\n        this.available = available;\n    }\n    \n    public InsufficientFundsException(String message, Throwable cause) {\n        super(message, cause);\n        this.accountId = null;\n        this.requested = 0;\n        this.available = 0;\n    }\n    \n    // Context getters\n    public String getAccountId() { return accountId; }\n    public double getRequested() { return requested; }\n    public double getAvailable() { return available; }\n}\n\n// Usage\nthrow new InsufficientFundsException(\"ACC-123\", 1000.0, 500.0);"
        },
        "codeExplanations": {
          "english": "InsufficientFundsException Exception extend karta hai (checked) indicating ye condition caller ko expect aur handle karni chahiye. Ye context (accountId, amounts) store karta hai fields mein programmatic access ke liye jabki formatted message provide karta hai human readability ke liye. Multiple constructor pattern different creation scenarios support karta hai: context data ke saath ya wrapping/chaining ke saath."
        },
        "keyPoints": [
          "Exception (checked) ya RuntimeException (unchecked) extend karo",
          "Char standard constructors provide karo: (), (msg), (cause), (msg, cause)",
          "Domain-specific data fields include karo context ke liye",
          "Naming convention follow karo: [Condition]Exception"
        ],
        "extras": {
          "flowDiagram": "CustomException extends Exception\n    ├── Fields (context data)\n    ├── Constructors (4 standard forms)\n    ├── Getters for context\n    └── Descriptive message formatting",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s4-5-2",
        "title": "Context-aware Exceptions",
        "explanations": {
          "english": "Context-aware exceptions relevant application state embed karte hain exception object ke andar, enabling sophisticated error handling aur logging bina catch block ko full scope access chahiye jahan error occur hua. Ismein identifiers (userId, orderId, transaction references), attempted values (invalid input), system states (current queue depth), aur environmental information (server node, timestamp) include hain. Context encapsulate karke, exceptions automated monitoring aur alerting systems support karte hain jo error details parse kar sakte hain, jabki allow karte hain human operators ko diagnose issues logs se bina scenario reproduce kiye. Context fields final hone chahiye, constructors ke through set kiye jaane chahiye, aur getter methods ke through exposed hone chahiye immutable data transfer ke liye."
        },
        "code": {
          "title": "Rich Context Exception",
          "language": "java",
          "content": "public class PaymentProcessingException extends RuntimeException {\n    private final String transactionId;\n    private final String merchantId;\n    private final BigDecimal amount;\n    private final PaymentMethod method;\n    private final Instant timestamp;\n    \n    public PaymentProcessingException(String txId, String merchantId, \n                                     BigDecimal amount, PaymentMethod method,\n                                     String message, Throwable cause) {\n        super(String.format(\"%s [TX:%s, Merchant:%s]\", message, txId, merchantId), cause);\n        this.transactionId = txId;\n        this.merchantId = merchantId;\n        this.amount = amount;\n        this.method = method;\n        this.timestamp = Instant.now();\n    }\n    \n    // Structured logging support\n    public Map<String, String> toContextMap() {\n        Map<String, String> ctx = new HashMap<>();\n        ctx.put(\"transactionId\", transactionId);\n        ctx.put(\"merchantId\", merchantId);\n        ctx.put(\"amount\", amount.toString());\n        ctx.put(\"method\", method.name());\n        ctx.put(\"timestamp\", timestamp.toString());\n        return ctx;\n    }\n}"
        },
        "codeExplanations": {
          "english": "Ye exception rich context capture karta hai including identifiers, financial amounts, payment method, aur automatic timestamping. toContextMap() method structured logging integration facilitate karta hai (e.g., SLF4J MDC ya ELK stack) allowing monitoring systems ko index aur query error context bina string messages parse kiye."
        },
        "keyPoints": [
          "Identifiers, values, aur state embed karo jo error relevant ho",
          "Both human-readable messages aur programmatic data access support karo",
          "Timestamps aur environmental details automatically include karo",
          "Structured export methods provide karo (toMap, toJSON) logging systems ke liye"
        ],
        "extras": {
          "flowDiagram": "Error occurs in context:\nTransactionID: TX123\nUserID: U456\nAmount: $500\n    ↓\nException captures all fields\n    ↓\nHandler logs structured data:\n{txId: TX123, userId: U456, amount: 500}",
          "comparisonTable": "Context Type|Examples|Usage\nIdentifiers|OrderID, UserID, SessionID|Trace specific entity\nValues|Input amount, requested size|See attempted operation\nEnvironment|Server, Region, Version|Infrastructure debugging\nTemporal|Timestamp, Duration|Timing analysis",
          "examples": []
        }
      },
      {
        "id": "s4-5-3",
        "title": "Internationalization-ready Messages",
        "explanations": {
          "english": "Internationalization-ready exception messages error codes ko display text se separate karte hain, enabling localization of error messages different languages aur locales ke liye. Hardcoded English messages ke bajaye, exceptions message keys carry karte hain (e.g., 'error.insufficient.funds') aur placeholder parameters jo localized ResourceBundle properties files se map hote hain. Ye allow karta hai presentation layer (UI ya API response) ko technical exceptions convert karne user-friendly, culturally appropriate messages mein using MessageFormat. Exception ko message key aur parameters fields ke roop mein store karna chahiye, getLocalizedMessage(Locale) method provide karna chahiye ya global exception handler pe rely karna chahiye lookup perform karne ke liye. Ye approach multi-language applications support karta hai jabki exception classes ko presentation concerns se independent rakhta hai."
        },
        "code": {
          "title": "I18n Exception Pattern",
          "language": "java",
          "content": "public class LocalizedException extends RuntimeException {\n    private final String messageKey;\n    private final Object[] params;\n    \n    public LocalizedException(String key, Object... params) {\n        super(key); // Store key as message for default\n        this.messageKey = key;\n        this.params = params;\n    }\n    \n    public String getLocalizedMessage(Locale locale) {\n        ResourceBundle bundle = ResourceBundle.getBundle(\"errors\", locale);\n        String pattern = bundle.getString(messageKey);\n        return MessageFormat.format(pattern, params);\n    }\n}\n\n// Usage\nthrow new LocalizedException(\"error.insufficient.funds\", accountId, requested);\n\n// ResourceBundle: errors_en.properties\n// error.insufficient.funds=Account {0} has insufficient funds for amount {1}\n\n// ResourceBundle: errors_fr.properties  \n// error.insufficient.funds=Compte {0} : fonds insuffisants pour {1}"
        },
        "codeExplanations": {
          "english": "LocalizedException message key aur parameters store karta hai hardcoded string ke bajaye. getLocalizedMessage method requested Locale specific ResourceBundle mein key lookup karta hai, phir stored parameters ke saath message format karta hai. Ye allow karta hai exceptions deep business logic mein throw honge jabki UI layer unhe user ki language mein localize karega."
        },
        "keyPoints": [
          "Message keys aur parameters store karo, hardcoded text nahi",
          "ResourceBundle use karo locale-specific message templates ke liye",
          "Presentation layer localization perform karta hai, exception throwing code nahi",
          "Multiple languages support karta hai bina exception throwing code change kiye"
        ],
        "extras": {
          "flowDiagram": "Exception Thrown (key: \"error.funds\", params: [123, 500])\n    ↓\nGlobal Handler catches\n    ↓\nLookup in ResourceBundle (locale: fr_FR)\n    ↓\nFormat: \"Compte 123 : fonds insuffisants pour 500\"\n    ↓\nReturn localized response",
          "comparisonTable": "Approach|Pros|Cons\nHardcoded English|Simple|Not localizable\nLocalized in exception|Tight coupling|Poor separation\nKey + ResourceBundle|Clean separation|Requires lookup step",
          "examples": []
        }
      },
      {
        "id": "s4-6-1",
        "title": "AutoCloseable Interface",
        "explanations": {
          "english": "AutoCloseable interface resources ko enable karta hai automatically close hone ke liye jab try-with-resources block exit hota hai, eliminating verbose aur error-prone finally block boilerplate resource management ke liye. Classes close() method implement karte hain resources release karne ke liye (files, connections, locks) aur declare karte hain koi bhi checked exceptions (typically IOException ya generic Exception) jo cleanup ke dauran throw ho sakti hain. Closeable AutoCloseable ko specifically extend karta hai IO resources ke liye, restrictions laga ke exceptions ko IOException tak. Resources try statement mein declare kiye jate hain, immediately initialize hote hain, aur reverse order mein close hote hain (LIFO) jab block exit hota hai. Ye pattern ensure karta hai resources close honge chahe exceptions occur kare, resource leaks ko minimal code se prevent karke."
        },
        "code": {
          "title": "Implementing AutoCloseable",
          "language": "java",
          "content": "public class DatabaseConnection implements AutoCloseable {\n    private boolean closed = false;\n    \n    public void query(String sql) {\n        if (closed) throw new IllegalStateException(\"Connection closed\");\n        // Execute query\n    }\n    \n    @Override\n    public void close() throws SQLException {\n        if (!closed) {\n            System.out.println(\"Closing connection\");\n            closed = true;\n            // Actual cleanup\n        }\n    }\n}\n\n// Usage with try-with-resources\ntry (DatabaseConnection conn = new DatabaseConnection()) {\n    conn.query(\"SELECT * FROM users\");\n} // close() called automatically here"
        },
        "codeExplanations": {
          "english": "DatabaseConnection AutoCloseable implement karta hai close() method ke saath jo cleanup perform karta hai aur state track karta hai double-close prevent karne ke liye. Try-with-resources block automatically close() call karta hai exit karte waqt, chahe query() exception throw kare. Ye manual finally blocks ki need eliminate karta hai jabki guarantee karta hai resources release honge."
        },
        "keyPoints": [
          "Cleanup logic ke liye close() method implement karo",
          "Throws Exception (ya specific) declare karo taaki checked exceptions during close allow ho sakein",
          "Closeable subinterface IO resources ke liye (throws IOException only)",
          "Resources reverse order of opening mein automatically close hote hain"
        ],
        "extras": {
          "flowDiagram": "try (Resource1; Resource2) {\n    // Use resources\n} \nExit → Close Resource2 → Close Resource1 (reverse order)",
          "comparisonTable": "",
          "examples": [
            "DatabaseConnection",
            "FileLock",
            "ManagedContext"
          ]
        }
      },
      {
        "id": "s4-6-2",
        "title": "Resource Management",
        "explanations": {
          "english": "Try-with-resources, Java 7 mein introduce hua, resource lifecycles manage karta hai automatically try statement mein declare kiye gaye resources ko close karke jab block exit hota hai. Multiple resources semicolons se separate karke declare kiye ja sakte hain, aur ye reverse order mein close hote hain opening ke. Resources ko AutoCloseable implement karna chahiye. Variables effectively final hain try block ke andar (reassign nahi kiya ja sakta). Ye construct eliminate karta hai manual try-catch-finally blocks ka boilerplate aur error-prone nature, particularly ensure karta hai resources close honge chahe initialization ya use ke dauran exceptions occur karein. Agar try block aur close() dono throw karte hain, close exception try block exception ke suppressed ke roop mein add ho jata hai, saari error information preserve karke."
        },
        "code": {
          "title": "Try-with-resources Patterns",
          "language": "java",
          "content": "// Single resource\ntry (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) {\n    return br.readLine();\n}\n\n// Multiple resources (closed in reverse order: writer before reader)\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"in.txt\"));\n     BufferedWriter writer = new BufferedWriter(new FileWriter(\"out.txt\"))) {\n    writer.write(reader.readLine());\n}\n\n// With catch and finally (optional)\ntry (Connection conn = dataSource.getConnection();\n     PreparedStatement ps = conn.prepareStatement(sql)) {\n    ps.executeUpdate();\n} catch (SQLException e) {\n    logger.error(\"Update failed\", e);\n}"
        },
        "codeExplanations": {
          "english": "Pehla example basic pattern dikhata hai: resource try parentheses mein declare kiya gaya hai auto-close hoga. Doosra multiple resources dikhata hai semicolons se separate; writer reader se pehle close hota hai (reverse order). Teesra dikhata hai ki catch aur finally blocks ab bhi try-with-resources ke saath use kiye ja sakte hain error handling aur additional cleanup ke liye jo AutoCloseable se cover nahi hota."
        },
        "keyPoints": [
          "Resource try parentheses mein declare kiya jata hai: try (Resource r = ...)",
          "Resource automatically close hota hai jab block exit hota hai (success ya exception)",
          "Multiple resources semicolons se separate, reverse order mein close hote hain",
          "Variables effectively final hain; try block mein reassign nahi kiya ja sakta"
        ],
        "extras": {
          "flowDiagram": "try (Resource r = new Resource()) {\n    r.use()\n} catch (Exception e) {\n    // Exception handling\n}\n\nExecution flow:\nCreate Resource → Try Block → If OK: Close Resource\n                    ↓ Exception\n              Catch Block → Close Resource (before catch executes)",
          "comparisonTable": "Approach|Lines|Error Handling|Resource Guarantee\nManual try-finally|15+|Complex|Risk of leak\nTry-with-resources|5|Clean|Guaranteed close",
          "examples": []
        }
      },
      {
        "id": "s4-6-3",
        "title": "Best Practices",
        "explanations": {
          "english": "Exception handling ke best practices mein include hai try-with-resources use karna saare AutoCloseable resources ke liye reliable cleanup ke liye bina boilerplate ke. Specific exceptions ko general ones se pehle catch karna chahiye unreachable code avoid karne ke liye. Exceptions ko control flow ke liye use nahi karna chahiye; conditional statements use karo instead. Hamesha original exception preserve karo wrapping (chaining) karte waqt debugging information maintain karne ke liye. Empty catch blocks avoid karo jo errors swallow kar dete hain; minimum logging karo. Checked exceptions ke liye consider karo ki kya caller realistically recover kar sakta hai; agar nahi, to unchecked exceptions use karo. Document karo exceptions @throws ke saath Javadoc mein. Validation exceptions prevent kare waar possible (guard clauses). Finally blocks ko exceptions throw nahi karna chahiye primary errors mask karne se bachne ke liye."
        },
        "code": {
          "title": "Exception Best Practices",
          "language": "java",
          "content": "// DO: Use try-with-resources\ntry (InputStream is = new FileInputStream(file)) {\n    process(is);\n}\n\n// DON'T: Empty catch\n} catch (IOException e) {\n    // Silent failure!\n}\n\n// DO: At least log\n} catch (IOException e) {\n    logger.error(\"Failed to process file\", e);\n    throw new ProcessingException(e);\n}\n\n// DON'T: Use exceptions for control flow\ntry {\n    return stack.pop();\n} catch (EmptyStackException e) {\n    return null; // Bad!\n}\n\n// DO: Check condition\nif (stack.isEmpty()) return null;\nreturn stack.pop();"
        },
        "codeExplanations": {
          "english": "Pehla pair proper resource handling dikhata hai try-with-resources ke saath versus empty catch jo failures chhupata hai. Doosra pair anti-pattern demonstrate karta hai: EmptyStackException flow control ke liye use karna versus proper isEmpty() checking. Exceptions exceptional hone chahiye, expected control paths nahi."
        },
        "keyPoints": [
          "Hamesha try-with-resources use karo AutoCloseable resources ke liye",
          "Specific exceptions ko general se pehle catch karo; exceptions swallow mat karo",
          "Exceptions ko control flow ke liye use mat karo; instead validate karo",
          "Causes preserve karo wrapping karte waqt; @throws se document karo"
        ],
        "extras": {
          "flowDiagram": "Check Preconditions → Throw IllegalArgumentException if invalid\n    ↓ Valid\nTry Operation → Catch Specific Exceptions → Log and Wrap if needed\n    ↓ Success\nReturn Result",
          "comparisonTable": "Bad Practice|Good Practice\nEmpty catch|Log and rethrow\nCatch Exception|Catch specific types\nUse for flow control|Use conditionals\nThrow generic Exception|Throw specific business exception\nLose stack trace|Chain with cause|examples"
        }
      }
    ]
  },
  {
    "id": "section-5",
    "title": "Multithreading & Java I/O",
    "topics": [
      {
        "id": "s5-1-1",
        "title": "Thread Creation Approaches",
        "explanations": {
          "english": "Java mein threads banane ke do primary tarike hain: Thread class extend karna ya Runnable interface implement karna. Thread extend karne ke liye run() method override karna padta hai, lekin isse flexibility kam ho jaati hai kyunki Java multiple inheritance support nahi karta. Runnable implement karna zyada prefer kiya jaata hai kyunki isse class doosri classes extend kar sakti hai aur saath hi Thread ke liye executable bhi rehti hai. Teesra tarika anonymous classes ya lambdas (Java 8+) use karna hai jo Runnable ka concise inline implementation provide karta hai. Thread class khud Runnable implement karti hai, aur jab woh Runnable target ke saath construct hoti hai, toh woh target ka run() method execute karti hai apne khud ke method ki jagah. Ye approaches samajhna concurrent programming ke liye bahut zaroori hai."
        },
        "code": {
          "title": "Thread Creation Patterns",
          "language": "java",
          "content": "// Approach 1: Extend Thread class\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Running in extended thread: \" + getName());\n    }\n}\n\n// Approach 2: Implement Runnable (preferred)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Running in runnable: \" + Thread.currentThread().getName());\n    }\n}\n\n// Usage\nThread t1 = new MyThread();\nThread t2 = new Thread(new MyRunnable());\n\n// Approach 3: Lambda expression (Java 8+)\nThread t3 = new Thread(() -> {\n    System.out.println(\"Running in lambda thread\");\n});\n\n// Approach 4: Anonymous class\nThread t4 = new Thread(new Runnable() {\n    public void run() {\n        System.out.println(\"Anonymous runnable\");\n    }\n});\n\nt1.start();\nt2.start();"
        },
        "codeExplanations": {
          "english": "Ye examples mein thread logic define karne ke char tarike dikhaye gaye hain. MyThread directly Thread extend karti hai lekin doosri classes extend nahi kar sakti. MyRunnable interface implement karta hai, jisse zaroorat padne par woh doosri classes extend kar sakta hai. Lambda approach simple thread bodies ke liye sabse concise syntax provide karta hai. Anonymous classes verbosity aur flexibility ke beech ka raasta hai. Saare approaches Thread objects banate hain jinhe concurrent execution start karne ke liye start() call karna padta hai (run() nahi)."
        },
        "keyPoints": [
          "Extend Thread: Simple but limits inheritance; override run()",
          "Implement Runnable: Flexible, preferred approach; allows class to extend other classes",
          "Lambda expressions provide concise syntax for Runnable implementations",
          "Call start() to begin execution; calling run() executes synchronously"
        ],
        "extras": {
          "flowDiagram": "main() → new Thread() → thread.start() → Thread Scheduler → run() executes in new thread",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s5-1-2",
        "title": "Extending Thread vs Implementing Runnable",
        "explanations": {
          "english": "Thread extend karna ya Runnable implement karna iska decision architectural requirements pe depend karta hai. Thread extend karne se task logic thread management ke saath coupled ho jaata hai, jo separation of concerns principle violate karta hai. Kyunki Java mein sirf single inheritance allowed hai, Thread extend karne se class koi aur class extend nahi kar sakti. Runnable implement karne se task execution mechanism se alag ho jaata hai, jisse same Runnable ko different thread pools ya executors mein submit kiya ja sakta hai. Ye composition over inheritance enable karta hai, jisme class Runnable implement karne ke saath-saath koi domain-specific superclass bhi extend kar sakti hai. Runnable ek task represent karta hai jo execute ho sakta hai; Thread execution mechanism represent karta hai. Modern concurrent programming mein direct Thread management ke bajaye Runnable/Callable with ExecutorServices ko prefer kiya jaata hai."
        },
        "code": {
          "title": "Architectural Comparison",
          "language": "java",
          "content": "// Problem with extending Thread: Cannot extend other classes\nclass ReportGenerator extends Thread { // Stuck here\n    public void run() { /* ... */ }\n}\n\n// Solution with Runnable: Can extend business class\nclass ReportTask extends BusinessTask implements Runnable {\n    private final String reportId;\n    \n    public ReportTask(String id) {\n        this.reportId = id;\n    }\n    \n    @Override\n    public void run() {\n        generateReport(reportId);\n    }\n    \n    private void generateReport(String id) {\n        // Business logic\n    }\n}\n\n// Reusability with Executors\nExecutorService executor = Executors.newFixedThreadPool(4);\nexecutor.submit(new ReportTask(\"RPT-001\"));\nexecutor.submit(new ReportTask(\"RPT-002\"));"
        },
        "codeExplanations": {
          "english": "ReportGenerator Thread extend kar raha hai toh woh BusinessTask bhi extend nahi kar sakta. ReportTask Runnable implement karta hai aur saath mein BusinessTask bhi extend karta hai, jo composition demonstrate karta hai. Same Runnable implementation ko multiple times thread pool mein submit kiya ja sakta hai, jo dikhata hai ki Runnable task definition ko execution management se alag karta hai, jisse different execution contexts mein reuse ho sakta hai."
        },
        "keyPoints": [
          "Runnable allows inheritance from other classes; Thread does not",
          "Runnable separates task logic from thread management",
          "Same Runnable instance can be reused across multiple threads",
          "Executor framework works with Runnable, not Thread subclasses"
        ],
        "extras": {
          "flowDiagram": "Runnable (Task Logic) → Thread/Executor (Execution Mechanism)",
          "comparisonTable": "Aspect|Extend Thread|Implement Runnable\nInheritance|Blocked|Available\nSeparation|Task + Thread coupled|Task separate from execution\nReuse|One Thread per task|Submit to multiple executors\nTesting|Requires thread|Can test run() directly",
          "examples": []
        }
      },
      {
        "id": "s5-1-3",
        "title": "Daemon Threads",
        "explanations": {
          "english": "Daemon threads background threads hain jo user threads ko supporting services provide karte hain aur JVM ko exit hone se nahi rokte jab saare user threads finish ho jaate hain. Jab sirf daemon threads bachti hain, tab JVM immediately terminate ho jaata hai, chahe daemon thread ka state kuch bhi ho. Daemon threads typically housekeeping tasks ke liye use hoti hain: garbage collection (GC bhi ek daemon thread hai), memory monitoring, logging, ya status monitoring. Daemon thread banane ke liye setDaemon(true) call karna padta hai thread start karne se pehle; agar start ke baat set karne ki koshish karte hain toh IllegalThreadStateException throw hota hai. Daemon threads ko I/O operations ya critical resources hold nahi karna chahiye, kyunki ye abruptly terminate ho sakti hain jab JVM exit ho. Ye user threads ke same priority pe run karti hain lekin completion ki guarantee nahi hoti."
        },
        "code": {
          "title": "Daemon Thread Usage",
          "language": "java",
          "content": "public class DaemonExample {\n    public static void main(String[] args) {\n        Thread daemon = new Thread(() -> {\n            while (true) {\n                System.out.println(\"Daemon monitoring...\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        // Must set before start\n        daemon.setDaemon(true);\n        daemon.start();\n        \n        // Main thread (user thread) ends immediately\n        System.out.println(\"Main thread ending\");\n        // JVM exits here even though daemon is still running\n    }\n}\n\n// Common pattern: Monitoring thread\nThread monitor = new Thread(() -> {\n    while (!Thread.currentThread().isInterrupted()) {\n        logMemoryUsage();\n        sleep(5000);\n    }\n});\nmonitor.setDaemon(true);\nmonitor.start();"
        },
        "codeExplanations": {
          "english": "Daemon thread infinite loop mein messages print karti rehti hai. Ek baar main thread (ek user thread) complete ho jaata hai, tab JVM terminate ho jaata hai chahe daemon thread abhi bhi chal rahi ho aur indefinitely continue kar sakti thi. Ye demonstrate karta hai ki daemon threads JVM shutdown ko block nahi karti. Monitoring pattern common usage dikhata hai background tasks ke liye jo application exit ko rokna nahi chahiye."
        },
        "keyPoints": [
          "Daemon threads do not prevent JVM exit when user threads complete",
          "Set setDaemon(true) before calling start()",
          "Used for background tasks: monitoring, logging, scheduling",
          "JVM terminates abruptly when only daemons remain; do not use for critical cleanup"
        ],
        "extras": {
          "flowDiagram": "User Thread 1 (Main) ────┐\nUser Thread 2 ───────────┼── All user threads finish → JVM exits immediately\nDaemon Thread 1 (GC) ────┤    (killing daemon threads)\nDaemon Thread 2 (Log) ───┘",
          "comparisonTable": "Property|User Thread|Daemon Thread\nJVM Exit|Blocks|Does not block\nTypical Use|Core application work|Background services\nPriority|Same|Same (by default)\nCleanup|Graceful|May be abrupt",
          "examples": [
            "Garbage Collector",
            "Finalizer thread",
            "Monitoring threads"
          ]
        }
      },
      {
        "id": "s5-2-1",
        "title": "Thread Lifecycle States",
        "explanations": {
          "english": "Java Thread lifecycle mein chah states hain jo Thread.State enum mein defined hain: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, aur TERMINATED. Thread creation ke baad NEW state mein shuru hota hai lekin start() call karne se pehle. start() call karne se RUNNABLE mein chala jaata hai, jahan woh execute kar raha ho sakta hai ya CPU time ke liye scheduler ka wait kar raha ho. BLOCKED tab hota hai jab thread kisi monitor lock ko acquire karne ki koshish karta hai jo currently doosre thread ne hold kiya hai (synchronized blocks). WAITING tab hota hai jab thread indefinitely wait karta hai doosre thread ke koi action perform karne ka (Object.wait(), Thread.join() bina timeout ke). TIMED_WAITING similar hai lekin timeout ke saath (sleep, wait with timeout, join with timeout). TERMINATED matlab thread ne execution complete kar liya ya abnormally exit ho gaya."
        },
        "code": {
          "title": "State Transitions",
          "language": "java",
          "content": "Thread t = new Thread(() -> {\n    try {\n        Thread.sleep(1000); // TIMED_WAITING\n        synchronized (lock) {\n            // BLOCKED if lock held, then RUNNABLE\n            lock.wait(); // WAITING\n        }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    }\n});\n\nSystem.out.println(t.getState()); // NEW\nt.start();\nSystem.out.println(t.getState()); // RUNNABLE (or TIMED_WAITING immediately)\n\n// Check blocked state\nThread blocker = new Thread(() -> {\n    synchronized (lock) {\n        sleep(5000); // Hold lock for 5 seconds\n    }\n});\nblocker.start();\nt.join(100); // Give t time to try to acquire lock\nSystem.out.println(t.getState()); // Likely BLOCKED"
        },
        "codeExplanations": {
          "english": "Code state transitions demonstrate karta hai: NEW start() se pehle, RUNNABLE jab execute ho raha ho, TIMED_WAITING sleep() ke dauraan, BLOCKED jab synchronized block mein enter karne ka wait ho raha ho jo doosre thread ne hold kiya hai, aur WAITING jab object.wait() call ho. getState() method current state inspect karta hai debugging ke liye. Ye states samajhna thread contention aur deadlocks diagnose karne ke liye bahut zaroori hai."
        },
        "keyPoints": [
          "NEW: Created, not yet started",
          "RUNNABLE: Executing or ready to execute (waiting for CPU)",
          "BLOCKED: Waiting to acquire monitor lock",
          "WAITING: Waiting indefinitely for notification or other thread",
          "TIMED_WAITING: Waiting with specified timeout",
          "TERMINATED: Execution completed"
        ],
        "extras": {
          "flowDiagram": "NEW → start() → RUNNABLE ←→ BLOCKED (waiting for lock)\n                ↓\n          TIMED_WAITING (sleep, timed wait)\n                ↓\n            TERMINATED (run completes)",
          "comparisonTable": "State|Trigger|Exit Condition\nNEW|Thread created|start() called\nRUNNABLE|start() called|Waiting for lock, I/O, or termination\nBLOCKED|Enter synchronized|Lock acquired\nWAITING|wait(), join()|notify(), interrupt(), target completes\nTIMED_WAITING|sleep(t), wait(t)|Time expires or notification\nTERMINATED|Run completes|N/A",
          "examples": []
        }
      },
      {
        "id": "s5-3-1",
        "title": "Synchronized Keyword",
        "explanations": {
          "english": "Synchronized keyword Java ka built-in intrinsic locking mechanism provide karta hai shared mutable state ko thread-safe way mein access karne ke liye. Isse methods (instance ya static) pe ya phir kisi specific object pe block ke roop mein apply kar sakte hain. Instance methods ke liye ye object instance (this) pe lock karta hai; static methods ke liye Class object pe lock karta hai. Synchronized blocks arbitrary objects pe finer-grained locking allow karte hain, jo poori methods ke comparison mein lock scope kam karta hai. Ek time pe sirf ek thread hi given monitor lock se protected code execute kar sakta hai, jo mutual exclusion ensure karta hai. Synchronized visibility bhi guarantee karta hai: ek thread ke dwara lock release karne se pehle kiye gaye changes doosre thread ko visible hote hain jo woh lock acquire karta hai, jisse happens-before relationships establish hote hain."
        },
        "code": {
          "title": "Synchronization Patterns",
          "language": "java",
          "content": "public class Counter {\n    private int count = 0;\n    private final Object lock = new Object();\n    \n    // Synchronized instance method (locks on 'this')\n    public synchronized void increment() {\n        count++;\n    }\n    \n    // Equivalent synchronized block\n    public void incrementBlock() {\n        synchronized (this) {\n            count++;\n        }\n    }\n    \n    // Different lock object for finer control\n    public void add(int value) {\n        synchronized (lock) {\n            count += value;\n        }\n    }\n    \n    // Static synchronized (locks on Counter.class)\n    public static synchronized void staticMethod() {\n        // Class-level lock\n    }\n}"
        },
        "codeExplanations": {
          "english": "Counter class teen synchronization approaches demonstrate karti hai: synchronized method instance ko lock karta hai, synchronized block explicitly this ya doosre object ko lock karta hai, aur private final lock object use karne se kuch methods ko locking se exclude kar sakte hain jabki doosron ko protect kar sakte hain. Static synchronized method Class object ko lock karta hai, jo instance locks se alag hota hai."
        },
        "keyPoints": [
          "Instance methods lock on 'this'; static methods lock on Class object",
          "Synchronized blocks allow locking on any object with finer granularity",
          "Only one thread can hold the lock at a time; others block",
          "Guarantees both mutual exclusion and visibility of changes"
        ],
        "extras": {
          "flowDiagram": "Thread A → acquire lock → execute synchronized code → release lock\nThread B → request lock (blocked) → acquire after A → execute",
          "comparisonTable": "Approach|Scope|Flexibility\nsynchronized method|Entire method|Simple, coarse\nsynchronized(this)|Same as method|Explicit\nsynchronized(obj)|Specific block|Fine-grained, flexible",
          "examples": []
        }
      },
      {
        "id": "s5-3-2",
        "title": "Intrinsic Locks",
        "explanations": {
          "english": "Intrinsic locks (monitor locks ya mutexes) har Java object mein built-in hote hain, jo synchronized blocks aur methods ka foundation provide karte hain. Har object ke saath ek associated monitor hota hai jise threads acquire aur release kar sakte hain; lock acquire hota hai jab synchronized block mein enter karte hain aur automatically release hota hai jab exit karte hain (exceptions ke through bhi). Intrinsic locks reentrant hote hain: thread jo lock hold kar raha hai woh dubara acquire kar sakta hai bina block kiye, har acquisition ke liye matching release zaroori hai. Ye exclusive hote hain (mutual exclusion) - ek time pe sirf ek thread hi lock hold kar sakta hai. Convenient hone ke bawajood, intrinsic locks ki limitations hain: inhe interrupt nahi kiya ja sakta, timeout nahi hota, aur ek lock pe multiple wait/notify condition variables support nahi karte, jo limitations java.util.concurrent.locks package address karta hai."
        },
        "code": {
          "title": "Monitor Lock Behavior",
          "language": "java",
          "content": "public class IntrinsicLockDemo {\n    public synchronized void methodA() {\n        System.out.println(\"In method A\");\n        methodB(); // Reentrant: same thread can acquire again\n    }\n    \n    public synchronized void methodB() {\n        System.out.println(\"In method B\");\n        // Lock held count: 2 (A + B)\n    }\n    // Exit B: count 1, Exit A: count 0, lock released\n    \n    // Every object has intrinsic lock\n    private final Object monitor = new Object();\n    \n    public void manualLocking() {\n        synchronized (monitor) {\n            // Lock acquired\n            try {\n                doWork();\n            } finally {\n                // Lock released automatically even if exception\n            }\n        }\n    }\n}"
        },
        "codeExplanations": {
          "english": "methodA ka methodB call karna reentrancy demonstrate karta hai: same thread synchronized methodB mein enter kar sakta hai jab woh already synchronized methodA se lock hold kar raha ho. JVM hold count maintain karta hai, lock tabhi release karta hai jab outermost synchronized block exit ho. manualLocking example dikhata hai ki private objects ke paas bhi intrinsic locks hote hain jo synchronization ke liye use ho sakte hain."
        },
        "keyPoints": [
          "Every Java object has an intrinsic lock (monitor)",
          "Lock acquired on synchronized entry, released on exit (including exceptions)",
          "Reentrant: same thread can acquire lock multiple times",
          "Exclusive: only one thread holds lock at a time"
        ],
        "extras": {
          "flowDiagram": "Object Monitor:\n[Unlocked] ←── Thread A acquires ──→ [Locked by A]\n   ↑                                     │\n   └────── Thread B blocks ──────────────┘\n        (enters wait set)",
          "comparisonTable": "Feature|Intrinsic Lock|ReentrantLock\nAcquisition|synchronized keyword|lock() method\nRelease|Automatic|Manual (finally)\nInterruptible|No|Yes (lockInterruptibly)\nTimeout|No|Yes (tryLock(timeout))\nCondition Variables|One per object|Multiple",
          "examples": []
        }
      },
      {
        "id": "s5-3-3",
        "title": "Reentrancy",
        "explanations": {
          "english": "Reentrancy lock ka property hai jo thread ko same lock multiple times acquire karne deta hai bina deadlock ke. Agar thread lock hold kar raha hai aur dubara acquire karne ki koshish karta hai (recursive method calls ke through ya doosre synchronized methods call karke), toh request succeed hoti hai aur lock hold count increment ho jaata hai. Thread ko lock utni hi baar release karna padta hai jitni baar acquire kiya tha tab tak lock doosre threads ke liye available nahi hota. Reentrancy ke bina, synchronized methods jo same object pe doosre synchronized methods call karte hain immediately deadlock ho jaayenge. Reentrancy implement hota hai har lock ke saath owner thread aur hold count associate karke; acquisition pe identity check hoti hai, same thread ho toh sirf count increment hota hai, different thread ho toh block hota hai."
        },
        "code": {
          "title": "Reentrant Locking",
          "language": "java",
          "content": "public class ReentrantExample {\n    public synchronized void outer() {\n        System.out.println(\"Outer acquired lock\");\n        inner(); // Would deadlock if not reentrant\n        System.out.println(\"Outer releasing\");\n    }\n    \n    public synchronized void inner() {\n        System.out.println(\"Inner acquired lock (again)\");\n        deepest();\n    }\n    \n    public synchronized void deepest() {\n        System.out.println(\"Deepest level - hold count: 3\");\n    }\n    // Lock released 3 times as stack unwinds\n    \n    public static void main(String[] args) {\n        new ReentrantExample().outer();\n    }\n}"
        },
        "codeExplanations": {
          "english": "outer(), inner(), aur deepest() saare synchronized hain. Jab outer() inner() call karta hai, toh thread already lock hold kar raha hai; kyunki Java locks reentrant hain, inner() succeed karta hai aur hold count 2 ho jaata hai. deepest() se 3 ho jaata hai. Jab methods return karte hain, count decrement hota hai. Finally 0 pe, lock release ho jaata hai. Reentrancy ke bina, inner() call hamesha ke liye block ho jaata lock ka wait karte hue jo already outer() ne hold kiya hua hai."
        },
        "keyPoints": [
          "Thread can acquire same lock multiple times without blocking",
          "Hold count tracks acquisition depth",
          "Lock fully released only when hold count reaches zero",
          "Essential for synchronized methods calling other synchronized methods"
        ],
        "extras": {
          "flowDiagram": "Thread A acquires lock (count: 1)\n    ↓\nEnter synchronized method (count: 2)\n    ↓\nEnter synchronized block (count: 3)\n    ↓\nExit block (count: 2)\n    ↓\nExit method (count: 1)\n    ↓\nExit outer (count: 0) → Lock released",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s5-3-4",
        "title": "Happens-before Relationship",
        "explanations": {
          "english": "Happens-before relationship Java Memory Model ka fundamental guarantee hai jo define karta hai ki ek thread ke memory writes doosre thread ko kab guaranteed visible honge. Single thread ke andar actions program order mein hote hain. Threads ke beech mein, synchronization happens-before establish karta hai: monitor unlock karna (synchronized exit) happens-before hai kisi bhi subsequent lock se same monitor ka (synchronized enter) doosre thread dwara. Isi tarah, volatile writes happens-before hote hain subsequent volatile reads se same variable ke. Ye ensure karta hai ki lock release karne se pehle ya volatile variable write karne se pehle jo memory writes hue hain woh visible honge threads ko jo woh lock acquire karte hain ya variable read karte hain. Happens-before guarantees ke bina, threads stale cached values dekh sakte hain compiler optimizations aur CPU caching ki wajah se."
        },
        "code": {
          "title": "Happens-before Guarantees",
          "language": "java",
          "content": "// Visibility through synchronization\nclass SynchronizedVisibility {\n    private int sharedValue = 0;\n    \n    public synchronized void writer() {\n        sharedValue = 42; // Write happens-before unlock\n    }\n    \n    public synchronized int reader() {\n        // Lock acquire happens-after previous unlock\n        return sharedValue; // Guaranteed to see 42 if writer completed\n    }\n}\n\n// Visibility through volatile\nclass VolatileVisibility {\n    private volatile int flag = 0;\n    private int data = 0;\n    \n    public void writer() {\n        data = 42;          // (1)\n        flag = 1;           // (2) volatile write happens-before\n    }\n    \n    public void reader() {\n        if (flag == 1) {    // (3) volatile read happens-after (2)\n            // Guaranteed to see data == 42 (1 happens-before 2, 2 happens-before 3)\n            System.out.println(data);\n        }\n    }\n}"
        },
        "codeExplanations": {
          "english": "Pehla example dikhata hai ki synchronized writer() mein writes reader() ko visible hain kyunki writer mein unlocking happens-before hai reader mein locking se. Volatile example demonstrate karta hai ki data ko write karna (1) happens-before hai flag ke volatile write (2) se, aur flag ka volatile read (3) happens-after hai (2) se, toh reader guaranteed hai ki updated data value dekhega."
        },
        "keyPoints": [
          "Defines visibility guarantees across threads in Java Memory Model",
          "Synchronized unlock happens-before subsequent lock on same monitor",
          "Volatile write happens-before subsequent volatile read",
          "Without happens-before, threads may see stale cached values"
        ],
        "extras": {
          "flowDiagram": "Thread A:\nWrite to x → Release Lock → Volatile Write\n                ↓ happens-before\nThread B:\n           Acquire Lock → Volatile Read → Read x (sees write from A)",
          "comparisonTable": "Mechanism|Happens-before Rule\nsynchronized|Unlock → subsequent Lock\nvolatile|Write → subsequent Read\nThread.start()|start() → run() begin\nThread.join()|Thread termination → join() return",
          "examples": []
        }
      },
      {
        "id": "s5-4-1",
        "title": "ReentrantLock",
        "explanations": {
          "english": "ReentrantLock ek explicit lock hai jo intrinsic synchronized locks se zyada flexible locking mechanisms provide karta hai. Ye lockInterruptibly() offer karta hai responsive cancellation ke liye, tryLock() timeout ke saath indefinite blocking avoid karne ke liye, aur fairness policies (fair vs non-fair) sabse zyada wait kar rahe threads ko favor karne ke liye. Synchronized blocks ke unlike, ReentrantLock explicit unlock() calls require karta hai finally blocks mein release ensure karne ke liye. Ye multiple Condition objects bhi support karta hai per lock sophisticated wait/notify patterns ke liye. ReentrantLock same reentrancy semantics provide karta hai intrinsic locks jaise (same thread multiple times acquire kar sakta hai) lekin zyada control aur visibility ke saath lock state mein (isLocked(), getHoldCount(), isHeldByCurrentThread())."
        },
        "code": {
          "title": "ReentrantLock Usage",
          "language": "java",
          "content": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    private int count = 0;\n    \n    public void safeIncrement() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Must unlock in finally\n        }\n    }\n    \n    public boolean tryIncrement(long timeout) throws InterruptedException {\n        if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {\n            try {\n                count++;\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false; // Could not acquire lock in time\n    }\n    \n    public void interruptibleOperation() throws InterruptedException {\n        lock.lockInterruptibly();\n        try {\n            // Can be interrupted while waiting for lock\n            doWork();\n        } finally {\n            lock.unlock();\n        }\n    }\n}"
        },
        "codeExplanations": {
          "english": "Lock lock() se acquire hota hai aur absolutely finally block mein release karna padta hai taaki deadlocks prevent ho sakein agar exceptions aayein. tryLock() timeout ke saath method ko allow karta hai give up karne ke liye agar lock time limit mein available nahi hota, indefinite blocking prevent karta hai. lockInterruptibly() thread ko allow karta hai interruption ko respond karne ke liye jab woh lock acquire karne ka wait kar raha ho, intrinsic locks ke unlike jo acquisition ke dauraan interruption ignore karte hain."
        },
        "keyPoints": [
          "Explicit lock/unlock calls required (unlock in finally)",
          "tryLock() supports timeouts; lockInterruptibly() supports cancellation",
          "Fairness policy available (fair queue vs barging allowed)",
          "Multiple Condition objects per lock for complex wait/notify"
        ],
        "extras": {
          "flowDiagram": "lock.lockInterruptibly()\n    ↓\n[Waiting for lock] ←── InterruptedException\n    ↓\n[Lock Acquired]\n    ↓\ntry { work } finally { lock.unlock() }",
          "comparisonTable": "Feature|synchronized|ReentrantLock\nSyntax|Keyword|Explicit API\nInterruptible|No|Yes (lockInterruptibly)\nTimeout|No|Yes (tryLock)\nFairness|No|Configurable\nCondition Variables|One|Multiple\nPerformance|Similar|Similar (modern JVM)",
          "examples": []
        }
      },
      {
        "id": "s5-4-2",
        "title": "Thread Pools",
        "explanations": {
          "english": "Thread pools reusable worker threads ka collection manage karte hain jo submitted tasks execute karte hain, thread creation aur destruction ka overhead eliminate karte hain short-lived tasks ke liye. java.util.concurrent package mein Executors mein factory methods hain common pool types ke liye: fixed thread pools (fixed size, unbounded queue), cached thread pools (dynamic sizing, no queue), single thread executors (sequential execution), aur scheduled pools (timed/delayed execution). Proper sizing crucial hai: pools agar bahut chote hain toh bottleneck create karte hain, bahut bade hain toh resources waste karte hain. Thread pools ko gracefully shutdown karna chahiye shutdown() se (completion ka wait karta hai) ya shutdownNow() se (immediate cancellation try karta hai) taaki running tasks complete ho sakein aur new submissions reject ho sakein."
        },
        "code": {
          "title": "Thread Pool Configuration",
          "language": "java",
          "content": "// Fixed size pool\nExecutorService fixed = Executors.newFixedThreadPool(4);\n\n// Cached pool (creates threads as needed, reuses idle ones)\nExecutorService cached = Executors.newCachedThreadPool();\n\n// Single threaded (sequential execution)\nExecutorService single = Executors.newSingleThreadExecutor();\n\n// Scheduled tasks\nScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);\nscheduled.schedule(() -> task(), 10, TimeUnit.SECONDS);\nscheduled.scheduleAtFixedRate(() -> recurring(), 0, 5, TimeUnit.SECONDS);\n\n// Proper shutdown\nfixed.shutdown(); // No new tasks, complete existing\nfixed.awaitTermination(60, TimeUnit.SECONDS);\nfixed.shutdownNow(); // Attempt to interrupt running"
        },
        "codeExplanations": {
          "english": "Different pool types different needs serve karte hain: fixed CPU-bound work ke liye controlled concurrency ke saath, cached bahut saare short-lived tasks ke liye, single guaranteed ordering ke liye bina synchronization ke. Scheduled pools timer-based tasks handle karte hain. Shutdown sequence graceful degradation ensure karta hai: pehle new work accept karna band, completion ka wait karna timeout ke saath, phir force shutdown agar zaroori ho."
        },
        "keyPoints": [
          "Reuse threads to avoid creation overhead",
          "Fixed: bounded concurrency; Cached: unbounded growth; Single: sequential",
          "Always shut down pools to prevent memory leaks",
          "Handle RejectedExecutionException when pool saturated"
        ],
        "extras": {
          "flowDiagram": "Task Submitted → Work Queue → Worker Thread (reusable)\n                ↓ Rejected (if saturated)\n         RejectedExecutionException",
          "comparisonTable": "Pool Type|Characteristics|Use Case\nnewFixedThreadPool(n)|Fixed threads, unbounded queue|CPU-intensive work\nnewCachedThreadPool|Elastic, 60s keep-alive|Many short async tasks\nnewSingleThreadExecutor|One thread, queue|Sequential processing\nnewScheduledThreadPool(n)|Delayed/periodic execution|Timers, recurring jobs",
          "examples": []
        }
      },
      {
        "id": "s5-4-3",
        "title": "Executor Framework",
        "explanations": {
          "english": "Executor framework task submission ko execution se decouple karta hai, standard interface provide karta hai tasks ko asynchronously run karne ke liye. Executor interface mein single method hai execute(Runnable), jabki ExecutorService isse extend karta hai submit() ke saath jo Futures return karta hai, batch execution (invokeAll/invokeAny), aur lifecycle management. Framework task creation (kya karna hai) ko execution policy (kab, kahan, kitne threads) se alag karta hai, flexible scheduling allow karta hai bina task code change kiye. ThreadPoolExecutor, standard implementation, core aur maximum pool sizes, keep-alive times, aur various work queues offer karta hai. Ye framework high-level concurrency utilities ka foundation hai aur recommend kiya jaata hai manual Thread creation ke bajaye sab non-trivial scenarios mein."
        },
        "code": {
          "title": "Executor Patterns",
          "language": "java",
          "content": "// Simple execution (fire and forget)\nExecutor executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -> System.out.println(\"Async task\"));\n\n// ExecutorService with results\nExecutorService service = Executors.newFixedThreadPool(4);\nFuture<Integer> future = service.submit(() -> calculate());\nInteger result = future.get(); // Blocks until result available\n\n// Batch processing\nList<Callable<String>> tasks = Arrays.asList(\n    () -> \"Task 1\",\n    () -> \"Task 2\"\n);\nList<Future<String>> results = service.invokeAll(tasks);\n\n// One successful result (fastest)\nString fastest = service.invokeAny(tasks);"
        },
        "codeExplanations": {
          "english": "execute() fire-and-forget hai koi result tracking ke bina. submit() Future return karta hai jo result retrieval ya cancellation allow karta hai. invokeAll() saare tasks execute karta hai aur return karta hai jab saare complete ho jaate hain; invokeAny() return karta hai jaise hi ek successfully complete ho jaata hai. Ye task logic ko concurrency management se decouple karta hai, same tasks ko different executor configurations pe run karne allow karta hai."
        },
        "keyPoints": [
          "Separates task submission from execution mechanism",
          "ExecutorService adds lifecycle management and result retrieval (Future)",
          "Submit Callables for results, Runnables for fire-and-forget",
          "Use executors instead of creating Thread objects directly"
        ],
        "extras": {
          "flowDiagram": "Client → submit(Task) → Executor\n                          ↓\n                    Work Queue → Worker Threads\n                          ↓\n                    Future ← Result",
          "comparisonTable": "Interface|Method|Returns\nExecutor|execute(Runnable)|void\nExecutorService|submit(Callable)|Future<T>\nExecutorService|invokeAll(List)|List<Future>\nExecutorService|invokeAny(List)|T (first success)",
          "examples": []
        }
      },
      {
        "id": "s5-4-4",
        "title": "Best Practices",
        "explanations": {
          "english": "Concurrent programming best practices emphasize karte hain high-level concurrency utilities use karna low-level synchronization ke bajaye. java.util.concurrent package utilities (ConcurrentHashMap, BlockingQueue, ExecutorService) prefer karo manual synchronization ke bajaye. Immutable objects use karo jahan possible ho synchronization needs eliminate karne ke liye. Hamesha shared mutable state ko synchronized blocks ya atomic variables se access karo; lengthy I/O ya computations ke dauraan locks hold karna avoid karo contention reduce karne ke liye. Document karo thread-safety guarantees (thread-safe, conditionally thread-safe, ya thread-hostile). Thread factories use karo meaningful names set karne ke liye debugging ke liye. Thread priorities pe kabhi bhi rely mat karo correctness ke liye. Lazy initialization mein cautious raho; static initializers ya double-checked locking with volatile use karo. Alien methods (methods jo tum control nahi karte) call karna avoid karo locks hold karte hue unknown locking order aur deadlocks prevent karne ke liye."
        },
        "code": {
          "title": "Concurrency Best Practices",
          "language": "java",
          "content": "// Good: Use concurrent collections\nConcurrentHashMap<String, Data> cache = new ConcurrentHashMap<>();\n\n// Bad: Synchronized collections (coarse locking)\nMap<String, Data> badCache = Collections.synchronizedMap(new HashMap<>());\n\n// Good: Immutable state (no synchronization needed)\npublic class Config {\n    private final Map<String, String> settings;\n    public Config(Map<String, String> s) {\n        this.settings = Map.copyOf(s); // Defensive copy\n    }\n}\n\n// Good: Don't call alien methods while locked\npublic void notifyListeners() {\n    List<Listener> snapshot;\n    synchronized (lock) {\n        snapshot = new ArrayList<>(listeners); // Copy while locked\n    }\n    for (Listener l : snapshot) {\n        l.update(); // Call outside lock\n    }\n}"
        },
        "codeExplanations": {
          "english": "ConcurrentHashMap synchronizedMap se better concurrency provide karta hai lock striping use karke. Immutable Config objects ko creation ke baad koi synchronization nahi chahiye hoti. Listener pattern demonstrate karta hai list copy karna synchronized block mein ConcurrentModificationException prevent karne ke liye, phir iterate karna lock ke bahar unknown code call karne se bachne ke liye (jo deadlocks ya lengthy delays cause kar sakta hai) lock hold karte hue."
        },
        "keyPoints": [
          "Use java.util.concurrent utilities over manual synchronization",
          "Prefer immutable objects to avoid synchronization entirely",
          "n",
          "Keep lock hold times short; avoid I/O while locked",
          "Document thread-safety; use proper thread naming"
        ],
        "extras": {
          "flowDiagram": "Locked Section:\n    Copy data (fast)\n    Release lock immediately\n    Process data outside lock (slow/safe)",
          "comparisonTable": "Good Practice|Bad Practice\nConcurrentHashMap|SynchronizedHashMap\nImmutable objects|Mutable shared state\nShort critical sections|Long synchronized blocks\nCopy-then-iterate|Iterate shared collection directly",
          "examples": []
        }
      },
      {
        "id": "s5-5-1",
        "title": "Callable",
        "explanations": {
          "english": "Callable ek functional interface hai Runnable ke similar lekin result return karne capable hai aur checked exceptions throw kar sakta hai. Runnable ke void run() method ke unlike, Callable<V> ke paas V call() method hai jo value return karta hai aur exceptions ko caller tak propagate karne allow karta hai. Ye tasks ke liye designed hai jo results compute karte hain ya fail ho sakte hain exceptions ke saath jo caller handle karna chahiye. Jab ExecutorService mein submit hota hai, Callable ek Future return karta hai jo pending result represent karta hai. Interface generics support karta hai, type-safe result retrieval allow karta hai. Callable essential hai asynchronous computation patterns ke liye jahan caller ko background processing ka result chahiye ya exceptional completion ko successful completion se distinctly handle karna hai."
        },
        "code": {
          "title": "Callable Implementation",
          "language": "java",
          "content": "// Callable that returns result or throws checked exception\nCallable<Integer> task = () -> {\n    Thread.sleep(1000);\n    if (System.currentTimeMillis() % 2 == 0) {\n        throw new IOException(\"Random failure\");\n    }\n    return 42;\n};\n\n// Submit to executor\nExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(task);\n\ntry {\n    Integer result = future.get(); // Blocks until done\n    System.out.println(\"Result: \" + result);\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n} catch (ExecutionException e) {\n    // Wraps the exception thrown by Callable\n    Throwable cause = e.getCause();\n    System.out.println(\"Task failed: \" + cause.getMessage());\n}"
        },
        "codeExplanations": {
          "english": "Lambda Callable<Integer> implement karta hai, Integer return karta hai ya IOException throw kar sakta hai. Jab ExecutorService mein submit hota hai, returned Future result retrieve karne allow karta hai get() se, jo block karta hai completion tak. ExecutionException wrap karta hai koi bhi exception jo call() execution ke dauraan throw hua hai; original exception retrieve karne ke liye getCause() use karo. Ye checked exceptions ko background threads se main thread tak propagate karne allow karta hai."
        },
        "keyPoints": [
          "Similar to Runnable but returns result and throws checked exceptions",
          "n",
          "V call() returns generic type V",
          "Submitted to ExecutorService to obtain Future",
          "Exceptions wrapped in ExecutionException when retrieved via Future.get()"
        ],
        "extras": {
          "flowDiagram": "Submit Callable → ExecutorService → Runs asynchronously\n    ↓ Returns Future\nFuture.get() → Blocks → Returns result OR throws ExecutionException",
          "comparisonTable": "Interface|Method|Return|Exceptions\nRunnable|run()|void|Unchecked only\nCallable|call()|V (generic)|Checked and unchecked",
          "examples": []
        }
      },
      {
        "id": "s5-5-2",
        "title": "Future",
        "explanations": {
          "english": "Future asynchronous computation ka result represent karta hai, methods provide karta hai check karne ke liye ki computation complete hai, uske completion ka wait karne ke liye, aur result retrieve karne ke liye. Future<V> return hota hai jab Callables ExecutorService mein submit hote hain. Iska get() method block karta hai task complete hone tak, result return karta hai ya ExecutionException throw karta hai agar task ne exception throw kiya. get(timeout, TimeUnit) wait time limit karne allow karta hai. isDone() completion status check karta hai bina block kiye; isCancelled() indicate karta hai agar cancelled ho. cancel(boolean mayInterruptIfRunning) task abort karne ki koshish karta hai, succeed tabhi hota hai agar task start nahi hua ho ya interruptible ho. Future enable karta hai task submission ko result consumption se alag karna, parallel execution patterns allow karta hai jahan results gather hote hain multiple tasks submit karne ke baad."
        },
        "code": {
          "title": "Future API Usage",
          "language": "java",
          "content": "Future<String> future = executor.submit(() -> {\n    Thread.sleep(5000);\n    return \"Complete\";\n});\n\n// Non-blocking check\nif (!future.isDone()) {\n    System.out.println(\"Still processing...\");\n}\n\n// Blocking with timeout\ntry {\n    String result = future.get(3, TimeUnit.SECONDS);\n} catch (TimeoutException e) {\n    System.out.println(\"Took too long\");\n    future.cancel(true); // Interrupt if running\n}\n\n// Blocking indefinitely\nString result = future.get(); // May throw ExecutionException"
        },
        "codeExplanations": {
          "english": "Example dikhata hai completion status check karna isDone() se, timed get() use karna indefinite blocking avoid karne ke liye, aur tasks ko cancel karna jo time limit exceed kar dete hain. cancel(true) running thread ko interrupt karta hai. Untimed get() block karta hai completion tak lekin ExecutionException throw kar sakta hai computation se kisi bhi exception ko wrap karke, future mechanics aur underlying errors dono handle karne require karta hai."
        },
        "keyPoints": [
          "Represents pending result of asynchronous computation",
          "get() blocks until completion; get(timeout) limits wait",
          "isDone() checks status without blocking",
          "cancel() attempts to abort execution"
        ],
        "extras": {
          "flowDiagram": "Submit → Future object created\n    ↓\nisDone() → false → wait\n    ↓\nTask completes → isDone() true → get() returns result",
          "comparisonTable": "Method|Behavior\nget()|Block indefinitely, return result/get exception\nget(timeout)|Block max timeout, throw TimeoutException if not done\ncancel(true)|Interrupt running task\ncancel(false)|Cancel if not started\nisDone()|Check completion (success, exception, or cancelled)",
          "examples": []
        }
      },
      {
        "id": "s5-5-3",
        "title": "CompletableFuture",
        "explanations": {
          "english": "CompletableFuture, Java 8 mein introduce hua, Future aur CompletionStage implement karta hai asynchronous, non-blocking programming support karne ke liye functional composition ke saath. Ye chaining operations allow karta hai (thenApply, thenAccept, thenCompose) jo completion pe execute hote hain bina threads block kiye. Ye multiple futures combine karna support karta hai (thenCombine, allOf, anyOf), exception handling (exceptionally, handle), aur async execution custom executors ke saath. Future ke unlike jo sirf get() pe block karta hai, CompletableFuture reactive programming enable karta hai jahan callbacks automatically execute hote hain completion pe. Ye synchronous (thenApply) aur asynchronous (thenApplyAsync) dono continuation methods support karta hai, threading pe fine control allow karta hai. Ye modern approach thread blocking aur resource consumption reduce karta hai traditional Future.get() blocking patterns ke comparison mein."
        },
        "code": {
          "title": "CompletableFuture Chaining",
          "language": "java",
          "content": "// Async pipeline\nCompletableFuture.supplyAsync(() -> fetchUser(id))\n    .thenApply(user -> user.getOrders())    // Transform\n    .thenAccept(orders -> process(orders))  // Consume\n    .exceptionally(ex -> {                  // Error handling\n        log.error(\"Failed\", ex);\n        return null;\n    });\n\n// Combining futures\nCompletableFuture<String> user = fetchUserAsync(id);\nCompletableFuture<Integer> credit = checkCreditAsync(id);\n\nuser.thenCombine(credit, (u, c) -> {\n    if (c > 1000) return u + \" (VIP)\";\n    return u;\n}).thenAccept(System.out::println);\n\n// All complete\nCompletableFuture<Void> all = CompletableFuture.allOf(future1, future2, future3);"
        },
        "codeExplanations": {
          "english": "Pipeline supplyAsync() se shuru hota hai async execution ke liye, transformations chain karta hai thenApply() se, aur side effects end karta hai thenAccept() se. exceptionally() error handling provide karta hai bina chain break kiye. thenCombine() do independent futures ko merge karta hai jab dono complete ho jaate hain. allOf() ek future banata hai jo complete hota hai jab saare provided futures complete ho jaate hain, parallel tasks coordinate karne enable karta hai."
        },
        "keyPoints": [
          "Non-blocking async programming with functional composition",
          "Chain operations: thenApply (transform), thenAccept (consume), thenCompose (flatten)",
          "Combine futures: thenCombine, allOf, anyOf",
          "Error handling via exceptionally() and handle()"
        ],
        "extras": {
          "flowDiagram": "supplyAsync() → thenApply() → thenAccept()\n     ↓               ↓            ↓\n  Async          Async/Current  Async/Current\n     ↓               ↓            ↓\n  Step 1         Transform      Consume result",
          "comparisonTable": "Method|Function\nsupplyAsync|Create from Supplier\n.thenApply|Transform result (Function)\n.thenAccept|Consume result (Consumer)\n.thenCompose|Chain async operations (flatten)\n.exceptionally|Handle error (recovery)\n.handle|Map result or error (bi-function)",
          "examples": []
        }
      },
      {
        "id": "s5-5-4",
        "title": "Async Programming Patterns",
        "explanations": {
          "english": "Asynchronous programming patterns non-blocking concurrent execution enable karte hain, scalability improve karte hain threads ko free karke doosra kaam handle karne ke liye jab I/O ya computation ka wait ho raha ho. Common patterns include fire-and-forget (result ka wait kiye bina execute karna), async/await (Futures pe syntactic sugar), aur reactive streams (pub/sub backpressure). Callback pattern handlers register karta hai jo completion pe execute hote hain, polling avoid karte hue. Pipeline pattern dependent operations chain karta hai jahan har stage previous stage ke output consume karta hai. Fan-out/fan-in work distribute karta hai multiple threads mein phir results aggregate karta hai. Exception handling async chains mein careful rehna padta hai aur blocking operations avoid karne hain async callbacks ke andar. Executors aur thread pools ka proper use resource exhaustion prevent karta hai load ke under."
        },
        "code": {
          "title": "Async Patterns Implementation",
          "language": "java",
          "content": "// Fan-out/fan-in: Parallel processing\nList<CompletableFuture<String>> futures = urls.stream()\n    .map(url -> CompletableFuture.supplyAsync(() -> download(url)))\n    .collect(Collectors.toList());\n\n// Wait for all to complete\nList<String> results = futures.stream()\n    .map(CompletableFuture::join)\n    .collect(Collectors.toList());\n\n// Retry pattern with backoff\nCompletableFuture<String> retry = attemptAsync()\n    .thenCompose(result -> {\n        if (result == null) {\n            return CompletableFuture.supplyAsync(\n                () -> attemptAsync(), \n                CompletableFuture.delayedExecutor(1, TimeUnit.SECONDS)\n            );\n        }\n        return CompletableFuture.completedFuture(result);\n    });\n\n// Timeout pattern\nCompletableFuture<String> withTimeout = future.orTimeout(5, TimeUnit.SECONDS);"
        },
        "codeExplanations": {
          "english": "Fan-out/fan-in pattern saare URLs ke liye futures concurrently banata hai, phir unhe join karta hai results collect karne ke liye. Retry pattern thenCompose use karta hai doosra attempt chain karne ke liye agar pehla fail ho jaata hai, delay ke saath. orTimeout() (Java 9+) kisi bhi future mein automatic timeout add karta hai, exceptionally complete karta hai agar time mein done nahi hota. Ye patterns complex async workflows manage karte hue thread blocking prevent karte hain."
        },
        "keyPoints": [
          "Fan-out/fan-in: Parallel execution with result aggregation",
          "Retry with backoff: Chain new attempts on failure with delays",
          "Timeouts: Prevent indefinite waits on async operations",
          "Avoid blocking calls (Thread.sleep, blocking I/O) in async pipelines"
        ],
        "extras": {
          "flowDiagram": "Fan-out:\nInput List → [Task1] → Future1\n         → [Task2] → Future2\n         → [Task3] → Future3\n                  ↓\nFan-in: allOf() → Aggregate results",
          "comparisonTable": "Pattern|Description|Use Case\nFire-and-forget|Execute without result|Logging, notifications\nPipeline|Chain dependent ops|Data processing\nFan-out/in|Parallel then aggregate|Batch processing\nRetry|Reattempt on failure|Network calls",
          "examples": []
        }
      },
      {
        "id": "s5-6-1",
        "title": "Memory Visibility",
        "explanations": {
          "english": "Memory visibility problems tab occur karte hain jab ek thread shared data modify karta hai jo doosre threads promptly nahi dekh paate CPU caching aur compiler optimizations ki wajah se. Synchronization ke bina, thread stale values read kar sakta hai apne local cache se main memory ki jagah. Volatile keyword isse address karta hai ensure karke ki writes main memory mein flush ho jaayein aur reads cache bypass kar jaayein, visibility provide karta hai lekin atomicity nahi. Synchronization both visibility (unlock cache flush karta hai, lock refresh karta hai) aur atomicity provide karta hai. Happens-before relationships guarantee karte hain ki volatile write ya unlock se pehle jo memory writes hue hain woh visible honge threads ko jo subsequent volatile reads ya lock acquires perform karte hain. Visibility samajhna crucial hai correct concurrent programming ke liye bina data races ke."
        },
        "code": {
          "title": "Visibility Issues and Solutions",
          "language": "java",
          "content": "// Problem: Visibility issue\npublic class VisibilityProblem {\n    private boolean running = true; // Not volatile\n    \n    public void stop() {\n        running = false; // May not be seen by other thread\n    }\n    \n    public void run() {\n        while (running) { // May run forever seeing cached value\n            doWork();\n        }\n    }\n}\n\n// Solution 1: volatile\nprivate volatile boolean running = true;\n\n// Solution 2: synchronized\npublic synchronized void stop() {\n    running = false;\n}\n\npublic void run() {\n    while (true) {\n        synchronized (this) {\n            if (!running) break;\n        }\n        doWork();\n    }\n}"
        },
        "codeExplanations": {
          "english": "Volatile ke bina, running variable mein change stop() mein kabhi visible nahi ho sakta thread ko jo run() execute kar raha hai CPU caching ki wajah se, infinite loop cause kar sakta hai. Isse volatile banana ensure karta hai ki write immediately visible ho. Alternatively, synchronized blocks visibility ensure karte hain memory barriers flush karke lock release/acquire pe."
        },
        "keyPoints": [
          "Threads may cache variables locally, missing updates from others",
          "volatile ensures visibility (flush to main memory) but not atomicity",
          "Synchronization ensures both visibility and atomicity",
          "Happens-before rules define when writes become visible"
        ],
        "extras": {
          "flowDiagram": "Thread A: Write to sharedVar → Cached (invisible to others)\nThread B: Read sharedVar → Sees stale cached value\n\nWith volatile:\nThread A: Write → Flushes to Main Memory\nThread B: Read ← Reads from Main Memory (sees update)",
          "comparisonTable": "Modifier|Visibility|Atomicity\nNone|No|No\nvolatile|Yes|No\nsynchronized|Yes|Yes\nAtomicInteger|Yes|Yes (single operations)",
          "examples": []
        }
      },
      {
        "id": "s5-6-2",
        "title": "Atomicity",
        "explanations": {
          "english": "Atomicity ensure karta hai ki operations indivisible units mein execute hoon jahan ya toh saare effects visible hain ya koi nahi, interleaved thread execution se race conditions prevent karta hai. Java mein, primitive variables ke reads aur writes (long/double ke alawa) atomic hote hain, lekin compound operations jaise increment (read-modify-write) atomic nahi hote. Synchronization ke bina, do threads simultaneously counter increment karne se lost updates ho sakte hain. java.util.concurrent.atomic package lock-free atomic classes provide karta hai (AtomicInteger, AtomicLong, AtomicReference) jo Compare-And-Swap (CAS) hardware instructions use karte hain atomic updates ke liye. Synchronized blocks aur ReentrantLocks bhi mutual exclusion se atomicity enforce karte hain. Atomicity essential hai counters, sequences, aur state flags ke liye jo multiple threads access karte hain."
        },
        "code": {
          "title": "Atomic Operations",
          "language": "java",
          "content": "// Non-atomic compound action\npublic void unsafeIncrement() {\n    count++; // Read, modify, write - not atomic!\n}\n\n// Atomic solution 1: Synchronization\npublic synchronized void safeIncrement() {\n    count++;\n}\n\n// Atomic solution 2: Atomic classes\nprivate AtomicInteger atomicCount = new AtomicInteger(0);\n\npublic void atomicIncrement() {\n    atomicCount.incrementAndGet(); // Atomic increment\n}\n\n// CAS pattern\npublic boolean compareAndSet(int expected, int newValue) {\n    return atomicCount.compareAndSet(expected, newValue);\n}"
        },
        "codeExplanations": {
          "english": "count++ actually teen operations hain: current value read karna, one add karna, write back karna. Agar do threads ye simultaneously karte hain, toh woh same value read kar sakte hain, separately increment kar sakte hain, aur same result write back kar sakte hain, ek increment lost ho jaata hai. synchronized poori sequence ko atomic bana deta hai. AtomicInteger hardware CAS operations use karta hai atomicity achieve karne ke liye bina locking ke, contention ke under better performance offer karta hai."
        },
        "keyPoints": [
          "Compound operations (read-modify-write) are not atomic by default",
          "Race conditions occur when threads interleave non-atomic operations",
          "Atomic classes provide lock-free atomic operations using CAS",
          "Synchronization enforces atomicity through mutual exclusion"
        ],
        "extras": {
          "flowDiagram": "Race Condition:\nT1: Read(5)   T2: Read(5)\nT1: Add(6)    T2: Add(6)\nT1: Write(6)  T2: Write(6) ← Lost update!\n\nAtomic:\nT1: CAS(5→6) success\n      T2: CAS(5→6) fails, retries with new value(6)",
          "comparisonTable": "Approach|Mechanism|Performance Blocking\nSynchronized|Lock|Yes\nAtomicInteger|CAS (hardware)|No (retry loop)\nvolatile|Memory barrier|N/A (not compound)",
          "examples": []
        }
      },
      {
        "id": "s5-6-3",
        "title": "Compare-And-Swap (CAS)",
        "explanations": {
          "english": "Compare-And-Swap (CAS) ek hardware-level atomic instruction hai jo JVM use karta hai lock-free algorithms aur atomic classes implement karne ke liye. CAS teen arguments leta hai: ek memory location, ek expected value, aur ek new value. Ye atomically check karta hai ki location mein expected value hai; agar haan, toh usse new value pe update karta hai aur true return karta hai. Agar nahi (doosre thread ne change kar diya), toh koi update nahi hota aur false return karta hai. Calling code typically loop mein retry karta hai (spin) successful hone tak. CAS non-blocking hai - agar operation fail hota hai, toh thread retry karta hai block karne ki jagah. Low contention ke under efficient, lekin high contention bahut saare failed retries cause karta hai (CAS spin), potentially CPU cycles waste karta hai. Modern CPUs isse pause instructions se optimize karte hain."
        },
        "code": {
          "title": "CAS Implementation Pattern",
          "language": "java",
          "content": "// Simulated CAS logic (AtomicInteger does this natively)\npublic class SimulatedCAS {\n    private volatile int value;\n    \n    public synchronized int compareAndSwap(int expected, int newValue) {\n        int oldValue = value;\n        if (oldValue == expected) {\n            value = newValue;\n        }\n        return oldValue;\n    }\n    \n    // Usage pattern\n    public void increment() {\n        int current;\n        do {\n            current = value; // Get expected value\n        } while (current != compareAndSwap(current, current + 1));\n        // Loop until CAS succeeds (no other thread changed value)\n    }\n}\n\n// Actual AtomicInteger usage\nAtomicInteger counter = new AtomicInteger(0);\ncounter.compareAndSet(0, 1); // If 0, set to 1"
        },
        "codeExplanations": {
          "english": "Simulated CAS logic dikhata hai: expected check karna, swap karna agar match ho, verification ke liye old value return karna. Increment method loop karta hai, current value read karta hai, CAS attempt karta hai, aur retry karta hai agar value read aur CAS ke beech badal jaati hai (indicate karta hai doosre thread ne modify kiya hai). Ye lock-free hai lekin spin kar sakta hai. AtomicInteger is hardware instruction ko efficiently wrap karta hai."
        },
        "keyPoints": [
          "Hardware instruction: atomically compare and update if expected value matches",
          "Non-blocking: thread retries rather than blocks on conflict",
          "ABA problem: value changes from A→B→A, CAS succeeds incorrectly (solved by AtomicStampedReference)",
          "Used by atomic classes for lock-free operations"
        ],
        "extras": {
          "flowDiagram": "Thread 1: Read(5) → CAS(5→6) → Success!\nThread 2: Read(5) → CAS(5→6) → Fail (now 6) → Retry with 6",
          "comparisonTable": "Aspect|CAS|Lock\nBlocking|No|Yes\nContention|Spin/retry|Block/wait\nOverhead|Low (single instruction)|Higher (OS scheduling)\nABA Problem|Yes|No",
          "examples": []
        }
      },
      {
        "id": "s5-6-4",
        "title": "Atomic Classes",
        "explanations": {
          "english": "java.util.concurrent.atomic package lock-free, thread-safe atomic variables provide karta hai hardware CAS instructions use karke. AtomicInteger, AtomicLong, aur AtomicBoolean atomic arithmetic aur logical operations provide karte hain (compareAndSet, getAndIncrement, addAndGet). AtomicReference atomic object reference updates provide karta hai. Ye classes synchronization overhead avoid karti hain jabki thread safety ensure karti hain single variable operations ke liye. Ye compound operations support karti hain jaise getAndUpdate aur accumulateAndGet (Java 8+) functional updates ke liye. ABA problem protection ke liye (jab value A→B→A cycle karta hai), AtomicStampedReference aur AtomicMarkableReference values ko version stamps ya boolean marks ke saath pair karte hain. Ye classes high-performance concurrent algorithms aur data structures ke liye foundational hain."
        },
        "code": {
          "title": "Atomic Class Usage",
          "language": "java",
          "content": "// Atomic counters\nAtomicInteger counter = new AtomicInteger(0);\nint newValue = counter.incrementAndGet(); // ++i\nint oldValue = counter.getAndIncrement(); // i++\nint sum = counter.addAndGet(5); // i += 5\n\n// Atomic reference updates\nAtomicReference<String> ref = new AtomicReference<>(\"initial\");\nref.updateAndGet(s -> s.toUpperCase());\n\n// ABA protection\nAtomicStampedReference<String> stamped = \n    new AtomicStampedReference<>(\"A\", 0); // value, stamp\n\nstamped.compareAndSet(\"A\", \"B\", 0, 1); // stamp 0 → 1\nstamped.compareAndSet(\"B\", \"A\", 1, 2); // stamp 1 → 2\n// Now CAS with old stamp 0 would fail even though value is \"A\"\n\n// LongAdder (Java 8) - better for high contention\nLongAdder adder = new LongAdder();\nadder.increment();\nlong total = adder.sum();"
        },
        "codeExplanations": {
          "english": "AtomicInteger various atomic operations provide karta hai different return semantics ke saath (pre vs post increment). updateAndGet functional updates ke liye lambda accept karta hai. AtomicStampedReference ABA prevent karta hai value aur stamp dono ke match karne require karke. LongAdder (strictly atomic nahi lekin thread-safe) striping use karta hai contention read/write overhead reduce karne ke liye higher memory usage ki cost pe, end mein summing karta hai."
        },
        "keyPoints": [
          "Lock-free thread-safe operations on single variables",
          "AtomicInteger/AtomicLong for arithmetic; AtomicReference for objects",
          "AtomicStampedReference prevents ABA problem",
          "LongAdder/LongAccumulator for high-contention counters"
        ],
        "extras": {
          "flowDiagram": "Multiple Threads → AtomicInteger\n    ↓ CAS operations\nSingle atomic update, no locking",
          "comparisonTable": "Class|Use Case\nAtomicInteger|Counters, sequences\nAtomicLong|Large counters\nAtomicReference|Object references\nAtomicStampedReference|ABA-sensitive updates\nLongAdder|High-contention counters (read occasionally)",
          "examples": []
        }
      },
      {
        "id": "s5-7-1",
        "title": "Path & Files",
        "explanations": {
          "english": "Java NIO.2 (Java 7+) mein Path interface introduce hua modern replacement ke roop mein File ka, jo better representation provide karta hai filesystem paths ka symbolic links aur complex operations ke support ke saath. Path immutable hai aur Files utility class ke saath kaam karta hai jo comprehensive static methods offer karta hai file operations ke liye (create, delete, copy, move, read, write). Paths.get() (ya Path.of() Java 11+ mein) Path objects banata hai. API complex path manipulations support karta hai: resolve (paths join karna), relativize (relative path get karna), normalize (redundancies remove karna), aur getParent/getFileName. Files.walk() aur Files.find() Stream-based directory traversal provide karte hain. Ye API legacy java.io.File class ki bahut saari limitations resolve karta hai, particularly error handling aur cross-platform path separators ke around."
        },
        "code": {
          "title": "NIO.2 Path Operations",
          "language": "java",
          "content": "// Creating paths\nPath path = Paths.get(\"/home/user/docs\");\nPath path2 = Path.of(\"data\", \"file.txt\"); // Java 11+\n\n// Path manipulation\nPath absolute = path.toAbsolutePath();\nPath normalized = path.normalize(); // Remove . and ..\nPath resolved = path.resolve(\"subdir/file.txt\"); // Join\nPath relative = path.relativize(Paths.get(\"/home/user/other\"));\n\n// Files utility\nif (Files.exists(path)) {\n    long size = Files.size(path);\n    byte[] bytes = Files.readAllBytes(path);\n    List<String> lines = Files.readAllLines(path);\n}\n\n// Stream operations\nFiles.walk(path) // Recursive directory stream\n    .filter(p -> p.toString().endsWith(\".java\"))\n    .forEach(System.out::println);"
        },
        "codeExplanations": {
          "english": "Paths.get() path objects banata hai varargs use karke path components handle karne ke liye. resolve() paths intelligently join karta hai (agar argument absolute hai, toh argument return karta hai). relativize() do paths ke beech relative path compute karta hai. Files utility methods common operations ke liye one-liners provide karte hain jabki walk() lazy stream banata hai recursive traversal, filtering, aur processing ke liye bina poori directory trees ko memory mein load kiye."
        },
        "keyPoints": [
          "Path replaces File with immutable, robust path representation",
          "Paths.get() or Path.of() (Java 11) for creation",
          "Files utility class provides static methods for all file operations",
          "Stream-based directory traversal with Files.walk() and Files.find()"
        ],
        "extras": {
          "flowDiagram": "Path Creation → Path Manipulation (resolve, relativize) → Files Operations (read/write/check)",
          "comparisonTable": "Operation|Old (java.io.File)|New (NIO.2)\nCreate path|new File(String)|Paths.get(String)\nRead lines|BufferedReader|Files.readAllLines()\nCopy file|FileInput/OutputStream|Files.copy()\nWalk directory|Recursive method|Files.walk() Stream",
          "examples": []
        }
      },
      {
        "id": "s5-7-2",
        "title": "File Operations",
        "explanations": {
          "english": "Files class comprehensive static methods provide karta hai file aur directory operations ke liye atomic aur symbolic link support ke saath. Basic operations include createFile, createDirectory, createDirectories (intermediate dirs create karta hai), delete, deleteIfExists, copy, aur move CopyOption flags ke saath (REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE). API symbolic links ko separately handle karta hai LinkOption.NOFOLLOW_LINKS ke saath. Files attribute access bhi provide karta hai (size, lastModifiedTime, isRegularFile, isDirectory, isSymbolicLink) aur file type probing (probeContentType). Temporary files ke liye, createTempFile aur createTempDirectory available hain. API IOException throw karta hai clear error messages ke saath old File class ki tarah boolean false return karne ki jagah, better error handling enable karta hai."
        },
        "code": {
          "title": "Comprehensive File Operations",
          "language": "java",
          "content": "// Creation\nPath file = Files.createFile(path);\nPath dir = Files.createDirectories(Paths.get(\"a/b/c\"));\n\n// Copy with options\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n// Move atomically (avoids partial files on crash)\nFiles.move(source, target, \n    StandardCopyOption.ATOMIC_MOVE,\n    StandardCopyOption.REPLACE_EXISTING);\n\n// Attributes\nboolean isDir = Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);\nlong size = Files.size(path);\nFileTime time = Files.getLastModifiedTime(path);\n\n// Temporary files\nPath temp = Files.createTempFile(\"prefix\", \".tmp\");\nPath tempDir = Files.createTempDirectory(\"myApp\");"
        },
        "codeExplanations": {
          "english": "createDirectories full path create karta hai parents including, createDirectory ke unlike. Copy aur move CopyOptions ke varargs accept karte hain behavior control karne ke liye; ATOMIC_MOVE ensure karta hai ki operation fully complete ho ya bilkul nahi, system crashes ke dauraan corrupted files prevent karta hai. NOFOLLOW_LINKS option symbolic links traverse karna prevent karta hai attributes check karte hue, security ke liye important."
        },
        "keyPoints": [
          "Atomic file operations with CopyOption flags",
          "ATOMIC_MOVE prevents partial file states during crashes",
          "createDirectories creates parent directories as needed",
          "Better error handling with exceptions vs boolean returns"
        ],
        "extras": {
          "flowDiagram": "Source File → Files.copy() → Target File\n                ↓ Options\n         REPLACE_EXISTING: Overwrite if exists\n         COPY_ATTRIBUTES: Preserve metadata\n         ATOMIC_MOVE: All-or-nothing",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s5-7-3",
        "title": "WatchService",
        "explanations": {
          "english": "WatchService mechanism provide karta hai directories monitor karne ke liye changes ke liye (create, delete, modify events) bina polling ke. Path ke saath registered, ye WatchKeys queue karta hai jo events ke batches represent karte hain. Service ENTRY_CREATE, ENTRY_DELETE, aur ENTRY_MODIFY events watch karta hai. Subdirectories recursively watch nahi hote unless explicitly registered. API require karta hai WatchService ko polling karna take() (blocking) ya poll() (non-blocking) se WatchKeys receive karne ke liye, phir key ko events ke liye poll karna aur usse reset karna further events receive karne ke liye. Ye useful hai hot-reloading configuration files ke liye, upload directories monitor karne ke liye, ya builds trigger karne ke liye jab source change ho. Service ko close karna padta hai jab monitoring end ho taaki native resources release ho sakein."
        },
        "code": {
          "title": "Directory Watching",
          "language": "java",
          "content": "Path dir = Paths.get(\"/watch/dir\");\nWatchService watcher = FileSystems.getDefault().newWatchService();\n\n// Register for events\ndir.register(watcher, \n    StandardWatchEventKinds.ENTRY_CREATE,\n    StandardWatchEventKinds.ENTRY_DELETE,\n    StandardWatchEventKinds.ENTRY_MODIFY);\n\n// Monitor loop\nwhile (true) {\n    WatchKey key = watcher.take(); // Blocks until event\n    \n    for (WatchEvent<?> event : key.pollEvents()) {\n        WatchEvent.Kind<?> kind = event.kind();\n        Path filename = (Path) event.context();\n        System.out.println(kind + \": \" + filename);\n    }\n    \n    boolean valid = key.reset(); // Ready for more events\n    if (!valid) break; // Directory no longer accessible\n}\n\nwatcher.close();"
        },
        "codeExplanations": {
          "english": "Directory WatchService ke saath registered hoti hai specific event types ke liye. Infinite loop take() pe block karta hai jab tak events na ho jaayein. pollEvents() saare events retrieve karta hai jo last check se accumulate hue hain. Key ko reset() karna padta hai further events receive karne ke liye; agar reset false return karta hai, toh watch key valid nahi rahi (directory delete ho gayi). Watcher ko close karna padta hai native file system monitoring resources release karne ke liye."
        },
        "keyPoints": [
          "Monitor directories for create/delete/modify events without polling",
          "n",
          "Register Path with WatchService for specific event kinds",
          "Poll WatchKeys and reset them to continue receiving events",
          "Not recursive; must register subdirectories individually",
          "Close service to release native resources"
        ],
        "extras": {
          "flowDiagram": "Register Path → WatchService\n    ↓\nFile Created → WatchKey queued\n    ↓\nwatcher.take() returns key\n    ↓\nkey.pollEvents() → Process → key.reset() → Continue",
          "comparisonTable": "Method|Behavior\ntake()|Block until events available\npoll()|Return immediately (null if none)\npoll(timeout)|Wait max time",
          "examples": [
            "Configuration hot-reloading",
            "File upload monitoring",
            "Auto-compilation on source change"
          ]
        }
      },
      {
        "id": "s5-7-4",
        "title": "Blocking vs Non-blocking I/O",
        "explanations": {
          "english": "Blocking I/O (traditional java.io) executing thread ko suspend karta hai jab tak operation complete nahi hota, thread resources ko tie up karta hai disk ya network ka wait karte hue. Non-blocking I/O (NIO) single thread ko allow karta hai multiple channels (files ya sockets) manage karne ke liye selectors use karke jo notify karte hain jab channels read/write ke liye ready hote hain. NIO buffers aur channels use karta hai streams ki jagah. Asynchronous I/O (NIO.2 AsynchronousFileChannel, AsynchronousSocketChannel) callbacks ya Futures use karta hai jahan OS completion notify karta hai completion ports ke through, operation ke dauraan koi thread wait nahi karta. Blocking I/O simpler hai aur simple applications ke liye suitable hai; NIO better scale karta hai high-concurrency servers ke liye jo thousands of connections handle karte hain few threads ke saath, jabki async I/O highest throughput provide karta hai I/O-bound workloads ke liye."
        },
        "code": {
          "title": "I/O Model Comparison",
          "language": "java",
          "content": "// Blocking I/O (traditional)\ntry (BufferedReader reader = Files.newBufferedReader(path)) {\n    String line = reader.readLine(); // Thread blocked until data available\n    // Process...\n}\n\n// Non-blocking NIO (Channels)\nPath path = Paths.get(\"file.txt\");\ntry (FileChannel channel = FileChannel.open(path, StandardOpenOption.READ)) {\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n    int bytesRead = channel.read(buffer); // May return 0 if nothing available\n    // Non-blocking channel.configureBlocking(false) required\n}\n\n// Asynchronous I/O (NIO.2)\nAsynchronousFileChannel channel = AsynchronousFileChannel.open(path);\nByteBuffer buffer = ByteBuffer.allocate(1024);\n\nchannel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n    public void completed(Integer result, ByteBuffer attachment) {\n        // Called when read completes, no thread blocked\n    }\n    public void failed(Throwable exc, ByteBuffer attachment) {\n        // Error handling\n    }\n});"
        },
        "codeExplanations": {
          "english": "Blocking I/O thread ko tie up karta hai read ki duration ke liye. NIO channels aur buffers ke saath non-blocking mode mein operate kar sakta hai jahan read immediately return karta hai available data ya 0 ke saath. Asynchronous I/O callbacks use karta hai jo system invoke karta hai jab I/O complete hota hai, wait period ke dauraan zero threads require karta hai - ideal hai high-scale servers ke liye jahan thread-per-connection impractical hai."
        },
        "keyPoints": [
          "Blocking: Thread waits until I/O completes; simple but resource-intensive",
          "Non-blocking (NIO): Thread polls or uses selector; multiplex channels",
          "Asynchronous (NIO.2): OS notifies completion via callbacks/Futures",
          "NIO better for high concurrency with few threads; blocking simpler for low concurrency"
        ],
        "extras": {
          "flowDiagram": "Blocking: Thread → Read Request → [Blocked] → Data Ready → Continue\n\nNon-blocking: Thread → Read → Return immediately (0 or data) → Check again/Selector\n\nAsync: Thread → Read Request → Immediate return\n         ↓\n      Kernel handles I/O\n         ↓\n      Callback executes (any thread)",
          "comparisonTable": "Model|Threads|Throughput|Complexity\nBlocking|Many (per connection)|Low|Low\nNIO Selector|Few (multiplex)|High|Medium\nAsync/AIO|Few|Very High|High",
          "examples": []
        }
      },
      {
        "id": "s5-8-1",
        "title": "Byte Streams",
        "explanations": {
          "english": "Byte streams (InputStream/OutputStream) raw binary data handle karte hain 8-bit bytes ke sequences ke roop mein, suitable hai images, audio, executable files, aur network protocols ke liye jahan character encoding relevant nahi hai. InputStream reading bytes ke liye abstract superclass hai (read(), read(byte[])), jabki OutputStream writing handle karta hai (write(), write(byte[])). FileInputStream aur FileOutputStream file access provide karte hain; BufferedInputStream/BufferedOutputStream performance ke liye buffering add karte hain; DataInputStream/DataOutputStream primitive type serialization support karte hain. Byte streams low-level aur versatile hain lekin manual handling require karte hain byte arrays ki. Character streams ke unlike, ye encoding/decoding involve nahi karte, exact byte values preserve karte hain. Hamesha streams ko finally mein close karo ya try-with-resources use karo resource leaks prevent karne ke liye."
        },
        "code": {
          "title": "Byte Stream Operations",
          "language": "java",
          "content": "// Basic file copy with buffering\ntry (InputStream in = new FileInputStream(\"source.jpg\");\n     BufferedInputStream bin = new BufferedInputStream(in);\n     OutputStream out = new FileOutputStream(\"dest.jpg\");\n     BufferedOutputStream bout = new BufferedOutputStream(out)) {\n    \n    byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = bin.read(buffer)) != -1) {\n        bout.write(buffer, 0, bytesRead);\n    }\n    bout.flush(); // Ensure all data written\n}\n\n// Data streams for primitives\ntry (DataOutputStream dos = new DataOutputStream(\n        new FileOutputStream(\"data.bin\"))) {\n    dos.writeInt(42);\n    dos.writeDouble(3.14);\n    dos.writeUTF(\"Hello\");\n}\n\ntry (DataInputStream dis = new DataInputStream(\n        new FileInputStream(\"data.bin\"))) {\n    int i = dis.readInt();\n    double d = dis.readDouble();\n    String s = dis.readUTF();\n}"
        },
        "codeExplanations": {
          "english": "Buffered copy 8KB buffer use karta hai system calls reduce karne ke liye; read(byte[]) end-of-file pe -1 return karta hai. Data streams primitives binary format mein write karte hain (platform independent DataInput/DataOutput interfaces ke liye). UTF strings length-prefixed hote hain. Buffered output flush karna ensure karta hai ki data physically disk pe write ho jaaye close se pehle; try-with-resources ke saath, close automatic hota hai aur implicitly flush hota hai."
        },
        "keyPoints": [
          "InputStream/OutputStream for raw binary data (8-bit bytes)",
          "Buffered streams improve performance by reducing system calls",
          "Data streams handle primitives (int, double) in binary format",
          "Always close streams; use try-with-resources for automatic cleanup"
        ],
        "extras": {
          "flowDiagram": "File → FileInputStream → BufferedInputStream → Application\nApplication → BufferedOutputStream → FileOutputStream → File",
          "comparisonTable": "Stream Class|Purpose\nFileInputStream|Raw file bytes\nBufferedInputStream|Buffered file access\nDataInputStream|Primitive types\nObjectInputStream|Object serialization",
          "examples": []
        }
      },
      {
        "id": "s5-8-2",
        "title": "Character Streams",
        "explanations": {
          "english": "Character streams (Reader/Writer) 16-bit Unicode characters handle karte hain, automatically character encoding/decoding handle karte hain internal UTF-16 aur external byte encodings (UTF-8, ISO-8859-1, etc.) ke beech mein. FileReader/FileWriter convenience constructors provide karte hain default platform encoding use karke (risky), jabki InputStreamReader/OutputStreamWriter explicit encoding specification allow karte hain portability ke liye. BufferedReader text line processing ke liye readLine() add karta hai; PrintWriter formatted output offer karta hai (printf, println). CharArrayReader/Writer aur StringReader/Writer in-memory character processing allow karte hain. Text files deal karte hue, hamesha encoding explicitly specify karo platform-dependent behavior aur character corruption avoid karne ke liye, particularly ASCII range ke baahar international characters ke liye."
        },
        "code": {
          "title": "Character Stream Usage",
          "language": "java",
          "content": "// Always specify encoding!\ntry (Reader reader = new InputStreamReader(\n        new FileInputStream(\"text.txt\"), StandardCharsets.UTF_8);\n     BufferedReader br = new BufferedReader(reader)) {\n    \n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n\n// Writing with explicit encoding\ntry (Writer writer = new OutputStreamWriter(\n        new FileOutputStream(\"out.txt\"), StandardCharsets.UTF_8);\n     PrintWriter pw = new PrintWriter(writer)) {\n    \n    pw.println(\"Line with Unicode: 日本語\");\n    pw.printf(\"Formatted: %d, %s%n\", 42, \"test\");\n}\n\n// Java 7+ Files convenience (handles encoding)\nList<String> lines = Files.readAllLines(\n    Paths.get(\"file.txt\"), \n    StandardCharsets.UTF_8\n);"
        },
        "codeExplanations": {
          "english": "InputStreamReader byte streams aur character streams ke beech bridge banata hai specified encoding ke saath (UTF-8). BufferedReader efficient line-by-line reading provide karta hai. PrintWriter convenient formatting methods offer karta hai. Files utility (Java 7) simplify karta hai poori files ko strings ki lists mein read karna proper encoding handling ke saath. Explicit encoding 'mojibake' (character corruption) prevent karta hai jab platform default file encoding se differ karta hai."
        },
        "keyPoints": [
          "Reader/Writer for text (Unicode characters) vs bytes",
          "Always specify Charset (UTF-8) for portability; don't rely on platform default",
          "BufferedReader provides readLine() for line-oriented text",
          "PrintWriter provides printf/println convenience methods"
        ],
        "extras": {
          "flowDiagram": "File (bytes) → InputStream → InputStreamReader (decode UTF-8→chars) → BufferedReader → Application",
          "comparisonTable": "Byte Stream|Character Stream|Use Case\nInputStream|Reader|Binary vs Text\nFileInputStream|FileReader (avoid)|File access\nBufferedInputStream|BufferedReader|Buffering\nDataInputStream|BufferedReader|Data vs Text",
          "examples": []
        }
      },
      {
        "id": "s5-8-3",
        "title": "Bridge Streams",
        "explanations": {
          "english": "Bridge streams byte aur character streams ke beech convert karte hain, encoding/decoding transition handle karte hue. InputStreamReader InputStream (bytes) ko Reader (characters) mein convert karta hai bytes decode karke specified Charset use karke. Iske converse mein, OutputStreamWriter Writer (characters) ko OutputStream (bytes) mein convert karta hai characters encode karke bytes mein. Ye essential hain jab legacy APIs byte streams provide karte hain lekin tumhe character handling chahiye, ya jab characters byte-oriented destinations jaise network sockets ya System.out pe write karne hain. Ye charset encoding/decoding internally handle karte hain aur buffering support karte hain jab BufferedReader/Writer mein wrap karte hain. In bridges ke bina, programmers manually manage karenge byte-to-character conversion CharsetEncoder/Decoder use karke."
        },
        "code": {
          "title": "Bridging Bytes to Characters",
          "language": "java",
          "content": "// System.in is byte stream, convert to character reader\nBufferedReader console = new BufferedReader(\n    new InputStreamReader(System.in, StandardCharsets.UTF_8)\n);\nString input = console.readLine();\n\n// Network socket (byte) to character communication\nSocket socket = new Socket(\"host\", 80);\nBufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream(), \"ISO-8859-1\")\n);\nPrintWriter writer = new PrintWriter(\n    new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\")\n);\n\n// Writing to byte stream destination\nByteArrayOutputStream baos = new ByteArrayOutputStream();\ntry (Writer writer = new OutputStreamWriter(baos, StandardCharsets.UTF_8)) {\n    writer.write(\"Unicode text: émojis 🎉\");\n}\nbyte[] bytes = baos.toByteArray(); // UTF-8 encoded bytes"
        },
        "codeExplanations": {
          "english": "InputStreamReader System.in (byte stream) wrap karta hai console se character reading provide karne ke liye. Network communication often specific encodings require karta hai (ISO-8859-1 legacy HTTP ke liye, UTF-8 modern ke liye). OutputStreamWriter character writes ko socket ke byte output stream mein convert karta hai proper encoding ke saath. ByteArrayOutputStream example dikhata hai in-memory conversion characters ko specific byte encoding mein."
        },
        "keyPoints": [
          "InputStreamReader: Bytes → Characters (decoding)",
          "OutputStreamWriter: Characters → Bytes (encoding)",
          "Essential for network I/O and System streams",
          "Always specify charset to avoid platform dependencies"
        ],
        "extras": {
          "flowDiagram": "Byte Stream (bytes) ← InputStreamReader → Character Stream (chars)\n                 (decode)\n\nCharacter Stream (chars) → OutputStreamWriter → Byte Stream (bytes)\n                     (encode)",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s5-8-4",
        "title": "Encoding Basics",
        "explanations": {
          "english": "Character encoding specify karta hai characters ko bytes mein kaise represent kiya jaata hai. ASCII (7-bit) English cover karta hai; ISO-8859-1 (Latin-1) Western European languages tak extend karta hai; UTF-8 (variable 1-4 bytes) modern standard hai jo saare Unicode characters support karta hai ASCII compatibility maintain karte hue; UTF-16 (2 ya 4 bytes) Java ki internal representation hai. Mismatched encoding corruption cause karta hai (mojibake) jab files read karte hain. StandardCharsets class constants provide karta hai guaranteed-supported encodings ke liye. Text read/write karte hue, hamesha encoding explicitly specify karo platform defaults pe rely karne ki bajaye jo OS vary karte hain (Windows: Cp1252, Linux: UTF-8). FileReader/FileWriter constructors mein 'platform default' charset se beware karo jo portability bugs cause karta hai; iski jagah InputStreamReader/Writer use karo explicit charset ke saath."
        },
        "code": {
          "title": "Encoding Handling",
          "language": "java",
          "content": "// StandardCharsets constants (Java 7+)\nCharset utf8 = StandardCharsets.UTF_8;\nCharset ascii = StandardCharsets.US_ASCII;\n\n// Encoding string to bytes\nString text = \"日本語\";\nbyte[] utf8Bytes = text.getBytes(utf8); // Valid UTF-8\nbyte[] asciiBytes = text.getBytes(ascii); // Replacement characters (garbage)\n\n// Decoding bytes to string\nString decoded = new String(utf8Bytes, utf8); // Correct\n\n// Detect encoding (not 100% reliable)\nInputStream in = new FileInputStream(\"file.txt\");\nbyte[] BOM = new byte[3];\nin.read(BOM);\nCharset encoding = StandardCharsets.UTF_8;\nif (BOM[0] == (byte)0xEF && BOM[1] == (byte)0xBB && BOM[2] == (byte)0xBF) {\n    encoding = StandardCharsets.UTF_8; // UTF-8 BOM detected\n}"
        },
        "codeExplanations": {
          "english": "StandardCharsets charset constants provide karta hai UnsupportedEncodingException avoid karne ke liye. getBytes(Charset) string encode karta hai; new String(bytes, Charset) decode karta hai. Japanese characters ko ASCII mein encode karne ki koshish replacement characters (?) produce karti hai. File start pe BOM (Byte Order Mark) detection UTF-8 encoding indicate kar sakta hai, although UTF-8 without BOM zyada common hai."
        },
        "keyPoints": [
          "UTF-8: Universal, recommended default encoding",
          "Always specify encoding; avoid FileReader/FileWriter (use platform default)",
          "StandardCharsets provides safe constants (UTF_8, ISO_8859_1)",
          "Mismatched encoding causes data corruption"
        ],
        "extras": {
          "flowDiagram": "Unicode String (Java memory: UTF-16)\n    ↓ getBytes(UTF_8)\nByte Array (UTF-8 encoded)\n    ↓ new String(bytes, UTF_8)\nUnicode String (correct)\n\nWrong:\n    ↓ new String(bytes, WINDOWS-1252)\nUnicode String (mojibake/corruption)",
          "comparisonTable": "Charset|Bytes per char|Unicode Support|Usage\nASCII|1|Basic English|Legacy protocols\nISO-8859-1|1|Western Europe|Legacy Western systems\nUTF-8|1-4|Full Unicode|Web, modern standard\nUTF-16|2 or 4|Full Unicode|Java internal",
          "examples": []
        }
      },
      {
        "id": "s5-9-1",
        "title": "Performance Optimization",
        "explanations": {
          "english": "Buffered streams dramatically I/O performance improve karte hain native system calls ki number reduce karke. Unbuffered streams har byte ya small array read/write ke liye system call karte hain, significant overhead cause karte hain Java aur OS kernel ke beech context switches ki wajah se. Buffered streams in-memory buffer internalize karte hain (typically 8KB) batch reading/writing ke liye, buffer ko tabhi fill ya flush karte hain jab full ho ya explicitly flushed ho. Ye expensive I/O operations ka cost amortize karta hai bahut saare bytes mein. File I/O ke liye, buffered variants performance improve kar sakte hain orders of magnitude se (10x-100x) small operations ke liye. Optimal buffer size underlying device aur typical data size pe depend karta hai; 8KB ek achha default hai, lekin larger buffers (64KB-1MB) sequential access improve kar sakte hain modern disks pe."
        },
        "code": {
          "title": "Buffering Impact",
          "language": "java",
          "content": "// Without buffering - very slow for small reads\nFileInputStream slow = new FileInputStream(\"large.bin\");\nint data;\nwhile ((data = slow.read()) != -1) { // System call per byte!\n    process(data);\n}\n\n// With buffering - much faster\nBufferedInputStream fast = new BufferedInputStream(\n    new FileInputStream(\"large.bin\"), // Default 8KB buffer\n    65536 // Or specify 64KB custom buffer\n);\nwhile ((data = fast.read()) != -1) { // Reads from memory buffer\n    process(data);\n}"
        },
        "codeExplanations": {
          "english": "Unbuffered example OS read() system call karta hai har single byte ke liye, thousands of CPU cycles consume karta hai context switches mein per byte. Buffered version 64KB ek system call mein memory mein read karta hai, phir individual bytes serve karta hai array se, system calls ko reduce karke 99.9% is workload ke liye."
        },
        "keyPoints": [
          "Unbuffered I/O makes expensive system calls per operation",
          "Buffered streams batch operations using internal memory buffers",
          "Can improve performance 10x-100x for small read/write operations",
          "Flush or close to ensure data reaches destination"
        ],
        "extras": {
          "flowDiagram": "Unbuffered: App → read() → Kernel → Disk (per byte!)\nBuffered: App → Buffer (memory) → read() → Kernel → Disk (when buffer empty)",
          "comparisonTable": "Approach|System Calls|Speed\nUnbuffered|Per byte|Very Slow (1x)\nBufferedInputStream|Per 8KB|Fast (50-100x)",
          "examples": []
        }
      },
      {
        "id": "s5-9-2",
        "title": "Buffer Sizes",
        "explanations": {
          "english": "Buffer size selection memory usage aur I/O efficiency ke beech balance karta hai. Default 8KB (8192 bytes) Buffered streams mein bahut saare scenarios suit karta hai, lekin different workloads ko tuning se benefit milta hai. Small buffers (1-4KB) memory reduce karte hain bahut saare concurrent streams ke liye lekin system calls increase karte hain. Large buffers (64KB-1MB) maximize karte hain throughput sequential file access ya high-latency networks ke liye (round trips reduce karte hue) lekin zyada memory consume karte hain aur latency reduce kar sakte hain small operations ke liye. Disk I/O ke liye, OS page size (often 4KB ya 8KB) ya disk block size match karna help karta hai. Network I/O ke liye, TCP window size ya typical packet size (1460 bytes Ethernet MTU ke liye) relevant hain. Custom buffer sizes specify kiye ja sakte hain Buffered stream constructors mein."
        },
        "code": {
          "title": "Custom Buffer Sizing",
          "language": "java",
          "content": "// Default buffer (8KB)\nBufferedInputStream defaultBuf = new BufferedInputStream(in);\n\n// Large buffer for sequential file processing\nBufferedInputStream largeBuf = new BufferedInputStream(in, 1024 * 1024); // 1MB\n\n// Small buffer for constrained memory\nBufferedInputStream smallBuf = new BufferedInputStream(in, 1024); // 1KB\n\n// Matching buffer to array read size for efficiency\nbyte[] buffer = new byte[8192];\nBufferedInputStream bis = new BufferedInputStream(in, buffer.length);\nint len;\nwhile ((len = bis.read(buffer)) != -1) {\n    // Buffer size matches read array size for optimal performance\n}"
        },
        "codeExplanations": {
          "english": "Default 8KB general use ke liye suitable hai. 1MB buffer sequential reading suit karta hai large files ka jahan memory usage acceptable hai. BufferedInputStream buffer size ko byte[] read size se match karna unnecessary array copying prevent karta hai stream implementation mein, kyunki buffer directly destination array mein copy ho sakta hai."
        },
        "keyPoints": [
          "Default 8KB suitable for general use",
          "Large buffers (1MB+) for high-throughput sequential access",
          "Match buffer size to typical read/write sizes to minimize copying",
          "Consider memory constraints with many concurrent streams"
        ],
        "extras": {
          "flowDiagram": "Small buffer (1KB): Freemptive system calls, low latency, less memory\nLarge buffer (1MB): Fewer system calls, high throughput, more memory",
          "comparisonTable": "Buffer Size|Best For|Trade-off\n1-4KB|Many concurrent streams|Higher syscall overhead\n8KB (default)|General purpose|Balanced\n64KB-1MB|Sequential large files|Higher memory use",
          "examples": []
        }
      },
      {
        "id": "s5-9-3",
        "title": "When to Use Buffered Streams",
        "explanations": {
          "english": "Buffered streams use karne chahiye jab frequent small read/write operations perform ho rahe hon ya jab unbuffered byte streams wrap ho rahe hon (FileInputStream, SocketInputStream). Ye unnecessary hain aur slight overhead add karte hain jab already buffered sources wrap karte hain (ByteArrayInputStream, BufferedReader) ya jab large array operations perform kar rahe hon jahan tum already manually buffer kar rahe ho (1MB at a time apne byte[] mein read karke). Hamesha buffering use karo file I/O aur network communication ke liye unless profiling indicate karta hai ki unnecessary hai. Character streams ke liye, BufferedReader/Writer line-oriented methods add karte hain (readLine, newLine) buffering benefits ke alawa. Java NIO mein, buffering differently handle hota hai ByteBuffer.allocate() ke through, lekin same principles apply hote hain system calls reduce karne ke liye."
        },
        "code": {
          "title": "Appropriate Buffering",
          "language": "java",
          "content": "// DO: Buffer file or network streams\nBufferedInputStream bis = new BufferedInputStream(\n    new FileInputStream(\"file.txt\") // Unbuffered source\n);\n\n// DON'T: Buffer already buffered stream (redundant)\nBufferedInputStream redundant = new BufferedInputStream(\n    new ByteArrayInputStream(bytes) // Already in memory\n);\n\n// DON'T: Buffer when doing large manual reads\nFileInputStream fis = new FileInputStream(\"file.txt\");\nbyte[] largeBuffer = new byte[1024 * 1024];\nwhile (fis.read(largeBuffer) != -1) { } // No BufferedInputStream needed\n\n// DO: Use BufferedReader for line-oriented text\nBufferedReader br = new BufferedReader(\n    new FileReader(\"text.txt\") // Buffering + readLine()\n);\nString line = br.readLine();"
        },
        "codeExplanations": {
          "english": "FileInputStream ko buffer karna significant benefit provide karta hai. ByteArrayInputStream ko buffer karna redundant hai kyunki data already memory mein hai. Jab manually 1MB array mein read karte hain, application buffering handle karti hai, toh BufferedInputStream overhead add karta hai. BufferedReader essential hai line-by-line text processing ke liye, both buffering aur readLine() convenience method provide karta hai."
        },
        "keyPoints": [
          "Use for file I/O and network streams",
          "Avoid for in-memory streams (ByteArrayInputStream)",
          "Unnecessary if manually buffering with large arrays (>8KB)",
          "Essential for character readLine() operations"
        ],
        "extras": {
          "flowDiagram": "Use BufferedInputStream:\nFileInputStream ✓\nSocketInputStream ✓\nByteArrayInputStream ✗ (memory already)\nAlready buffered stream ✗",
          "comparisonTable": "Scenario|Buffered?|Reason\nFile read/write|Yes|Reduce system calls\nSocket communication|Yes|Reduce network round trips\nByte arrays in memory|No|Already in RAM\nLarge manual buffers (1MB+)|No|Application handles buffering",
          "examples": []
        }
      },
      {
        "id": "s5-10-1",
        "title": "Object Serialization",
        "explanations": {
          "english": "Java Object Serialization object instances ko byte streams mein convert karta hai storage ya transmission ke liye, aur deserialization objects ko un bytes se reconstruct karta hai. Classes java.io.Serializable implement karte hain (marker interface) serializability indicate karne ke liye. ObjectOutputStream writeObject() method objects serialize karta hai, poori object graphs handle karte hue (references follow karke), jabki ObjectInputStream readObject() unhe reconstruct karta hai. Transient fields exclude hote hain; static fields serialize nahi hote kyunki ye class ko belong karte hain, instance ko nahi. Serialization object identity preserve karta hai stream mein (same object ke multiple references same object ban jaate hain deserialize karte hue). Ye RMI, session persistence, aur caching mein use hota hai lekin significant security implications aur performance overhead hai modern formats jaise JSON ya Protocol Buffers ke comparison mein."
        },
        "code": {
          "title": "Basic Serialization",
          "language": "java",
          "content": "public class User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private transient String password; // Not serialized\n    private int age;\n    \n    // Getters/setters omitted\n}\n\n// Serialize\nUser user = new User(\"Alice\", \"secret\", 30);\ntry (ObjectOutputStream oos = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    oos.writeObject(user);\n}\n\n// Deserialize\nUser restored;\ntry (ObjectInputStream ois = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    restored = (User) ois.readObject();\n}\n// restored.getPassword() returns null (transient)"
        },
        "codeExplanations": {
          "english": "User Serializable implement karta hai serialVersionUID ke saath version control ke liye. Password field transient mark kiya gaya hai, toh ye null serialize hota hai (ya primitives ke liye default). writeObject call object graph serialize karta hai; readObject correct type casting ke saath reconstruct karta hai. Stream object references automatically handle karta hai."
        },
        "keyPoints": [
          "Implement Serializable marker interface to enable serialization",
          "ObjectOutputStream/ObjectInputStream handle conversion",
          "n",
          "Transient fields are excluded from serialization",
          "Preserves object identities and graphs (circular references handled)"
        ],
        "extras": {
          "flowDiagram": "Object Graph → ObjectOutputStream → Byte Stream (file/network)\nByte Stream → ObjectInputStream → Object Graph (restored)",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s5-10-2",
        "title": "serialVersionUID",
        "explanations": {
          "english": "serialVersionUID Serializable classes ke liye ek unique version identifier hai, serial stream mein store hota hai deserialization ke dauraan compatibility verify karne ke liye. Agar class definition change ho jaati hai (fields add/remove hote hain) aur UID stream se differ karta hai, toh deserialization InvalidClassException throw karta hai. Explicitly serialVersionUID declare karna (private static final long) automatic generation prevent karta hai jo class structure change hone pe change hota hai, controlled versioning allow karta hai. Default UID computation sensitive hai class details ke liye including fields, methods, aur interfaces. Classes evolve karte hue, backward compatibility maintain karo same UID rakhke aur missing fields ko readObject mein handle karke. serialVersionUID add karna strongly recommend kiya jaata hai unexpected incompatibility avoid karne ke liye minor class changes ke dauraan."
        },
        "code": {
          "title": "Version Control",
          "language": "java",
          "content": "public class VersionedClass implements Serializable {\n    // Explicit UID prevents auto-generation\n    private static final long serialVersionUID = 20240101L;\n    \n    private String field1;\n    // Add new field in version 2\n    private String field2; // Deserializing old data: field2 = null\n    \n    // Custom deserialization for compatibility\n    private void readObject(ObjectInputStream in) \n        throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // Initialize new fields if missing from old stream\n        if (field2 == null) {\n            field2 = \"default\";\n        }\n    }\n}\n\n// Eclipse/IntelliJ can generate UID:\n// private static final long serialVersionUID = -6849794470754667701L;"
        },
        "codeExplanations": {
          "english": "Explicit serialVersionUID declare karne se fields add kar sakte hain bina old objects ki deserialization break kiye. Iske bina, class change karne se auto-generated UID change hota hai, InvalidClassException cause karta hai. Custom readObject method backward compatibility handle karta hai new fields initialize karke jab old streams deserialize karte hain jahan wo fields exist nahi karti thi."
        },
        "keyPoints": [
          "Unique identifier for class versioning",
          "Explicit declaration recommended to control compatibility",
          "Mismatch causes InvalidClassException",
          "Use custom readObject/writeObject for complex versioning logic"
        ],
        "extras": {
          "flowDiagram": "Serialize (Class v1, UID=100) → Bytes with UID=100\nDeserialize with Class v2: UID=100 (match) → Success\nDeserialize with UID=200 (changed) → InvalidClassException",
          "comparisonTable": "Scenario|Explicit UID|Implicit UID\nAdd method|Compatible|Compatible\nAdd field|Compatible (null/default)|Incompatible (UID changes)\nRemove field|Compatible|Incompatible",
          "examples": []
        }
      },
      {
        "id": "s5-10-3",
        "title": "Security Risks",
        "explanations": {
          "english": "Java deserialization ek significant security vulnerability hai kyunki readObject method arbitrary code execute kar sakta hai reconstruction ke dauraan. Malicious byte streams objects craft kar sakte hain jo harmful logic execute karein unke constructors, finalizers, ya readObject methods mein deserialization pe (gadget chains). Isse numerous critical vulnerabilities hui hain (e.g., Apache Commons Collections gadget chain). Mitigate karne ke liye, entirely untrusted data deserialize karna avoid karo. Agar necessary ho, toh look-ahead deserialization use karo ObjectInputFilter (Java 9+) ke saath allowable classes whitelist karne ke liye, object graph depth aur size validate karne ke liye, aur proxy classes reject karne ke liye. Safer alternatives consider karo jaise JSON ya Protocol Buffers jo code execute nahi karte parsing ke dauraan. Sensitive data ko kabhi bhi encryption ke bina serialize mat karo, aur sensitive fields ko transient mark karo."
        },
        "code": {
          "title": "Deserialization Security",
          "language": "java",
          "content": "// NEVER deserialize untrusted data without filtering\nObjectInputStream ois = new ObjectInputStream(untrustedStream);\nObject obj = ois.readObject(); // Dangerous if stream is malicious!\n\n// Java 9+ ObjectInputFilter for whitelisting\nObjectInputFilter filter = ObjectInputFilter.Config.createFilter(\n    \"maxdepth=5;java.base/*;!com.example.dangerous.**\"\n);\nois.setObjectInputFilter(filter);\nObject safe = ois.readObject(); // Filter checks before instantiation\n\n// Alternative: JSON (Jackson) - no code execution\nString json = untrustedString;\nUser user = objectMapper.readValue(json, User.class); // Safe"
        },
        "codeExplanations": {
          "english": "Untrusted streams ki raw deserialization 'gadget chain' attacks allow karti hai jahan specially crafted serialized objects library classes mein code execution trigger karte hain. ObjectInputFilter allowed packages whitelist karta hai aur depth limit karta hai ye attacks prevent karne ke liye. JSON parsing arbitrary objects instantiate nahi karta ya methods execute nahi karta, isse untrusted data ke liye safer banata hai."
        },
        "keyPoints": [
          "Deserialization of untrusted data can execute arbitrary code",
          "Gadget chains exploit classes with dangerous readObject methods",
          "Mitigation: ObjectInputFilter (whitelisting), avoid serialization for external data",
          "Use JSON, XML, or Protocol Buffers instead for safer data interchange"
        ],
        "extras": {
          "flowDiagram": "Malicious Bytes → ObjectInputStream.readObject() → Instantiate Gadget Classes → Execute System.exit() or worse\n\nSafe JSON → Parser → Plain Data → Manual Object Construction",
          "comparisonTable": "Format|Code Execution Risk|Use for\nJava Serialization|High (gadget chains)|Internal persistence only\nJSON|Very Low|External APIs, config\nXML|Medium (XXE, entity expansion)|Document data\nProtocol Buffers|Very Low|Internal RPC",
          "examples": [
            "Apache Commons Collections gadgets",
            "ysoserial exploit tool"
          ]
        }
      },
      {
        "id": "s5-10-4",
        "title": "Alternatives to Serialization",
        "explanations": {
          "english": "Java Serialization ke modern alternatives better security, performance, aur cross-language compatibility offer karte hain. JSON (Jackson, Gson) human-readable hai aur widely supported hai lekin larger aur slower hai binary data ke liye. Protocol Buffers (protobuf) aur Apache Avro compact binary formats provide karte hain schema evolution, strong typing, aur high performance ke saath, ideal hai microservices communication ke liye. Kryo fast binary serialization offer karta hai Java ke liye lekin careful version handling require karta hai. FlatBuffers aur Cap'n Proto zero-copy deserialization enable karte hain (access bina parsing ke). XML (JAXB) verbose hai lekin enterprise-standard hai. Persistence ke liye, database serialization (JPA, JDBC) ya columnar formats (Parquet, ORC) prefer kiye jaate hain. Ye alternatives native Java serialization ke security risks aur serialization-specific bugs avoid karte hain jabki often better performance provide karte hain."
        },
        "code": {
          "title": "Alternative Approaches",
          "language": "java",
          "content": "// JSON with Jackson\nObjectMapper mapper = new ObjectMapper();\nString json = mapper.writeValueAsString(user);\nUser restored = mapper.readValue(json, User.class);\n\n// Protocol Buffers (contract defined in .proto file)\nUserProto.User protoUser = UserProto.User.newBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\nbyte[] bytes = protoUser.toByteArray();\nUserProto.User parsed = UserProto.User.parseFrom(bytes);\n\n// Kryo (high performance Java binary)\nKryo kryo = new Kryo();\n kryo.register(User.class);\nOutput output = new Output(new FileOutputStream(\"file.bin\"));\nkryo.writeObject(output, user);\noutput.close();\n\nInput input = new Input(new FileInputStream(\"file.bin\"));\nUser user = kryo.readObject(input, User.class);\ninput.close();"
        },
        "codeExplanations": {
          "english": "Jackson human-readable JSON provide karta hai annotations ke saath customization ke liye. Protocol Buffers schema definition require karta hai lekin efficient, type-safe code generate karta hai multiple languages ke liye. Kryo ek fast binary alternative hai Java-only use cases ke liye, although ise explicit class registration chahiye security aur efficiency ke liye production mein."
        },
        "keyPoints": [
          "JSON: Human-readable, language-neutral, verbose",
          "Protocol Buffers/Avro: Compact binary, schema evolution, multi-language",
          "Kryo: Fast Java-specific binary serialization",
          "Prefer these over Java Serialization for new projects"
        ],
        "extras": {
          "flowDiagram": "Java Object → Jackson → JSON Text → Any Language\nJava Object → Protobuf → Binary → Java/C++/Python/Go\nJava Object → Kryo → Binary → Java only",
          "comparisonTable": "Format|Readable|Size|Speed|Security|Schema\nJava Serial|No|Large|Slow|Poor|Implicit\nJSON|Yes|Large|Medium|Good|External (JSON Schema)\nProtobuf|No|Small|Fast|Excellent|Required (.proto)\nKryo|No|Small|Very Fast|Fair|Implicit",
          "examples": []
        }
      }
    ]
  },
  {
    "id": "section-6",
    "title": "Modern Java (Java 8+)",
    "topics": [
      {
        "id": "s6-1-1",
        "title": "Lambda Expressions Syntax",
        "explanations": {
          "english": "Lambda ka use karke aap anonymous functions ko bina zyada code likhe represent kar sakte ho. Syntax hota hai (parameters) -> body. Ye anonymous classes ka boilerplate khatam kar deta hai - sirf parameters aur logic likhna hota hai. Single parameter ho toh parentheses lagana zaroori nahi, aur single line ka code ho toh curly braces bhi skip kar sakte ho. Compiler automatically samajh jata hai ki parameters ka type kya hai functional interface ko dekh ke (isko target typing kehte hain). Arrow (->) parameters aur body ke beech mein lagta hai. Lambda ka signature bilkul waisa hi hona chahiye jaise functional interface ka abstract method hai. Isse functional programming patterns use kar sakte hain bina type safety compromise kiye."
        },
        "code": {
          "title": "Lambda Syntax Variations",
          "language": "java",
          "content": "// Full syntax with types\nRunnable r1 = () -> {\n    System.out.println(\"Hello\");\n};\n\n// Single parameter, inferred type\nConsumer<String> c1 = (String s) -> System.out.println(s);\nConsumer<String> c2 = s -> System.out.println(s); // Types inferred\n\n// Multiple parameters\nComparator<Integer> comp = (a, b) -> a.compareTo(b);\n\n// Multi-line body with return\nFunction<Integer, Integer> f = (Integer x) -> {\n    int result = x * 2;\n    return result;\n};\n\n// Expression body (implicit return)\nFunction<Integer, Integer> square = x -> x * x;\n\n// Method reference equivalent\nConsumer<String> c3 = System.out::println;"
        },
        "codeExplanations": {
          "english": "Examples mein dikhaya gaya hai kaise lambda syntax verbose se concise ban gaya. Single parameter ke liye parentheses ki zaroorat nahi hoti, aur single expression ke liye braces ya explicit return ki bhi nahi. Compiler types infer kar leta hai target functional interface se (jaise Consumer<String> dekh ke compiler ko pata chal jata hai ki parameter String hai). Method references (::) aur bhi chhota syntax provide karte hain jab lambda sirf koi existing method call kar raha ho."
        },
        "keyPoints": [
          "Syntax: (parameters) -> { body } or (parameters) -> expression",
          "Parameter types can usually be inferred (target typing)",
          "Single parameter: parentheses optional; Single expression: braces/return optional",
          "Must match the single abstract method of a functional interface"
        ],
        "extras": {
          "flowDiagram": "Lambda Expression → Compiler infers target type → Matches Functional Interface → Generates byte code",
          "comparisonTable": "",
          "examples": []
        }
      },
      {
        "id": "s6-1-2",
        "title": "Functional Programming Basics",
        "explanations": {
          "english": "Java mein functional programming computation ko mathematical functions ki tarah treat karti hai, jisme immutability, first-class functions (lambdas), aur side effects avoid karna important hai. Main concepts hain pure functions (same input pe same output, koi side effect nahi), higher-order functions (jo functions accept ya return karte hain), aur immutability (data create hone ke baad change nahi hota). Java functional programming ko support karta hai lambda expressions, method references, aur Stream API se, aur saath mein object-oriented bhi rehta hai. Functional approach mein declarative code pasand kiya jata hai (kya karna hai) imperative ke badle (kaise karna hai), jaise map, filter, reduce operations use karke. Is style se bugs kam hote hain kyunki shared mutable state minimize ho jata hai aur code zyada testable aur parallelizable ban jata hai."
        },
        "code": {
          "title": "Functional vs Imperative",
          "language": "java",
          "content": "// Imperative style (how to do it)\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList<String> upper = new ArrayList<>();\nfor (String name : names) {\n    if (name.length() > 3) {\n        upper.add(name.toUpperCase());\n    }\n}\n\n// Functional style (what to do)\nList<String> upperFunctional = names.stream()\n    .filter(name -> name.length() > 3)    // Predicate\n    .map(String::toUpperCase)             // Function\n    .collect(Collectors.toList());        // Collector\n\n// Pure function (no side effects)\nFunction<Integer, Integer> pure = x -> x * 2;\n\n// Higher-order function (returns function)\npublic static Function<Integer, Integer> multiplier(int factor) {\n    return x -> x * factor; // Returns a function\n}\n\nFunction<Integer, Integer> triple = multiplier(3);\nint result = triple.apply(5); // 15"
        },
        "codeExplanations": {
          "english": "Imperative example mein manually iterate kiya ja raha hai aur collect kiya ja raha hai, external state modify karke. Functional example mein stream operations use ho rahe hain: filter predicate apply karta hai taaki 3 characters se zyada wale elements rahe jayein, map har element ko transform karta hai, aur collect results ko gather kar leta hai. pure ek pure function hai jisme koi side effect nahi hai. multiplier ek higher-order function hai jo ek function return karta hai jo factor variable ko capture karta hai (closure)."
        },
        "keyPoints": [
          "Declarative programming: describe what, not how",
          "Pure functions: deterministic, no side effects, easier to test",
          "Higher-order functions: functions as parameters or return values",
          "Immutability preferred; avoid modifying external state in lambdas"
        ],
        "extras": {
          "flowDiagram": "Data → Filter → Map → Collect → Result\n(Declarative pipeline vs step-by-step imperative)",
          "comparisonTable": "Aspect|Imperative|Functional\nStyle|Step-by-step|Declarative\nState|Mutable variables|Immutable data\nSide Effects|Common|Avoided\nParallel|Hard|Easy (Streams)",
          "examples": []
        }
      },
      {
        "id": "s6-1-3",
        "title": "Effectively Final Variables",
        "explanations": {
          "english": "Effectively final variables woh local variables hain jo final declare nahi kiye gaye hain lekin jinki value initialization ke baad kabhi change nahi hoti. Lambdas aur local classes in variables ko capture kar sakte hain, lekin sirf tab jab woh effectively final hon. Agar aap aise variable ko modify karne ki koshish karte ho lambda mein reference karne ke baad, toh compilation error aata hai. Yeh restriction isliye hai kyunki lambdas asynchronous execute ho sakte hain (jaise streams ya threads mein) method return hone ke baad, aur agar modification allow kiya toh race conditions aur visibility issues ho sakte hain. Instance aur static fields ko lambdas ke andar modify kiya ja sakta hai; yeh restriction sirf local variables aur parameters pe apply hoti hai. Isse thread safety ensure hoti hai aur functional code mein confusing side effects prevent hote hain."
        },
        "code": {
          "title": "Variable Capture Rules",
          "language": "java",
          "content": "public void lambdaCapture() {\n    int count = 0; // Effectively final (never modified)\n    \n    Runnable r = () -> {\n        System.out.println(count); // OK: reading effectively final\n        // count++; // Compile error: must be final or effectively final\n    };\n    \n    // count = 1; // Would make count not effectively final\n    \n    // Workaround using array or AtomicInteger\n    int[] counter = new int[1];\n    Runnable r2 = () -> {\n        counter[0]++; // OK: array reference is final, contents mutable\n    };\n    \n    // Better: use atomic types\n    AtomicInteger atomicCount = new AtomicInteger(0);\n    Runnable r3 = () -> {\n        atomicCount.incrementAndGet(); // OK: modifying object state, not reference\n    };\n}\n\n// Instance fields are always accessible\nprivate int instanceVar = 0;\npublic void fieldAccess() {\n    Runnable r = () -> {\n        instanceVar++; // OK: instance fields can be modified\n    };\n}"
        },
        "codeExplanations": {
          "english": "count effectively final hai (modify nahi kiya gaya), isliye isse lambda ke andar read kiya ja sakta hai. Ise lambda ke andar ya baad mein modify karna prohibited hai. Array workaround isliye kaam karta hai kyunki variable (reference) final hai, array contents change ho sakte hain lekin. AtomicInteger lambdas mein counters ke liye proper solution hai. Instance fields pe koi restriction nahi hai kyunki yeh heap pe exist karte hain aur kisi bhi code ke liye accessible hain jisko object ka reference hai."
        },
        "keyPoints": [
          "Local variables referenced from lambdas must be final or effectively final",
          "Effectively final: assigned once, never modified after",
          "Restriction prevents race conditions in asynchronous execution",
          "Instance fields and array elements can be modified (reference stays final)"
        ],
        "extras": {
          "flowDiagram": "Lambda Creation → Captures value of effectively final variable\nMethod returns → Lambda executes later with captured copy\n(Original variable may be gone, so modification would be unsafe)",
          "comparisonTable": "Variable Type|Can Read|Can Modify\nEffectively final local|Yes|No\nNon-final local|No|No\nInstance field|Yes|Yes\nStatic field|Yes|Yes\nArray elements|Yes|Yes (reference is final)",
          "examples": []
        }
      },
      {
        "id": "s6-2-1",
        "title": "Predicate",
        "explanations": {
          "english": "Predicate<T> ek functional interface hai jo boolean-valued function represent karta hai single argument ke saath, conditions test karne ya filtering ke liye use hota hai. Iska single abstract method hai boolean test(T t). Predicates Stream API ke filter operation ke liye fundamental hain aur inhe compose kiya ja sakta hai and(), or(), aur negate() default methods use karke. Common uses mein validation (jaise valid email check karna), collections filter karna (jaise active user), aur conditional logic aate hain. Interface provide karta hai static method isEqual() equality testing ke liye aur default methods logical combination ke liye. Predicates declarative filtering logic enable karte hain bina verbose anonymous classes ke, jisse code zyada readable aur composable ban jata hai."
        },
        "code": {
          "title": "Predicate Usage and Composition",
          "language": "java",
          "content": "// Basic predicate\nPredicate<String> isLong = s -> s.length() > 5;\nboolean result = isLong.test(\"Hello World\"); // true\n\n// Usage in Stream filtering\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList<String> longNames = names.stream()\n    .filter(isLong)\n    .collect(Collectors.toList());\n\n// Negation\nPredicate<String> isShort = isLong.negate();\n\n// Composition with AND/OR\nPredicate<String> startsWithA = s -> s.startsWith(\"A\");\nPredicate<String> longAndStartsWithA = isLong.and(startsWithA);\n\n// Method reference\nPredicate<Object> isNull = Objects::isNull;\nPredicate<Object> nonNull = Objects::nonNull;\n\n// BiPredicate for two arguments\nBiPredicate<String, Integer> isLength = (s, len) -> s.length() == len;"
        },
        "codeExplanations": {
          "english": "isLong string length test karta hai; filter ise stream elements pe apply karta hai. Negate opposite condition create karta hai. and() do predicates ko combine karta hai short-circuit evaluation ke saath (agar pehla false hai toh second evaluate nahi hota). BiPredicate do arguments accept karta hai un comparisons ke liye jo dono values require karte hain, jaise check karna ki string kisi specific length parameter se match karti hai ya nahi."
        },
        "keyPoints": [
          "Represents boolean condition: T -> boolean",
          "Primary method: test(T t)",
          "Composable: and(), or(), negate() for combining conditions",
          "Heavily used in Stream.filter()"
        ],
        "extras": {
          "flowDiagram": "Stream Elements → Predicate.test() → true: keep, false: filter out",
          "comparisonTable": "Operation|Method|Description\nLogical AND|p1.and(p2)|Both must be true\nLogical OR|p1.or(p2)|At least one true\nNegation|p.negate()|Opposite boolean\nEquality|Predicate.isEqual(obj)|Compares to specific object",
          "examples": []
        }
      },
      {
        "id": "s6-2-2",
        "title": "Consumer",
        "explanations": {
          "english": "Consumer<T> ek operation represent karta hai jo single argument accept karta hai aur koi result return nahi karta (void), side effects ke liye use hota hai jaise printing, logging, ya external state modify karna. Iska method hai void accept(T t). Consumers Stream ke forEach() method mein use hote hain har element process karne ke liye. andThen() default method chaining allow karta hai consumers ki jahan pehle ka output dusre ka input ban jata hai (sequenced execution). BiConsumer<T,U> do arguments handle karta hai, Map.forEach() entry processing ke liye useful hai. Functions ke unlike, consumers values return nahi karte, isliye yeh terminal operations ke liye suitable hain pipelines mein jahan action itself goal hai transformation ke badle."
        },
        "code": {
          "title": "Consumer Patterns",
          "language": "java",
          "content": "// Basic consumer\nConsumer<String> printer = System.out::println;\nprinter.accept(\"Hello\"); // Prints Hello\n\n// ForEach usage\nList<Integer> numbers = Arrays.asList(1, 2, 3);\nnumbers.forEach(n -> System.out.println(n * 2));\n\n// Chaining consumers\nConsumer<String> printUpper = s -> System.out.println(s.toUpperCase());\nConsumer<String> printLength = s -> System.out.println(s.length());\nConsumer<String> combined = printUpper.andThen(printLength);\ncombined.accept(\"hello\"); // Prints HELLO then 5\n\n// BiConsumer (two arguments)\nMap<String, Integer> scores = new HashMap<>();\nscores.put(\"Alice\", 90);\nscores.forEach((name, score) -> \n    System.out.println(name + \": \" + score)\n);\n\n// Custom consumer with logic\nConsumer<List<Integer>> clearAndLog = list -> {\n    System.out.println(\"Clearing list of size \" + list.size());\n    list.clear();\n};"
        },
        "codeExplanations": {
          "english": "System.out::println ek method reference hai jo Consumer<String> mein fit hota hai. forEach consumer ko har stream element pe apply karta hai. andThen consumers ko sequence karta hai; combined pehle uppercase print karta hai, phir length print karta hai. BiConsumer forEach mein map key aur value dono accept karta hai. Custom consumers complex side-effect logic encapsulate kar sakte hain functional interface compatibility maintain karte hue."
        },
        "keyPoints": [
          "Represents operation: T -> void (side effects)",
          "Method: accept(T t)",
          "andThen() chains sequential operations",
          "BiConsumer<T,U> for two-argument operations (e.g., Map entries)"
        ],
        "extras": {
          "flowDiagram": "Element → Consumer.accept() → Side Effect (print, log, modify external state)",
          "comparisonTable": "Interface|Arguments|Returns|Use Case\nConsumer<T>|1|void|ForEach operations\nBiConsumer<T,U>|2|void|Map iteration\nSupplier<T>|0|T|Provide values\nFunction<T,R>|1|R|Transform data",
          "examples": []
        }
      },
      {
        "id": "s6-2-3",
        "title": "Supplier",
        "explanations": {
          "english": "Supplier<T> results ka supplier represent karta hai jo koi argument nahi leta aur ek value return karta hai, factory ya deferred execution mechanism ki tarah kaam karta hai. Iska method hai T get(). Suppliers lazy evaluation ke liye use hote hain, values tabhi generate karte hain jab zaroorat hoti hai (jaise Optional.orElseGet() mein taaki expensive default value computation avoid ho sake). Yeh value creation logic ko dependency injection enable karte hain aur functional style mein factory patterns ke liye essential hain. Common uses mein random values create karna, configuration read karna, ya timestamps generate karna aate hain. Functions ke unlike, Suppliers ka koi input nahi hota, isliye yeh suitable hain values provide karne ke liye on demand bina external dependencies ke. DoubleSupplier, IntSupplier, aur LongSupplier variants boxing avoid karte hain primitives ke liye."
        },
        "code": {
          "title": "Supplier Patterns",
          "language": "java",
          "content": "// Basic supplier\nSupplier<String> greeting = () -> \"Hello World\";\nString message = greeting.get(); // Lazily provides value\n\n// Lazy evaluation with Optional\nOptional<String> optional = Optional.empty();\nString value = optional.orElseGet(() -> {\n    // Only executes if optional is empty\n    System.out.println(\"Computing expensive default...\");\n    return expensiveOperation();\n});\n\n// Factory pattern\nSupplier<List<String>> listFactory = ArrayList::new;\nList<String> list1 = listFactory.get();\nList<String> list2 = listFactory.get();\n\n// Random generation\nSupplier<Integer> randomInt = () -> (int) (Math.random() * 100);\nint number = randomInt.get();\n\n// Primitive suppliers (avoid boxing)\nIntSupplier intSupplier = () -> 42;\nint primitive = intSupplier.getAsInt(); // Returns int, not Integer"
        },
        "codeExplanations": {
          "english": "orElseGet lazy evaluation demonstrate karta hai: expensive lambda sirf tab execute hota hai jab Optional empty ho, orElse ke unlike jo hamesha execute hota hai. listFactory ek Supplier hai jo new ArrayLists create karta hai, Stream.collect() ke liye useful hai. Primitive suppliers (IntSupplier, etc.) primitives directly return karte hain Integer object overhead avoid karne ke liye, tight loops mein better performance offer karte hain."
        },
        "keyPoints": [
          "Represents supplier: () -> T (no input, produces output)",
          "Method: get()",
          "Used for lazy evaluation and factory patterns",
          "Primitive variants: IntSupplier, LongSupplier, DoubleSupplier"
        ],
        "extras": {
          "flowDiagram": "Call Supplier.get() → Executes logic → Returns value\n(Deferred until called)",
          "comparisonTable": "Method|Eager|Lazy\norElse(value)|Always computes|N/A (already computed)\norElseGet(Supplier)|N/A|Computes only if needed",
          "examples": []
        }
      },
      {
        "id": "s6-2-4",
        "title": "Function",
        "explanations": {
          "english": "Function<T,R> ek function represent karta hai jo ek argument accept karta hai aur result produce karta hai, functional programming mein primary transformation type ka kaam karta hai. Iska method hai R apply(T t). Functions Stream.map() mein use hote hain element transformation ke liye (jaise String ko Integer mein convert karna). compose() method current function se pehle function apply karta hai (f.compose(g) matlab f(g(x))), jabki andThen() baad mein apply karta hai (f.andThen(g) matlab g(f(x))). identity() ek function return karta hai jo hamesha apna input argument hi return karta hai. UnaryOperator<T> Function ko extend karta hai jahan input aur output same type ke hote hain. Functions method chaining aur composition enable karte hain, jisse complex transformations simple, reusable components se build ki ja sakti hain."
        },
        "code": {
          "title": "Function Composition",
          "language": "java",
          "content": "// Basic function\nFunction<String, Integer> length = String::length;\nint len = length.apply(\"hello\"); // 5\n\n// Chaining with andThen\nFunction<String, String> trim = String::trim;\nFunction<String, String> toUpper = String::toUpperCase;\nFunction<String, String> trimThenUpper = trim.andThen(toUpper);\nString result = trimThenUpper.apply(\"  hello  \"); // \"HELLO\"\n\n// Composition with compose (reverse order)\nFunction<String, String> composeResult = toUpper.compose(trim); // Same as above\n\n// Stream transformation\nList<String> names = Arrays.asList(\"Alice\", \"Bob\");\nList<Integer> lengths = names.stream()\n    .map(length)\n    .collect(Collectors.toList());\n\n// UnaryOperator (input type = output type)\nUnaryOperator<String> addExclamation = s -> s + \"!\";\n\n// Identity function\nFunction<String, String> identity = Function.identity(); // Returns input unchanged"
        },
        "codeExplanations": {
          "english": "andThen functions ko left-to-right chain karta hai: pehle trim apply hota hai, phir toUpper. compose right-to-left chain karta hai: argument function (trim) pehle execute hota hai, phir caller (toUpper). identity useful hai default function ki tarah ya jab function required ho lekin koi transformation nahi chahiye. UnaryOperator ek convenience type hai jab aap indicate karna chahte ho ki transformation type preserve karta hai (jaise String to String)."
        },
        "keyPoints": [
          "Represents transformation: T -> R",
          "Method: apply(T t)",
          "andThen(): sequential composition; compose(): nested composition",
          "UnaryOperator<T> is Function<T, T> (same type)"
        ],
        "extras": {
          "flowDiagram": "Input → Function1.apply() → Result1 → Function2.apply() → Result2\n(andThen chaining)",
          "comparisonTable": "Method|Order|Syntax\nf.andThen(g)|f then g|g(f(x))\nf.compose(g)|g then f|f(g(x))\nidentity|N/A|x -> x",
          "examples": []
        }
      },
      {
        "id": "s6-2-5",
        "title": "Custom Functional Interfaces",
        "explanations": {
          "english": "Custom functional interfaces domain-specific contracts define karte hain lambdas ke liye jab standard interfaces (Predicate, Function, Consumer) required signature match nahi karte. Inhe @FunctionalInterface se annotate kiya jata hai taaki indicate ho ki yeh lambdas ke liye intended hain aur compiler checking enable ho (ensure karta hai exactly one abstract method ho). Custom interfaces code readability improve karte hain domain-relevant names use karke (jaise Validator, Transformer) aur checked exceptions specify kar sakte hain apne abstract method signatures mein. Inme default aur static methods include ho sakte hain bina functional interface contract break kiye. Jab custom functional interfaces design karte hain, prefer karo existing standard interfaces use karna agar possible ho taaki utility methods leverage kar sakein aur other developers ke liye familiarity ensure ho sake."
        },
        "code": {
          "title": "Custom Interface Definition",
          "language": "java",
          "content": "package com.example.validation;\n\n@FunctionalInterface\npublic interface Validator<T> {\n    // Single abstract method\n    boolean validate(T value) throws ValidationException;\n    \n    // Default method (doesn't affect functional interface status)\n    default Validator<T> and(Validator<T> other) {\n        return value -> this.validate(value) && other.validate(value);\n    }\n    \n    // Static utility\n    static <T> Validator<T> alwaysTrue() {\n        return value -> true;\n    }\n}\n\n// Usage\nValidator<String> notNull = s -> s != null;\nValidator<String> notEmpty = s -> !s.isEmpty();\nValidator<String> combined = notNull.and(notEmpty);\n\ntry {\n    boolean valid = combined.validate(\"hello\");\n} catch (ValidationException e) {\n    // Handle checked exception\n}\n\n// Generic transformer with exception\n@FunctionalInterface\npublic interface ThrowingFunction<T, R, E extends Exception> {\n    R apply(T t) throws E;\n}"
        },
        "codeExplanations": {
          "english": "Validator ek custom functional interface hai jisme single abstract method ki check hai aur allowed checked exception hai. Default method 'and' composition capability provide karta hai Predicate ke similar. ThrowingFunction ek generic pattern demonstrate karta hai functional interfaces ke liye jo checked exceptions declare karna chahte hain, commonly use hota hai frameworks mein jo functional aur checked exception worlds ko bridge karte hain."
        },
        "keyPoints": [
          "Use @FunctionalInterface annotation for compiler verification",
          "Exactly one abstract method (SAM); other methods must be default/static",
          "n",
          "Can declare checked exceptions unlike standard functional interfaces",
          "Prefer standard interfaces (Function, Predicate) when possible"
        ],
        "extras": {
          "flowDiagram": "@FunctionalInterface\n    ↓\nCompiler checks: exactly 1 abstract method\n    ↓\nCan use with lambda syntax",
          "comparisonTable": "Feature|Standard|Custom\nReadability|Generic (Function)|Domain-specific (Validator)\nChecked Exceptions|No (Runtime)|Can declare\nUtility methods|Many (andThen, etc.)|Must implement own",
          "examples": []
        }
      },
      {
        "id": "s6-3-1",
        "title": "Static Method References",
        "explanations": {
          "english": "Static method references syntax use karte hain ClassName::methodName static methods ko functional interfaces ki tarah refer karne ke liye. Yeh shorthand hai lambdas ke liye jo static methods call karte hain (args -> ClassName.method(args)). Method signature functional interface ke abstract method signature se match karna chahiye. Static method references zyada clean aur readable code provide karte hain jab lambda sirf static method call kar raha ho bina additional logic ke. Commonly use hote hain utility methods ke liye jaise Integer::parseInt, String::valueOf, ya Collections::sort. Compiler type inference handle karta hai method signature ko functional interface se match karne ke liye, parameter types aur return type compatibility check karke. Static references lambda generation ka overhead avoid karte hain jab method pehle se exist karti hai."
        },
        "code": {
          "title": "Static Reference Usage",
          "language": "java",
          "content": "// Lambda equivalent: s -> Integer.parseInt(s)\nFunction<String, Integer> parser = Integer::parseInt;\nint num = parser.apply(\"42\"); // 42\n\n// Converting list to strings\nList<Integer> numbers = Arrays.asList(1, 2, 3);\nList<String> strings = numbers.stream()\n    .map(String::valueOf) // Static method reference\n    .collect(Collectors.toList());\n\n// Sorting with Comparator\nList<String> names = Arrays.asList(\"Alice\", \"bob\", \"Charlie\");\nnames.sort(String::compareToIgnoreCase);\n\n// Thread factory\nSupplier<Thread> threadFactory = Thread::new; // Reference to constructor\nThread t = threadFactory.get();\n\n// Utility class methods\nFunction<Double, Double> abs = Math::abs;\nBiFunction<Integer, Integer, Integer> max = Math::max;"
        },
        "codeExplanations": {
          "english": "Integer::parseInt String ko Integer mein convert karta hai, Function<String, Integer> match karta hai. String::valueOf objects ko strings mein convert karta hai. String::compareToIgnoreCase Comparator<String> match karta hai. Math::abs aur Math::max static references dikhate hain different arities ke saath (unary aur binary). Yeh references same bytecode produce karte hain equivalent lambdas jitna lekin zyada concise hote hain."
        },
        "keyPoints": [
          "Syntax: ClassName::staticMethodName",
          "Shorthand for lambda calling static method",
          "Method signature must match functional interface method",
          "Cleaner than equivalent lambda when no additional logic needed"
        ],
        "extras": {
          "flowDiagram": "Lambda: x -> Class.method(x)\n         ↓ equivalent\nReference: Class::method",
          "comparisonTable": "Lambda|Method Reference|Use When\nx -> Math.abs(x)|Math::abs|Just calling static method\nx -> x.trim()|String::trim|Just calling instance method\n() -> new ArrayList()|ArrayList::new|Object creation",
          "examples": []
        }
      },
      {
        "id": "s6-3-2",
        "title": "Instance Method References",
        "explanations": {
          "english": "Instance method references specific object instance ke methods ko refer karte hain syntax use karke instance::methodName. Yeh use hote hain jab kisi particular object pe method call karna ho jo reference create hone ke time pe jana jata hai, arbitrary instance references (ClassName::methodName) ke unlike jo lambda argument pe operate karte hain. Common uses mein event handlers jo listener ke method ko reference karte hain, specific object state ke liye callbacks, ya existing object methods ko functions ki tarah wrap karna aate hain. Instance capture (bind) ho jata hai jab reference create hota hai, jab invoke hota hai tab nahi. Yeh useful hai dependency injection scenarios mein jahan service method ko callback ki tarah invoke karna chahiye. Instance method functional interface signature match karna chahiye pehle parameter ko chhod ke (jo instance khud hai)."
        },
        "code": {
          "title": "Bound Instance References",
          "language": "java",
          "content": "// Specific instance method reference\nString prefix = \"Hello, \";\nFunction<String, String> greeter = prefix::concat; // s -> prefix.concat(s)\nString result = greeter.apply(\"World\"); // \"Hello, World\"\n\n// Using existing object methods\nList<String> list = new ArrayList<>();\nConsumer<String> addToList = list::add; // s -> list.add(s)\naddToList.accept(\"Item\"); // Adds to specific list instance\n\n// arbitrary instance reference (different syntax)\nFunction<String, String> toUpper = String::toUpperCase; // s -> s.toUpperCase()\n\n// Comparator with instance field\nLocalDate today = LocalDate.now();\nComparator<Event> byDaysUntil = Comparator.comparing(\n    event -> ChronoUnit.DAYS.between(today, event.getDate())\n);"
        },
        "codeExplanations": {
          "english": "prefix::concat specific String object 'prefix' ko bind karta hai taaki jab function \"World\" ke saath call hota hai, toh prefix.concat(\"World\") invoke hota hai. list::add specific ArrayList instance ko bind karta hai, useful hai callbacks ke liye jo specific collection modify karni chahiye. List<String>::add ek unbound reference hoga jo list aur element dono arguments require karega (BiConsumer)."
        },
        "keyPoints": [
          "Syntax: objectInstance::methodName",
          "n",
          "Captures specific instance at reference creation time",
          "Different from ClassName::method (arbitrary instance)",
          "Useful for callbacks to specific objects"
        ],
        "extras": {
          "flowDiagram": "Specific Object → Method Reference Captured → Lambda Invocation Calls Object's Method",
          "comparisonTable": "Type|Syntax|Parameters\nStatic|Class::method|Regular parameters\nBound Instance|obj::method|Regular parameters (obj captured)\nUnbound Instance|Class::method|First param becomes 'this', rest are params",
          "examples": []
        }
      },
      {
        "id": "s6-3-3",
        "title": "Constructor References",
        "explanations": {
          "english": "Constructor references syntax use karte hain ClassName::new class constructors ko functional interfaces ki tarah refer karne ke liye, lambda expressions ke equivalent jo objects instantiate karte hain. Yeh kaam karte hain Supplier (no-arg constructor), Function (one-arg constructor), BiFunction (two-arg constructor), aur custom functional interfaces ke saath jo constructor signatures match karte hain. Compiler appropriate constructor select karta hai target functional interface ke parameters ke basis pe. Constructor references explicit lambdas se zyada clean hain object factories ke liye aur heavily use hote hain Stream collection operations mein (Collectors.toCollection(ArrayList::new)). Yeh dependency injection patterns enable karte hain jahan object creation defer ho jati hai function reference pe. Generic type inference exact class determine karta hai jo instantiate ho rahi hai."
        },
        "code": {
          "title": "Constructor Reference Patterns",
          "language": "java",
          "content": "// No-arg constructor (Supplier)\nSupplier<ArrayList<String>> listFactory = ArrayList::new;\nArrayList<String> list = listFactory.get();\n\n// One-arg constructor (Function)\nFunction<String, File> fileCreator = File::new;\nFile file = fileCreator.apply(\"/path/to/file\");\n\n// Two-arg constructor (BiFunction)\nBiFunction<String, Integer, Person> personFactory = Person::new;\nPerson person = personFactory.apply(\"Alice\", 30);\n\n// Array constructor\nIntFunction<int[]> arrayCreator = int[]::new;\nint[] array = arrayCreator.apply(10); // size 10\n\n// Generic collection creation\nList<String> names = Stream.of(\"Alice\", \"Bob\")\n    .collect(Collectors.toCollection(ArrayList::new));"
        },
        "codeExplanations": {
          "english": "ArrayList::new Supplier match karta hai default constructor ke liye. File::new Function<String, File> match karta hai String path constructor ke liye. Person::new do arguments ke saath BiFunction match karta hai. int[]::new arrays create karta hai (special array constructor reference syntax). Collectors.toCollection Supplier accept karta hai Collection ka, isliye ArrayList::new factory provide karta hai result list create karne ke liye."
        },
        "keyPoints": [
          "Syntax: ClassName::new or obj.getClass()::new",
          "Matches constructor arguments to functional interface parameters",
          "Used with Supplier (0-args), Function (1-arg), BiFunction (2-args)",
          "Array creation: Type[]::new (e.g., int[]::new)"
        ],
        "extras": {
          "flowDiagram": "Functional Interface Requires Object → Constructor Reference Class::new → Invokes new Class(params)",
          "comparisonTable": "Constructor|Matches Interface\nnew()|Supplier<T>\nnew(T)|Function<T, R>\nnew(T,U)|BiFunction<T, U, R>\nnew int[size]|IntFunction<int[]>",
          "examples": []
        }
      },
      {
        "id": "s6-4-1",
        "title": "Stream Creation",
        "explanations": {
          "english": "Java 8 mein Streams elements ki sequences represent karte hain jo sequential aur parallel aggregate operations support karte hain. Inhe collections se (stream(), parallelStream()), arrays se (Arrays.stream()), static factory methods se (Stream.of, Stream.empty, Stream.iterate, Stream.generate), I/O channels se (Files.lines), aur primitives se (IntStream, LongStream, DoubleStream) create kiya ja sakta hai. Streams lazy hote hain; computation tabhi hota hai jab terminal operation invoke hota hai. Collections ke unlike, streams data store nahi karte; yeh source se values carry karte hain operations ke pipeline ke through. Primitive streams boxing overhead avoid karte hain aur numeric methods provide karte hain (sum, average, range). Infinite streams create ki ja sakti hain iterate (seeded) ya generate (supplier-based) se, lekin collection ke liye limit() chahiye hota hai terminate karne ke liye."
        },
        "code": {
          "title": "Stream Sources",
          "language": "java",
          "content": "// From Collection\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream1 = list.stream();\nStream<String> parallelStream = list.parallelStream();\n\n// From Array\nString[] array = {\"a\", \"b\", \"c\"};\nStream<String> stream2 = Arrays.stream(array);\n\n// Static factory methods\nStream<String> stream3 = Stream.of(\"a\", \"b\", \"c\");\nStream<String> empty = Stream.empty();\nStream<String> nullable = Stream.ofNullable(getString()); // Java 9+\n\n// Infinite streams\nStream<Integer> infinite = Stream.iterate(0, n -> n + 2); // 0, 2, 4...\nStream<Integer> limited = Stream.iterate(0, n -> n < 10, n -> n + 1); // Java 9+\nStream<Double> random = Stream.generate(Math::random);\n\n// From I/O\ntry (Stream<String> lines = Files.lines(Paths.get(\"file.txt\"))) {\n    lines.forEach(System.out::println);\n}\n\n// Primitive streams (avoid boxing)\nIntStream intStream = IntStream.range(1, 100); // 1-99\nLongStream longStream = LongStream.rangeClosed(1, 100); // 1-100\nDoubleStream doubleStream = DoubleStream.of(1.0, 2.0, 3.0);"
        },
        "codeExplanations": {
          "english": "Collection.stream() sabse common source hai. Stream.of values se stream create karta hai. Stream.iterate stream create karta hai function ko repeatedly seed pe apply karke; do-arg version infinite hai, limit() chahiye hota hai. Teen-arg version (Java 9) hasNext predicate add karta hai. Stream.generate infinite streams create karta hai Supplier se. Files.lines stream lazily create karta hai file lines se aur try-with-resources mein hona chahiye. Primitive streams jaise IntStream numeric operations provide karte hain bina Integer objects box kiye."
        },
        "keyPoints": [
          "Collections: collection.stream()",
          "Arrays: Arrays.stream(array)",
          "Static: Stream.of(), Stream.iterate(), Stream.generate()",
          "I/O: Files.lines(), BufferedReader.lines()",
          "Primitives: IntStream, LongStream, DoubleStream"
        ],
        "extras": {
          "flowDiagram": "Source (Collection, Array, I/O, Generator) → Stream Pipeline → Terminal Operation",
          "comparisonTable": "Method|Stream Type|Description\nstream()|Stream<T>|Sequential collection stream\nparallelStream()|Stream<T>|Parallel collection stream\nStream.of()|Stream<T>|From elements\nStream.iterate()|Stream<T>|Infinite seeded generation\nStream.generate()|Stream<T>|Infinite supplier generation\nFiles.lines()|Stream<String>|File line stream (lazy)",
          "examples": []
        }
      },
      {
        "id": "s6-4-2",
        "title": "Intermediate Operations",
        "explanations": {
          "english": "Intermediate operations stream ko doosri stream mein transform karte hain aur lazy hote hain—yeh execute nahi hote jab tak terminal operation invoke na ho. Yeh stateless ho sakte hain (dusre elements se independent: filter, map, flatMap) ya stateful (full stream knowledge chahiye: distinct, sorted, limit, skip). Intermediate operations short-circuiting support karte hain jahan kuch elements process hone ki zaroorat nahi hoti (limit, findFirst). Multiple intermediate operations chain karke pipeline form karte hain, har ek previous ke output pe operate karta hai. Kyunki streams lazy hain aur sirf ek baar consume ho sakti hain, intermediate operations new streams return karte hain source modify karne ke badle. Common operations mein filter (predicate-based removal), map (element transformation), flatMap (stream flattening), distinct (duplication removal), aur sorted (ordering) aate hain."
        },
        "code": {
          "title": "Intermediate Operations",
          "language": "java",
          "content": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\nList<Integer> result = numbers.stream()\n    .filter(n -> n > 5)           // Keep only > 5: [6, 7, 8, 9, 10]\n    .map(n -> n * n)              // Transform: [36, 49, 64, 81, 100]\n    .limit(3)                     // Keep first 3: [36, 49, 64]\n    .sorted(Comparator.reverseOrder()) // Sort desc: [64, 49, 36]\n    .collect(Collectors.toList());\n\n// FlatMap: flatten nested structures\nList<List<Integer>> nested = Arrays.asList(\n    Arrays.asList(1, 2), \n    Arrays.asList(3, 4)\n);\nList<Integer> flat = nested.stream()\n    .flatMap(List::stream)        // Stream<Integer> instead of Stream<List<Integer>>\n    .collect(Collectors.toList()); // [1, 2, 3, 4]\n\n// Distinct and skip\nList<Integer> distinct = Stream.of(1, 2, 2, 3, 3, 3)\n    .distinct()                   // [1, 2, 3]\n    .collect(Collectors.toList());"
        },
        "codeExplanations": {
          "english": "Pipeline mein filtering dikhaya gaya hai (elements <= 5 remove karke), mapping (squaring), limiting (pehle 3 leke), aur sorting (descending). flatMap Stream<List<Integer>> ko Stream<Integer> mein flatten karta hai har list ko uske stream mein map karke aur unhe concatenate karke. Distinct duplicates remove karne ke liye equals() use karta hai. Yeh sab lazy hain—koi computation nahi hota jab tak collect() call nahi hota."
        },
        "keyPoints": [
          "Transform stream to stream; lazy evaluation",
          "Stateless: filter, map, flatMap (element independent)",
          "Stateful: distinct, sorted, limit, skip (need stream knowledge)",
          "Return new streams; source not modified"
        ],
        "extras": {
          "flowDiagram": "Source Stream → filter() → map() → sorted() → limit() → Terminal Operation\n(Lazy: nothing executes until terminal)",
          "comparisonTable": "Operation|Type|Result\nfilter|Stateless|Elements matching predicate\nmap|Stateless|Transformed elements\nflatMap|Stateless|Flattened streams\ndistinct|Stateful|Unique elements\nsorted|Stateful|Ordered elements\nlimit|Stateful|First n elements",
          "examples": []
        }
      },
      {
        "id": "s6-4-3",
        "title": "Terminal Operations",
        "explanations": {
          "english": "Terminal operations stream processing trigger karte hain aur stream consume kar lete hain, result ya side effect produce karte hain. Yeh value return kar sakte hain (single value: findFirst, findAny, reduce, count; ya collection: collect, toArray), side effects perform kar sakte hain (forEach, forEachOrdered), ya properties check kar sakte hain (anyMatch, allMatch, noneMatch). Ek baar terminal operation invoke ho jane ke baad, stream invalid ho jati hai aur reuse nahi ho sakti (aapko source se new stream create karni padti hai). Short-circuiting terminal operations (findFirst, anyMatch, limit) sirf stream ka part process kar sakte hain. Reduction operations (reduce, collect) elements ko result mein combine karte hain. collect operation Collectors use karta hai complex aggregations ke liye (grouping, partitioning, joining), jisse yeh sabse flexible terminal operation ban jata hai."
        },
        "code": {
          "title": "Terminal Operations",
          "language": "java",
          "content": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Reductions\nint sum = numbers.stream().reduce(0, Integer::sum); // 15\nOptional<Integer> max = numbers.stream().reduce(Integer::max);\nlong count = numbers.stream().count();\n\n// Collection\nList<Integer> doubled = numbers.stream()\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\nString joined = numbers.stream()\n    .map(String::valueOf)\n    .collect(Collectors.joining(\", \")); // \"1, 2, 3, 4, 5\"\n\n// Matching\nboolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);\nboolean allPositive = numbers.stream().allMatch(n -> n > 0);\n\n// Finding\nOptional<Integer> first = numbers.stream().findFirst();\nOptional<Integer> any = numbers.stream().parallel().findAny();\n\n// Side effects\nnumbers.stream().forEach(System.out::println);"
        },
        "codeExplanations": {
          "english": "reduce elements ko accumulator ke saath combine karta hai (0 identity hai). collect results ko collections ya strings mein gather karta hai. Matching operations predicates ke basis pe boolean return karte hain. findFirst pehla element return karta hai encounter order mein; findAny parallel streams ke liye zyada flexible hai. forEach ek terminal side-effect operation hai intermediate peek() ke unlike. Koi bhi terminal operation ke baad, stream close ho jati hai aur reuse nahi ho sakti."
        },
        "keyPoints": [
          "Trigger execution and consume the stream",
          "Types: Reduction (reduce), Collection (collect), Matching (anyMatch), Finding (findFirst), Iteration (forEach)",
          "Stream cannot be reused after terminal operation",
          "Short-circuiting: findFirst, anyMatch may not process entire stream"
        ],
        "extras": {
          "flowDiagram": "Intermediate Ops (lazy) → Terminal Op → Stream consumed → Result produced",
          "comparisonTable": "Operation|Returns|Short-circuit|Produces\ncollect|Collection/Value|No|Aggregated result\nreduce|Value|No|Combined value\nforEach|void|No|Side effects\nfindFirst|Optional|Yes|First element\nanyMatch|boolean|Yes|true if any match",
          "examples": []
        }
      },
      {
        "id": "s6-4-4",
        "title": "Parallel Streams Overview",
        "explanations": {
          "english": "Parallel streams multi-core CPUs ka leverage karte hain stream ko automatically partition karke, chunks ko concurrently common ForkJoinPool mein process karke, aur results combine karke. Parallel mein convert karo stream.parallel() se ya create karo collection.parallelStream() se. Parallelism CPU-intensive operations mein benefit karta hai large datasets pe (typically >10,000 elements), lekin task coordination ka overhead add karta hai jo small streams ko slow kar sakta hai. Correctness ke liye thread-safe operations chahiye, mutable shared state avoid karna chahiye, aur associative non-interfering lambdas chahiye. Stateful intermediate operations (sorted, distinct) aur encounter-order-sensitive operations (findFirst, limit) poorly perform kar sakte hain ya additional coordination chahiye ho sakti hai. Hamesha performance measure karo—parallel streams automatically faster nahi hote aur splitting overhead aur cache contention ki wajah se performance degrade kar sakte hain."
        },
        "code": {
          "title": "Parallel Stream Usage",
          "language": "java",
          "content": "List<Integer> numbers = new ArrayList<>();\nfor (int i = 1; i <= 1_000_000; i++) {\n    numbers.add(i);\n}\n\n// Sequential vs Parallel\nlong sumSequential = numbers.stream()\n    .mapToLong(n -> n * n)\n    .sum();\n\nlong sumParallel = numbers.parallelStream() // or .stream().parallel()\n    .mapToLong(n -> n * n)\n    .sum();\n\n// Wrong: mutable shared state (race conditions!)\nList<Integer> result = new ArrayList<>();\nnumbers.parallelStream().forEach(result::add); // ConcurrentModificationException possible\n\n// Correct: use collect to merge results\nList<Integer> resultCorrect = numbers.parallelStream()\n    .map(n -> n * n)\n    .collect(Collectors.toList()); // Thread-safe merging\n\n// Custom ForkJoinPool (advanced)\nForkJoinPool customPool = new ForkJoinPool(4);\ntry {\n    customPool.submit(() ->\n        numbers.parallelStream().map(...).collect(...)\n    ).get();\n} catch (Exception e) {\n    e.printStackTrace();\n} finally {\n    customPool.shutdown();\n}"
        },
        "codeExplanations": {
          "english": "parallelStream() automatically million-element list ko CPU cores mein split karta hai. Wrong example mein common mistake dikhaya gaya hai shared ArrayList ko parallel threads se mutate karne ki, jisse data races hote hain. Correct approach collect() use karta hai jo parallel threads se results ko thread-safe merge karta hai. Custom ForkJoinPool parallelism level control karne allow karta hai (default availableProcessors hota hai)."
        },
        "keyPoints": [
          "Enable with parallelStream() or stream.parallel()",
          "Uses ForkJoinPool.commonPool() (threads = availableProcessors)",
          "Good for: large datasets, CPU-intensive operations, stateless operations",
          "Bad for: small datasets, blocking I/O, mutable shared state"
        ],
        "extras": {
          "flowDiagram": "Sequential: Single thread processes all elements\nParallel: Stream split → Multiple threads process chunks → Results combined",
          "comparisonTable": "Aspect|Sequential|Parallel\nThreading|Single|Multiple (ForkJoinPool)\nBest for|Small data, ordered ops|Large data, math-heavy\nThread safety|Not required|Required\nPerformance|Predictable|Measure first (overhead exists)",
          "examples": []
        }
      },
      {
        "id": "s6-5-1",
        "title": "Avoiding NullPointerException",
        "explanations": {
          "english": "Optional<T>, Java 8 mein introduce hua, ek container object hai jo ho sakta hai contain kare non-null value ya na bhi kare, NullPointerExceptions reduce karne ke liye design kiya gaya hai absent values ko explicit handle karke. Null return karne ke badle (jo bhool sakta hai aur NPE cause kar sakta hai), methods return karte hain Optional.empty() ya Optional.of(value). Callers ko explicitly choose karna padta hai ki empty hone pe kya karna hai: default provide karna (orElse), exception throw karna (orElseThrow), ya transform karna agar present ho (map). Optional null eliminate nahi karta lekin type-safe way provide karta hai potential absence indicate karne ke liye. Ishe primarily return type ki tarah use karna chahiye methods ke liye jo shayad value return na karein; fields ya method parameters ke liye use karna generally discouraged hai kyunki yeh unnecessary wrapper overhead aur complexity add karta hai."
        },
        "code": {
          "title": "Optional vs Null",
          "language": "java",
          "content": "// Old way - risk of NPE\npublic String findUserNameOld(String id) {\n    User user = findUser(id); // might return null\n    return user.getName().toUpperCase(); // NPE if user or name is null!\n}\n\n// New way with Optional\npublic Optional<String> findUserName(String id) {\n    return Optional.ofNullable(findUser(id))\n        .map(User::getName)\n        .map(String::toUpperCase);\n}\n\n// Handling the Optional\nOptional<String> nameOpt = findUserName(\"123\");\nnameOpt.ifPresent(System.out::println); // Only prints if present\n\n// Providing defaults\nString name = nameOpt.orElse(\"Unknown\"); // Static default\nString name2 = nameOpt.orElseGet(() -> fetchNameExpensively()); // Supplier\nString name3 = nameOpt.orElseThrow(() -> new NotFoundException(\"User not found\"));\n\n// Filtering\nOptional<String> longName = nameOpt.filter(n -> n.length() > 5);"
        },
        "codeExplanations": {
          "english": "Optional.ofNullable potentially null value ko wrap karta hai. map value ko transform karta hai agar present ho (empty Optional return karta hai agar input empty tha). ifPresent consumer execute karta hai sirf tab jab value exist karti hai. orElse fallback provide karta hai; orElseGet expensive computation defer karta hai jab tak zaroorat na ho; orElseThrow empty ko exception mein convert karta hai. filter empty return karta hai agar predicate match nahi karta, jisse chained constraints enable hote hain."
        },
        "keyPoints": [
          "Container for value that may be absent (null-safe alternative)",
          "Use as return type for methods that may not have result",
          "Forces explicit handling of empty case",
          "of(value) for non-null, ofNullable(value) for possibly null, empty() for absent"
        ],
        "extras": {
          "flowDiagram": "Method returns Optional → Caller must check:\n    → isPresent()?\n        Yes: get() value\n        No: orElse(), orElseThrow(), or ignore safely",
          "comparisonTable": "Method|When Null in Source\nOptional.of(null)|Throws NPE immediately\nOptional.ofNullable(null)|Returns Optional.empty()\nOptional.empty()|Returns empty explicitly",
          "examples": []
        }
      },
      {
        "id": "s6-5-2",
        "title": "Proper Usage Patterns",
        "explanations": {
          "english": "Proper Optional usage ishe return type ki tarah emphasize karta hai code ke liye jo shayad result produce na kare, general null replacement ki tarah nahi. Avoid karo Optional use karna fields mein (serialization issues, memory overhead), method parameters mein (callers ke liye awkward, multiple wrapping), ya collections mein (empty collection use karo instead). Kabhi bhi get() call mat karo bina isPresent() check kiye; prefer karo orElse, orElseGet, ya ifPresent. Use karo map aur flatMap operations ko safe chaining ke liye jo Optionals return karte hain. flatMap Optional<Optional<T>> ko Optional<T> mein flatten karta hai. ifPresentOrElse (Java 9+) present aur empty dono cases handle karta hai. Stream integration stream() method ke through (Java 9) allow karta hai Optional ko 0-or-1 element stream ki tarah treat karne ke liye seamless Stream API integration ke liye."
        },
        "code": {
          "title": "Best Practice Patterns",
          "language": "java",
          "content": "// Chaining operations safely\nOptional<Customer> customer = findCustomer(id);\nOptional<Order> order = customer\n    .flatMap(Customer::getLastOrder) // Returns Optional<Order>\n    .filter(o -> o.getTotal() > 100);\n\n// Null-safe chaining with defaults\nString city = findCustomer(id)\n    .flatMap(Customer::getAddress)\n    .map(Address::getCity)\n    .orElse(\"Unknown City\");\n\n// ifPresentOrElse (Java 9+)\nfindCustomer(id).ifPresentOrElse(\n    c -> System.out.println(\"Found: \" + c.getName()),\n    () -> System.out.println(\"Not found\")\n);\n\n// Stream integration (Java 9+)\nList<String> cities = customerIds.stream()\n    .map(this::findCustomer) // Stream<Optional<Customer>>\n    .flatMap(Optional::stream) // Stream<Customer> (filters empty)\n    .map(Customer::getCity)\n    .collect(Collectors.toList());\n\n// BAD: Never do this\nOptional<String> badField; // Don't use as field\nvoid badParam(Optional<String> param) { } // Don't use as parameter\nString value = opt.get(); // Dangerous without isPresent()"
        },
        "codeExplanations": {
          "english": "flatMap methods handle karta hai jo Optional return karte hain (Optional<Optional<...>> nesting avoid karne ke liye). City example deep null-safe navigation dikhata hai. ifPresentOrElse if-else blocks replace karta hai. Optional.stream() empty ko 0 elements mein convert karta hai, present ko 1 element mein, jisse flatMap empties ko automatically filter kar sake. Bad examples anti-patterns dikhate hain: fields (serialization issues, overhead), parameters (awkward boxing), aur unsafe get()."
        },
        "keyPoints": [
          "Use as return type only; avoid fields and parameters",
          "Never call get() without isPresent() check",
          "Use map/flatMap for safe chaining",
          "stream() method integrates with Stream API (Java 9)"
        ],
        "extras": {
          "flowDiagram": "Optional Chain:\nOptional<Customer> → flatMap(getAddress) → Optional<Address> → map(getCity) → Optional<String> → orElse(default)",
          "comparisonTable": "Method|Use Case\nmap|Transform value if present\nflatMap|Chain methods returning Optional\nifPresent|Side effect if present\nifPresentOrElse|Dual handling (Java 9)\nstream|Convert to 0-1 element Stream",
          "examples": []
        }
      },
      {
        "id": "s6-5-3",
        "title": "Anti-patterns",
        "explanations": {
          "english": "Common Optional anti-patterns iska purpose undermine karte hain aur null checks se bhi bura code create karte hain. isPresent() ke baad get() verbose hai aur null checks se behtar nahi; instead orElse ya orElseThrow use karo. Optional fields mein use karna serialize karta hai poorly (early Java 8 mein Serializable nahi tha, baad mein fix hua lekin still awkward) aur object overhead double kar deta hai. Method parameters Optional mein wrapped callers ko annoy karte hain jo arguments wrap karna padta hai. Optionals create karna via new Optional<>() (constructor) galat hai; factory methods use karo. Optionals serialize karna ya unhe Map keys/values ki tarah use karna complexity add karta hai. Optional ko == Optional.empty() se test karna isPresent() ya isEmpty() ki jagah kaam karta hai lekin less readable hai. Sabse bura anti-pattern: Optional use karna nulls chhupane ke liye bina underlying null-producing code ko fix kiye."
        },
        "code": {
          "title": "Avoiding Bad Practices",
          "language": "java",
          "content": "// BAD: isPresent() + get() (verbose null-check equivalent)\nif (opt.isPresent()) {\n    return opt.get();\n} else {\n    return \"default\";\n}\n// GOOD: \nreturn opt.orElse(\"default\");\n\n// BAD: Optional as field\npublic class User {\n    private Optional<String> nickname; // Don't do this\n}\n// GOOD:\nprivate String nickname; // Null if absent\n\n// BAD: Optional parameter\npublic void process(Optional<String> data) { }\n// GOOD: Overloading or null with documentation\npublic void process(String data) { } // null means absent\n\n// BAD: Testing equality to empty\nif (opt == Optional.empty()) { }\n// GOOD:\nif (opt.isEmpty()) { } // Java 11+ or !opt.isPresent()\n\n// BAD: Creating with constructor ( compilation error anyway)\n// Optional<String> o = new Optional<>(); // Won't compile\n\n// BAD: Wrapping without checking\nOptional.of(null); // Throws NPE - use ofNullable"
        },
        "codeExplanations": {
          "english": "isPresent/get pattern verbose hai aur fluent benefits lose kar deta hai. Optional fields double memory karte hain (Optional + String objects) aur serialization complicate kar dete hain. Optional parameters force karte hain callers ko values awkwardly wrap karne ke liye. Reference equality Optional.empty() se kaam karta hai (yeh singleton hai) lekin idiomatically galat hai; use karo isEmpty() (Java 11) ya !isPresent(). Hamesha ofNullable use karo jab value null ho sakti hai."
        },
        "keyPoints": [
          "Don't use isPresent() + get(); use orElse/orElseGet/orElseThrow",
          "Don't use as fields or parameters",
          "Don't use == Optional.empty(); use isEmpty()",
          "Don't use constructor; use of/ofNullable/empty factories",
          "Don't use Optional to avoid fixing null-returning methods"
        ],
        "extras": {
          "flowDiagram": "Anti-pattern Detection:\nopt.isPresent()? opt.get() : default → Replace with opt.orElse()\nfield: Optional<Type> → Replace with Type (null allowed)\nmethod(Optional<T>) → Replace with method(T) + null check",
          "comparisonTable": "Anti-Pattern|Better Alternative\nisPresent()? get() : value|orElse(value)\nOptional field|T field (null)\nOptional parameter|T parameter + validation\nnew Optional()|Optional.empty()/of()/ofNullable()\n== Optional.empty()|isEmpty() or !isPresent()",
          "examples": []
        }
      },
      {
        "id": "s6-6-1",
        "title": "LocalDate",
        "explanations": {
          "english": "LocalDate date represent karta hai bina time ya timezone ke, jaise '2024-03-15', ISO-8601 calendar system mein (year-month-day). Yeh immutable aur thread-safe hai, suitable hai birth dates, hire dates, ya kisi bhi date-only value ke liye. Key methods mein now() current date ke liye, of() specific dates ke liye, plusDays/plusWeeks/plusMonths/plusYears arithmetic ke liye, aur withDayOfMonth/withMonth/withYear adjustments ke liye hain. LocalDate DayOfWeek aur Month enums provide karta hai day/month queries ke liye. Yeh leap years correctly handle karta hai (February 29 sirf leap years mein validate hota hai). Period represent karta hai difference do LocalDates ke beech mein years, months, aur days mein. LocalDate serializable aur comparable hai, comprehensive toString aur parsing support ke saath DateTimeFormatter ke through."
        },
        "code": {
          "title": "LocalDate Operations",
          "language": "java",
          "content": "// Creation\nLocalDate today = LocalDate.now();\nLocalDate specific = LocalDate.of(2024, 3, 15);\nLocalDate parsed = LocalDate.parse(\"2024-03-15\");\n\n// Querying\nint year = today.getYear();\nMonth month = today.getMonth(); // Month enum\nint day = today.getDayOfMonth();\nDayOfWeek dow = today.getDayOfWeek(); // MONDAY, etc.\nboolean leap = today.isLeapYear();\n\n// Arithmetic (returns new object, immutable)\nLocalDate tomorrow = today.plusDays(1);\nLocalDate nextMonth = today.plusMonths(1);\nLocalDate previousWeek = today.minusWeeks(1);\n\n// Adjustment (returns new object)\nLocalDate firstDayOfMonth = today.withDayOfMonth(1);\nLocalDate lastDayOfMonth = today.withDayOfMonth(today.lengthOfMonth());\n\n// Comparison\nboolean isBefore = today.isBefore(specific);\nboolean isAfter = today.isAfter(specific);\n\n// Period between dates\nPeriod period = Period.between(specific, today);\nint years = period.getYears();\nint months = period.getMonths();"
        },
        "codeExplanations": {
          "english": "LocalDate create hota hai now(), factory of(), ya parsing se. Yeh Month aur DayOfWeek enums use karta hai magic numbers ki jagah. Saare arithmetic methods new LocalDate instances return karte hain (immutable). Period dates ke beech mein calendar-based difference calculate karta hai (1 year, 2 months, 3 days) absolute days ki jagah. withXxx methods specific fields adjust karte hain baaki ko constant rakhte hue."
        },
        "keyPoints": [
          "Date-only (no time, no timezone)",
          "Immutable and thread-safe",
          "Handles leap years and varying month lengths",
          "Use Period for date-based differences, Duration for time-based"
        ],
        "extras": {
          "flowDiagram": "LocalDate.now() → 2024-01-15\n    .plusDays(5) → 2024-01-20\n    .plusMonths(1) → 2024-02-20\n    .withDayOfMonth(1) → 2024-02-01",
          "comparisonTable": "Legacy (java.util.Date)|Modern (LocalDate)\nMutable|Immutable\nIncludes time|Date only\nTimezone dependent|Zone-less\nJan=0|Jan=1 (sensible)",
          "examples": []
        }
      },
      {
        "id": "s6-6-2",
        "title": "LocalDateTime",
        "explanations": {
          "english": "LocalDateTime date aur time represent karta hai bina timezone ke, jaise '2024-03-15T10:30:00', LocalDate aur LocalTime ko combine karke. Yeh suitable hai local event times ke liye (jaise 3 PM ko appointment) jahan timezone separately handle hota hai ya implied hota hai, ya timestamps ke liye jab zone unknown ya irrelevant ho. Yeh similar arithmetic methods provide karta hai LocalDate jaisa lekin time components ke liye (plusHours, plusMinutes, plusSeconds) aur combined adjustments. atZone() method isse ZonedDateTime mein convert karta hai timezone add karke, jabki toLocalDate() aur toLocalTime() components extract karte hain. LocalDateTime nano-of-second precision truncate karta hai aur truncation methods offer karta hai (truncatedTo(ChronoUnit.MINUTES)). Yeh same immutability aur thread-safety guarantees follow karta hai jaise baaki java.time types."
        },
        "code": {
          "title": "LocalDateTime Usage",
          "language": "java",
          "content": "// Creation\nLocalDateTime now = LocalDateTime.now();\nLocalDateTime meeting = LocalDateTime.of(2024, 3, 15, 14, 30);\nLocalDateTime parsed = LocalDateTime.parse(\"2024-03-15T14:30:00\");\n\n// Extract components\nLocalDate date = now.toLocalDate();\nLocalTime time = now.toLocalTime();\n\n// Time arithmetic\nLocalDateTime later = now.plusHours(2).plusMinutes(30);\nLocalDateTime truncated = now.truncatedTo(ChronoUnit.HOURS); // Drop minutes\n\n// Combining with Zone\nZonedDateTime zoned = now.atZone(ZoneId.of(\"America/New_York\"));\nInstant instant = now.atZone(ZoneId.systemDefault()).toInstant();\n\n// Comparisons and between\nDuration duration = Duration.between(meeting, now);\nlong minutes = duration.toMinutes();"
        },
        "codeExplanations": {
          "english": "LocalDateTime date aur time operations combine karta hai. atZone timezone info add karta hai ZonedDateTime create karne ke liye, jo Instant (timestamp) mein convert ho sakta hai. truncatedTo specified precision pe round down karta hai. Duration do temporals ke beech mein exact time difference measure karta hai (hours/minutes/seconds return karta hai), jabki Period calendar units measure karta hai."
        },
        "keyPoints": [
          "Date and time without timezone",
          "Use for local event times, appointments",
          "Convert to ZonedDateTime with atZone(zone) for absolute instant",
          "Duration for time-based differences, Period for date-based"
        ],
        "extras": {
          "flowDiagram": "LocalDateTime → atZone(ZoneId) → ZonedDateTime → toInstant() → Instant (absolute timestamp)",
          "comparisonTable": "Class|Contains|Use Case\nLocalDate|Date only|Birthdays, holidays\nLocalTime|Time only|Business hours\nLocalDateTime|Date + Time|Local appointment\nZonedDateTime|Date + Time + Zone|Global timestamps\nInstant|Timestamp|Machine time, logging",
          "examples": []
        }
      },
      {
        "id": "s6-6-3",
        "title": "ZonedDateTime",
        "explanations": {
          "english": "ZonedDateTime date aur time represent karta hai timezone offset aur zone rules ke saath, jaise '2024-03-15T10:30:00+01:00[Europe/Paris]'. Yeh daylight saving time (DST) transitions aur historical zone changes handle karta hai ZoneId rules ke through. ZonedDateTime fully aware hai global time ki complexities se, correctly convert karta hai zones ke beech mein withZoneSameInstant() ya withZoneSameLocal() se. ZoneId timezone identifier represent karta hai (jaise 'America/New_York'), jabki ZoneOffset UTC se offset represent karta hai (jaise '+05:30'). Overlap (fall back) ya gap (spring forward) transitions ke dauran, ZonedDateTime appropriately resolve karta hai (jaise overlap mein earlier offset choose karna). Yeh Instant (absolute point in timeline) mein convert hota hai toInstant() se, aur LocalDateTime se atZone() ya of() se."
        },
        "code": {
          "title": "Timezone Handling",
          "language": "java",
          "content": "// Creation\nZonedDateTime meetingInNY = ZonedDateTime.now(ZoneId.of(\"America/New_York\"));\nZonedDateTime meetingInTokyo = ZonedDateTime.of(\n    2024, 3, 15, 14, 0, 0, 0, \n    ZoneId.of(\"Asia/Tokyo\")\n);\n\n// Zone conversion\nZonedDateTime sameInstantInLondon = meetingInNY.withZoneSameInstant(\n    ZoneId.of(\"Europe/London\")\n);\n// Adjusts time to represent same point in timeline\n\n// Keep local time, change zone (rarely correct)\nZonedDateTime differentInstant = meetingInNY.withZoneSameLocal(\n    ZoneId.of(\"Europe/London\")\n);\n\n// Get components\nZoneId zone = meetingInNY.getZone();\nZoneOffset offset = meetingInNY.getOffset();\nInstant instant = meetingInNY.toInstant(); // Absolute timestamp\n\n// DST handling\nZonedDateTime beforeDST = ZonedDateTime.of(\n    2024, 3, 10, 2, 30, 0, 0, \n    ZoneId.of(\"America/New_York\")\n); // Illegal time (spring forward) resolves to 3:30 AM"
        },
        "codeExplanations": {
          "english": "withZoneSameInstant time ko doosri zone mein convert karta hai same actual moment represent karne ke liye (jaise 9am NY = 2pm London). withZoneSameLocal clock time digits same rakhta hai lekin zone change kar deta hai (usually galat unless specifically intended). DST gaps (spring forward) aur overlaps (fall back) zone rules se handle hote hain. toInstant absolute timestamp deta hai storage ya transmission ke liye."
        },
        "keyPoints": [
          "Date + Time + Zone offset + Zone rules",
          "Handles DST transitions automatically",
          "Use withZoneSameInstant to convert between timezones",
          "Convert to Instant for absolute timestamps (database storage)"
        ],
        "extras": {
          "flowDiagram": "ZonedDateTime (NY 9:00 AM EST)\n    ↓ withZoneSameInstant(London)\nZonedDateTime (London 2:00 PM GMT)\n    ↓\nInstant (same absolute time)",
          "comparisonTable": "Method|Effect\nwithZoneSameInstant|Convert time to show same moment in new zone\nwithZoneSameLocal|Change zone but keep same clock digits\nofInstant|Create from Instant + ZoneId\ntoInstant|Convert to absolute timestamp",
          "examples": []
        }
      },
      {
        "id": "s6-6-4",
        "title": "Formatting & Parsing",
        "explanations": {
          "english": "DateTimeFormatter thread-safe formatting aur parsing provide karta hai java.time objects ke liye, non-thread-safe SimpleDateFormat ko replace karke. Predefined formats mein ISO_LOCAL_DATE ('2024-03-15'), ISO_LOCAL_DATE_TIME, aur ISO_ZONED_DATE_TIME hain. Custom patterns symbols use karte hain jaise yyyy (year), MM (month), dd (day), HH (hour), mm (minute), ss (second), aur a (am/pm). Formatter case-sensitive parsing aur strict/resolver styles perform kar sakta hai. DateTimeFormatterBuilder complex formatters build karne allow karta hai optional sections aur literal text ke saath. Localized formatting ke liye, use karo ofLocalizedDate(), ofLocalizedTime(), ya ofLocalizedDateTime() FormatStyle ke saath (FULL, LONG, MEDIUM, SHORT). Parsing parse() methods use karta hai with or without explicit formatter (defaults to ISO)."
        },
        "code": {
          "title": "DateTimeFormatter Usage",
          "language": "java",
          "content": "// Predefined formatters\nLocalDate date = LocalDate.now();\nString iso = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2024-03-15\n\n// Custom pattern\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\n    \"EEEE, MMMM d, yyyy\", // Thursday, March 15, 2024\n    Locale.US\n);\nString formatted = date.format(formatter);\n\n// Parsing with pattern\nLocalDate parsed = LocalDate.parse(\n    \"15/03/2024\", \n    DateTimeFormatter.ofPattern(\"dd/MM/yyyy\")\n);\n\n// Zoned formatting\nZonedDateTime zdt = ZonedDateTime.now();\nString zonedStr = zdt.format(DateTimeFormatter.RFC_1123_DATE_TIME);\n\n// Localized\nString localized = date.format(\n    DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)\n    .withLocale(Locale.FRANCE)\n);\n\n// Builder for complex patterns\nDateTimeFormatter complex = new DateTimeFormatterBuilder()\n    .appendText(ChronoField.YEAR)\n    .appendLiteral(\" year, \")\n    .appendText(ChronoField.MONTH_OF_YEAR)\n    .toFormatter();"
        },
        "codeExplanations": {
          "english": "DateTimeFormatter.ofPattern custom patterns ke saath formatters create karta hai (case sensitive: MM=month, mm=minute). Hamesha Locale specify karo month/day names ke liye. parse() se parsing ke liye string ko pattern se exactly match karna padta hai. ofLocalizedDate locale-specific conventions use karta hai. DateTimeFormatterBuilder fine-grained control provide karta hai complex requirements ke liye. Saare java.time formatters immutable aur thread-safe hain, SimpleDateFormat ke unlike."
        },
        "keyPoints": [
          "Thread-safe (unlike SimpleDateFormat)",
          "Predefined ISO formatters available",
          "Custom patterns: yyyy-MM-dd HH:mm:ss",
          "Always specify Locale for localized text"
        ],
        "extras": {
          "flowDiagram": "Temporal Object → Formatter.format() → String\nString → Formatter.parse() → Temporal Object",
          "comparisonTable": "Pattern|Meaning\nyyyy|4-digit year\nMM|Month number (01-12)\ndd|Day of month (01-31)\nHH|Hour (00-23)\nmm|Minute (00-59)\nss|Second (00-59)\na|AM/PM marker",
          "examples": []
        }
      },
      {
        "id": "s6-7-1",
        "title": "When to Use Parallel Streams",
        "explanations": {
          "english": "Parallel streams performance benefits sirf specific conditions mein provide karte hain: large data sources (typically 10,000-100,000 elements se zyada depending on operation complexity), CPU-intensive operations (complex math, object creation), aur stateless, side-effect-free operations. Yeh degrade karte hain performance small collections ke liye task-splitting overhead ki wajah se, I/O-bound operations ke liye (common pool block karta hai), ya jab encounter-order required ho (parallel mein costly maintain karna). Stateless operations (filter, map) achha parallelize hote hain; stateful operations (distinct, sorted) additional coordination chahiye hote hain. Source structures matter karti hain: ArrayList, IntStream.range, aur arrays efficiently split hote hain; Stream.iterate, Stream.of, aur LinkedList poorly split hote hain. Hamesha performance measure karo parallelization se pehle aur baad mein; anecdotal assumptions speedups ke baare mein often galat hote hain poor decomposition ya cache contention ki wajah se."
        },
        "code": {
          "title": "Parallel Decision Guide",
          "language": "java",
          "content": "// GOOD: Large data, CPU intensive\nlong count = IntStream.range(0, 10_000_000)\n    .parallel()\n    .filter(this::isPrime)\n    .count();\n\n// GOOD: Stateless operations on good source\nList<Integer> result = largeArrayList.parallelStream()\n    .map(this::expensiveComputation)\n    .collect(Collectors.toList());\n\n// BAD: Too small\nList<Integer> small = Arrays.asList(1, 2, 3);\nsmall.parallelStream().map(n -> n * 2); // Overhead exceeds benefit\n\n// BAD: Stateful/ordered expensive operations\nStream.iterate(0, n -> n + 1)\n    .limit(1000)\n    .parallel() // Bad: iterate doesn't split well\n    .distinct() // Expensive in parallel\n    .collect(Collectors.toList());\n\n// BAD: I/O blocking\nurls.parallelStream() // Blocks common pool!\n    .map(this::fetchUrl)\n    .collect(Collectors.toList());"
        },
        "codeExplanations": {
          "english": "Good examples large datasets dikhate hain CPU-intensive operations ke saath (isPrime checking, expensive transformation). Bad examples demonstrate karte hain: small collections jahan splitting overhead dominate karta hai, Stream.iterate jo poor splitting structure create karta hai (sequential dependency), aur blocking I/O jo ForkJoinPool ko starve karta hai. Parallel streams common ForkJoinPool use karte hain (thread count = CPU cores), isliye blocking operations saare parallel streams ko application mein freeze kar dete hain."
        },
        "keyPoints": [
          "Use for: Large datasets (>10k elements), CPU-intensive operations",
          "Avoid for: Small collections, blocking I/O, stateful ops (sorted, distinct), poor sources (iterate, linked lists)",
          "Measure performance; parallel is not automatically faster",
          "Side-effect-free operations only"
        ],
        "extras": {
          "flowDiagram": "Large Data + CPU Bound + Stateless = Good for Parallel\nSmall Data + IO Bound + Stateful (sort) = Bad for Parallel",
          "comparisonTable": "Factor|Good for Parallel|Bad for Parallel\nData Size|Large (>10k)|Small (<1k)\nOperation|Computation heavy|Simple, fast\nSource|ArrayList, arrays, IntStream.range|LinkedList, Stream.iterate, Stream.of\nState|Stateless|Stateful (distinct, sorted)",
          "examples": []
        }
      },
      {
        "id": "s6-7-2",
        "title": "Performance Considerations",
        "explanations": {
          "english": "Parallel stream performance NQ model pe depend karti hai: data size (N) aur computation cost per element (Q) ka product high enough hona chahiye splitting overhead overcome karne ke liye (typically N*Q > 10,000). Poorly decomposable sources (iterators, linked lists, Stream.of) imbalanced splits create karte hain jahan threads idle wait karti hain. Boxing primitives (Stream<Integer> vs IntStream) memory overhead aur cache misses cause karta hai; hamesha primitive streams (IntStream, LongStream) use karo numeric computation ke liye. Interference (stream source modify karna operation ke dauran) ConcurrentModificationException ya wrong results cause karta hai. Stateless side-effect-free lambdas optimal parallelization allow karte hain; stateful lambdas (synchronized, shared variables modify karna) contention create karte hain jo parallelism benefits eliminate kar deta hai. ForkJoinPool.common.parallelism (default CPU count - 1) limit karta hai concurrent threads jo saare parallel streams ke liye available hain JVM mein."
        },
        "code": {
          "title": "Performance Optimization",
          "language": "java",
          "content": "// Good: Primitive stream avoids boxing\nint sum = IntStream.range(0, 1_000_000)\n    .parallel()\n    .map(n -> n * n)\n    .sum();\n\n// Bad: Boxing overhead\nStream<Integer> boxed = IntStream.range(0, 1_000_000)\n    .boxed(); // Avoid if possible in parallel\n\n// Bad: Contended shared state\nList<Integer> results = new ArrayList<>();\nIntStream.range(0, 1000).parallel()\n    .forEach(results::add); // Race conditions, resizing overhead\n\n// Good: Proper merging with collect\nList<Integer> resultsSafe = IntStream.range(0, 1000).parallel()\n    .mapToObj(n -> n)\n    .collect(Collectors.toList()); // Thread-safe merging\n\n// Bad: LinkedList splitting\nLinkedList<Integer> linked = new LinkedList<>(largeList);\nlinked.parallelStream() // Splits poorly, cache misses\n    .map(...) \n    .collect();\n\n// Good: ArrayList splitting\nArrayList<Integer> array = new ArrayList<>(largeList);\narray.parallelStream() // Splits evenly, cache friendly\n    .map(...)\n    .collect();"
        },
        "codeExplanations": {
          "english": "Primitive IntStream Integer boxing overhead avoid karta hai. Collectors thread-safe merging handle karte hain partial results ka parallel threads se efficiently. forEach concurrent collection modification ke saath thread-safety issues cause karta hai; collect proper hai parallel gathering ke liye. ArrayList evenly split hota hai index ranges se, jabki LinkedList traversal chahiye split karne ke liye, jisse uneven work distribution aur poor cache locality hoti hai."
        },
        "keyPoints": [
          "Use primitive streams (IntStream) to avoid boxing overhead",
          "Ensure N*Q (size * cost) > 10,000 for benefit",
          "Avoid shared mutable state in lambdas",
          "Use ArrayList/arrays not LinkedList for sources",
          "Use collect() not forEach() for aggregating parallel results"
        ],
        "extras": {
          "flowDiagram": "Parallel Stream Splitting:\nArrayList [0-999] → [0-499], [500-999] → Fast split\nLinkedList → Must traverse to find middle → Slow split",
          "comparisonTable": "Aspect|Impact|Solution\nBoxing|Memory/cache overhead|Use IntStream/LongStream\nBad split|Uneven work|Use ArrayList, arrays\nShared state|Contention|Pure functions only\nWrong terminal|Missed optimizations|Use reduce, collect not forEach",
          "examples": []
        }
      },
      {
        "id": "s6-7-3",
        "title": "Common Pitfalls",
        "explanations": {
          "english": "Common parallel stream pitfalls mein include stream source modify karna traversal ke dauran (ConcurrentModificationException), thread-unsafe operations use karna forEach mein (race conditions), aur automatic speedup assume karna bina measure kiye. Blocking operations (I/O, sleep) parallel streams mein ForkJoinPool monopolize karte hain, starving other parallel streams application mein—ek critical issue web servers mein. Tasks jo bohot small hain splitting overhead create karte hain computation benefit se zyada. Non-associative reduce operations (subtraction, string concatenation without ordering) wrong results produce karte hain parallel mein kyunki operation order guaranteed nahi hai. Encounter order assume karna ki cheaply preserve hoti hai parallel mein (yeh expensive hai ordered streams ke liye jaise Stream.of ya List.stream); forEachOrdered sparingly use karo. Debugging parallel streams sequential se harder hai indeterminate ordering aur concurrent modifications ki wajah se."
        },
        "code": {
          "title": "Avoiding Pitfalls",
          "language": "java",
          "content": "// PITFALL 1: Modifying source during stream\nList<Integer> list = new ArrayList<>...\nlist.parallelStream()\n    .forEach(list::remove); // ConcurrentModificationException!\n\n// PITFALL 2: Non-associative reduce\nint wrong = IntStream.range(0, 10).parallel()\n    .reduce(0, (a, b) -> a - b); // (0-1-2-3...) order undefined result!\n\n// PITFALL 3: Blocking common pool\nList<String> data = fetchUrls();\ndata.parallelStream()\n    .map(url -> fetchFromNetwork(url)) // Blocks all parallel streams!\n    .collect(Collectors.toList());\n\n// Solution: Custom ForkJoinPool for blocking\nForkJoinPool custom = new ForkJoinPool(2);\ntry {\n    custom.submit(() ->\n        data.parallelStream().map(...).collect(...)\n    ).get();\n} finally {\n    custom.shutdown();\n}\n\n// PITFALL 4: forEachOrdered overhead\nStream.of(\"a\", \"b\", \"c\").parallel()\n    .map(...) // Parallel\n    .forEachOrdered(System.out::println); // Expensive reorder barrier"
        },
        "codeExplanations": {
          "english": "List modify karna while iterating in stream cause karta hai ConcurrentModificationException parallel mein bhi. Subtraction associative nahi hai (a-b-c != (a-b)-c), isliye parallel reduction galat answers deta hai. Network calls common ForkJoinPool use nahi karni chahiye kyunki yeh threads block karte hain jo other parallel streams ko chahiye hote hain; custom pool use karo limited threads ke saath. forEachOrdered expensive synchronization impose karta hai order maintain karne ke liye, parallel performance defeat kar deta hai."
        },
        "keyPoints": [
          "Never modify stream source during operation",
          "Ensure reduce operations are associative and stateless",
          "Never block in common pool (I/O, sleep); use custom ForkJoinPool",
          "Avoid forEachOrdered unless absolutely necessary",
          "Measure performance; don't assume parallel is faster"
        ],
        "extras": {
          "flowDiagram": "Parallel Stream Pitfalls:\nSource modification → ConcurrentModificationException\nNon-associative reduce → Wrong result\nBlocking in common pool → Starvation of other streams\nforEachOrdered → Performance degradation (synchronization)",
          "comparisonTable": "Pitfall|Symptom|Solution\nSource modification|ConcurrentModificationException|Filter instead of remove\nNon-associative reduce|Incorrect calculation|Use associative ops (sum, min)\nBlocking I/O|System slowdown|Custom ForkJoinPool\nforEachOrdered|Slow performance|Use forEach if order not required",
          "examples": []
        }
      }
    ]
  }
]
    }
]