[
    {
        "id": "core-java-mastery",
        "category": "Programming",
        "title": "Core Java Mastery Handbook",
        "subtitle": "A comprehensive, end-to-end guide to Core Java covering language fundamentals, object-oriented principles, memory management, exception handling, multithreading, I/O, modern Java features, reflection, and essential design patterns.",
        "icon": "☕",
        "stats": {
            "sections": 7,
            "topics": 40,
            "difficulty": "Beginner to Advanced"
        },
        "sections": [
            {
                "id": "section-1",
                "title": "Java Basics",
                "topics": [
                    {
                        "id": "s1-1-1",
                        "title": "JVM (Java Virtual Machine)",
                        "explanations": {
                            "english": "The Java Virtual Machine (JVM) is an abstract computing machine that provides the runtime environment for executing Java bytecode. It acts as an intermediary between the compiled Java code and the underlying hardware, translating bytecode into native machine instructions through interpretation or Just-In-Time (JIT) compilation. The JVM ensures platform independence by abstracting operating system differences, allowing Java programs to run on any device with a compatible JVM implementation. It manages critical runtime operations including memory allocation, garbage collection, security enforcement, and thread synchronization. Understanding the JVM architecture is essential for optimizing application performance and debugging complex runtime issues."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "JVM provides the runtime environment that executes Java bytecode on any platform",
                            "It uses a combination of interpretation and JIT compilation for code execution",
                            "The JVM abstracts hardware differences enabling Java's 'write once, run anywhere' capability",
                            "Key components include the classloader, runtime data areas, and execution engine"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-1-2",
                        "title": "JRE (Java Runtime Environment)",
                        "explanations": {
                            "english": "The Java Runtime Environment (JRE) is a software package that provides the libraries, Java Virtual Machine (JVM), and other components necessary to run Java applications. It contains the core classes, supporting files, and the JVM implementation required to execute compiled Java bytecode. The JRE does not include development tools such as compilers or debuggers, making it suitable for end-users who only need to run Java programs. It includes essential libraries like the Java Class Library (JCL) which provides utilities for collections, concurrency, networking, and GUI development. When you distribute a Java application to users, they typically only need the JRE installed on their system to run it successfully."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "JRE provides the minimum requirements to run Java applications without development capabilities",
                            "It includes the JVM, core libraries, and supporting configuration files",
                            "JRE is targeted at end-users while JDK is targeted at developers",
                            "Does not contain compilers, debuggers, or other development tools"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-1-3",
                        "title": "JDK (Java Development Kit)",
                        "explanations": {
                            "english": "The Java Development Kit (JDK) is a comprehensive software development environment used for building Java applications, applets, and components. It includes the Java Runtime Environment (JRE), the Java compiler (javac), debugger, documentation generator (javadoc), archiver (jar), and other tools necessary for development. The JDK allows developers to write, compile, and debug Java source code into bytecode that can be executed by the JVM. It also provides development libraries and APIs that extend the core functionality available in the JRE. When setting up a development environment, installing the correct JDK version is the first essential step to ensure compatibility with language features and libraries."
                        },
                        "code": {
                            "title": "Basic JDK Commands",
                            "language": "bash",
                            "content": "# Compile Java source file\njavac HelloWorld.java\n\n# Run compiled Java program\njava HelloWorld\n\n# Generate documentation\njavadoc -d docs HelloWorld.java\n\n# Create JAR archive\njar cvf app.jar HelloWorld.class"
                        },
                        "codeExplanations": {
                            "english": "These commands demonstrate essential JDK tools: javac compiles .java files to .class bytecode, java executes the bytecode on the JVM, javadoc generates HTML API documentation from source comments, and jar packages compiled classes into archive files for distribution."
                        },
                        "keyPoints": [
                            "JDK is a superset of JRE that includes development tools like compiler and debugger",
                            "The javac compiler transforms Java source code into platform-independent bytecode",
                            "JDK provides tools for documentation, archiving, and monitoring Java applications",
                            "Different JDK versions support different Java language features and APIs"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-1-4",
                        "title": "JVM Architecture (High-level)",
                        "explanations": {
                            "english": "The JVM architecture consists of three main components that work together to execute Java programs efficiently. The Class Loader Subsystem loads class files into memory through loading, linking, and initialization phases. The Runtime Data Areas include the Method Area, Heap, Java Stacks, PC Registers, and Native Method Stacks where data is stored during execution. The Execution Engine contains the Interpreter, JIT Compiler, and Garbage Collector that translate bytecode into machine code and manage memory. This modular design allows the JVM to optimize performance through adaptive optimization techniques while maintaining strict security and memory safety guarantees."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "Class Loader Subsystem handles loading, linking, and initialization of classes",
                            "Runtime Data Areas divide memory into method area, heap, stacks, and registers",
                            "Execution Engine interprets bytecode or compiles it to native code using JIT",
                            "Garbage Collector automatically manages heap memory by removing unreachable objects"
                        ],
                        "extras": {
                            "flowDiagram": "┌─────────────────────────────────────┐\n│         Class Loader                │\n│  Loading → Linking → Initialization │\n└──────────────┬──────────────────────┘\n               ↓\n┌─────────────────────────────────────┐\n│       Runtime Data Areas            │\n│  Method Area | Heap | Stacks | PC   │\n└──────────────┬──────────────────────┘\n               ↓\n┌─────────────────────────────────────┐\n│       Execution Engine              │\n│  Interpreter | JIT Compiler | GC    │\n└─────────────────────────────────────┘",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-1-5",
                        "title": "Java Compilation & Execution Flow",
                        "explanations": {
                            "english": "The Java compilation and execution flow transforms human-readable source code into running applications through a multi-stage process. First, the Java compiler (javac) performs lexical analysis, parsing, and semantic checking to generate platform-independent bytecode stored in .class files. During runtime, the Class Loader dynamically loads these class files into the JVM memory areas. The Bytecode Verifier then validates the loaded code for security violations and type safety before execution. Finally, the Execution Engine either interprets the bytecode line-by-line or compiles frequently used code to native machine code using the JIT compiler for improved performance."
                        },
                        "code": {
                            "title": "Compilation and Execution Process",
                            "language": "java",
                            "content": "// Source file: HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n\n// Step 1: Compile\n// javac HelloWorld.java\n// Generates: HelloWorld.class (bytecode)\n\n// Step 2: Execute\n// java HelloWorld\n// Output: Hello, World!"
                        },
                        "codeExplanations": {
                            "english": "This example shows the complete workflow: the .java source file contains human-readable code that javac compiles into platform-independent bytecode in the .class file. The java command then launches the JVM, loads the class, and executes the main method to produce output."
                        },
                        "keyPoints": [
                            "Java source code (.java) is compiled to bytecode (.class) by the javac compiler",
                            "Bytecode is platform-independent and can run on any JVM implementation",
                            "Class loading is dynamic, occurring at runtime rather than compile time",
                            "JIT compilation converts frequently executed bytecode to native machine code for speed"
                        ],
                        "extras": {
                            "flowDiagram": "HelloWorld.java → [javac] → HelloWorld.class → [Class Loader] → [Bytecode Verifier] → [Execution Engine] → Output",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-2-1",
                        "title": "Primitive Data Types",
                        "explanations": {
                            "english": "Primitive data types in Java are the fundamental building blocks for data manipulation that store simple values directly in memory. Java defines eight primitives: byte (8-bit), short (16-bit), int (32-bit), long (64-bit) for integers; float (32-bit) and double (64-bit) for floating-point numbers; char (16-bit Unicode) for characters; and boolean for true/false values. Unlike reference types, primitives are not objects and do not have methods or fields, making them more memory-efficient and faster to process. Each primitive has a fixed size regardless of the platform, ensuring consistent behavior across different JVM implementations. Understanding the range and memory footprint of each primitive is crucial for optimizing performance and preventing overflow errors."
                        },
                        "code": {
                            "title": "Primitive Type Declarations",
                            "language": "java",
                            "content": "// Integer types\nbyte byteVal = 127;\nshort shortVal = 32767;\nint intVal = 2147483647;\nlong longVal = 9223372036854775807L;\n\n// Floating point types\nfloat floatVal = 3.14f;\ndouble doubleVal = 3.14159265359;\n\n// Other primitives\nchar charVal = 'A';\nboolean boolVal = true;"
                        },
                        "codeExplanations": {
                            "english": "This code demonstrates declaration and initialization of all eight primitive types in Java. Notice the 'L' suffix for long literals and 'f' suffix for float literals, which are required to specify the correct type. Default integer literals are treated as int, and floating-point literals as double."
                        },
                        "keyPoints": [
                            "Java has 8 primitive types: byte, short, int, long, float, double, char, boolean",
                            "Primitives store values directly in stack memory, making them efficient",
                            "Each primitive has a specific bit-width and range that is platform-independent",
                            "Primitives do not support null values and have no methods or properties"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Type|Size|Range\nbyte|8-bit|-128 to 127\nshort|16-bit|-32,768 to 32,767\nint|32-bit|-2^31 to 2^31-1\nlong|64-bit|-2^63 to 2^63-1\nfloat|32-bit|IEEE 754\nchar|16-bit|0 to 65,535 (Unicode)\nboolean|JVM dependent|true or false",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-2-2",
                        "title": "Reference Data Types",
                        "explanations": {
                            "english": "Reference data types in Java store memory addresses (references) to objects rather than the actual data values themselves. Unlike primitives, reference types include classes, interfaces, arrays, and enums, which are created using the 'new' keyword and stored in the heap memory. When you assign a reference variable to another, both variables point to the same object in memory, meaning changes through one reference affect all others. Reference types can be null, indicating they do not currently point to any object. These types support inheritance, polymorphism, and encapsulation, forming the foundation of object-oriented programming in Java."
                        },
                        "code": {
                            "title": "Reference Type Usage",
                            "language": "java",
                            "content": "// Class reference\nString name = new String(\"Java\");\n\n// Array reference\nint[] numbers = new int[5];\n\n// Interface reference\nRunnable task = new Runnable() {\n    public void run() {\n        System.out.println(\"Running\");\n    }\n};\n\n// Null reference\nString empty = null;"
                        },
                        "codeExplanations": {
                            "english": "This example shows different reference types: String is a class reference pointing to a string object in the heap, arrays are special reference types that hold multiple values, interfaces can be used as reference types for implementing classes, and null represents a reference that points to no object."
                        },
                        "keyPoints": [
                            "Reference types store memory addresses pointing to heap-allocated objects",
                            "Includes classes, interfaces, arrays, and enums",
                            "Multiple references can point to the same object, sharing state",
                            "Reference types default to null and support methods and inheritance"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-2-3",
                        "title": "Variable Declaration & Initialization",
                        "explanations": {
                            "english": "Variable declaration in Java involves specifying the data type followed by the variable name, which reserves memory space and establishes the variable's scope and type constraints. Initialization assigns an initial value to the declared variable, which can occur on the same line as declaration or later in the code. Local variables must be explicitly initialized before use, while instance variables receive default values automatically. Java supports multiple variable declarations of the same type in a single statement separated by commas. The naming convention requires camelCase for variables, starting with a lowercase letter, and constants use uppercase with underscores."
                        },
                        "code": {
                            "title": "Variable Declaration Examples",
                            "language": "java",
                            "content": "// Declaration and initialization\nint age = 25;\nString name = \"John\";\n\n// Declaration only, initialization later\ndouble salary;\nsalary = 50000.00;\n\n// Multiple declarations\nint x = 1, y = 2, z = 3;\n\n// Constants\nfinal double PI = 3.14159;\nfinal int MAX_USERS = 100;"
                        },
                        "codeExplanations": {
                            "english": "The code demonstrates different declaration patterns: combined declaration and initialization, separate declaration and initialization for later assignment, multiple variables in one statement, and constant declaration using the final keyword which prevents reassignment."
                        },
                        "keyPoints": [
                            "Variables must declare a type and name before use; local variables require initialization",
                            "Instance variables receive default values (0, false, or null) if not initialized",
                            "The final keyword creates constants that cannot be modified after initialization",
                            "Multiple variables of the same type can be declared in a single statement"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-2-4",
                        "title": "Type Casting (Implicit vs Explicit)",
                        "explanations": {
                            "english": "Type casting in Java converts values from one data type to another when compatible conversions are possible. Implicit casting (widening) occurs automatically when converting from a smaller type to a larger type, such as int to long or float to double, as no data loss occurs. Explicit casting (narrowing) requires the programmer to specify the target type in parentheses when converting from larger to smaller types, such as double to int, which may result in data loss or truncation. Reference type casting allows objects to be treated as different types in the inheritance hierarchy, with instanceof checks recommended to avoid ClassCastException. Understanding casting rules is essential for preventing runtime errors and maintaining data integrity."
                        },
                        "code": {
                            "title": "Type Casting Examples",
                            "language": "java",
                            "content": "// Implicit casting (widening)\nint intVal = 100;\nlong longVal = intVal;\ndouble doubleVal = longVal;\n\n// Explicit casting (narrowing)\ndouble price = 99.99;\nint intPrice = (int) price; // Truncates to 99\n\n// Casting with potential data loss\nlong bigNumber = 10000000000L;\nint smallNumber = (int) bigNumber; // Overflow\n\n// Reference casting\nObject obj = \"Hello\";\nString str = (String) obj;"
                        },
                        "codeExplanations": {
                            "english": "This code shows implicit casting where the compiler automatically converts smaller types to larger ones. Explicit casting demonstrates manual conversion with potential truncation of decimal values or overflow for large numbers. Reference casting allows treating a general Object as a specific String type."
                        },
                        "keyPoints": [
                            "Implicit casting (widening) happens automatically from smaller to larger compatible types",
                            "Explicit casting (narrowing) requires syntax (targetType) value and may cause data loss",
                            "Casting between incompatible types results in compilation or runtime errors",
                            "Always verify object types with instanceof before reference casting to prevent exceptions"
                        ],
                        "extras": {
                            "flowDiagram": "byte → short → int → long → float → double\n        char ↗",
                            "comparisonTable": "Casting Type|Direction|Syntax|Data Loss\nImplicit|Widening|auto|No\nExplicit|Narrowing|(type) value|Possible",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-2-5",
                        "title": "Scope of Variables",
                        "explanations": {
                            "english": "Variable scope in Java defines the region of the program where a variable is visible and accessible, determining its lifetime and accessibility rules. Local variables declared inside methods or blocks exist only within those braces and are destroyed when the block exits. Instance variables belong to object instances and are accessible throughout the class, existing as long as the object exists. Class variables (static) belong to the class itself and are shared among all instances, persisting for the program's duration. Parameters have method scope, accessible only within the method signature and body. Understanding scope prevents naming conflicts, manages memory efficiently, and controls encapsulation."
                        },
                        "code": {
                            "title": "Variable Scope Demonstration",
                            "language": "java",
                            "content": "public class ScopeDemo {\n    // Instance variable\n    int instanceVar = 10;\n    \n    // Class variable\n    static int staticVar = 20;\n    \n    public void method(int param) { // Parameter scope\n        int localVar = 30; // Local variable\n        \n        if (true) {\n            int blockVar = 40; // Block scope\n            System.out.println(blockVar);\n        }\n        // blockVar not accessible here\n        System.out.println(localVar + param);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This example illustrates different scopes: instanceVar exists for each object instance, staticVar is shared across all instances, param is accessible throughout the method, localVar exists within the method body, and blockVar is restricted to the if-statement block and inaccessible outside it."
                        },
                        "keyPoints": [
                            "Local variables exist only within their declared block or method",
                            "Instance variables are accessible throughout the class and exist with the object",
                            "Static variables belong to the class and are shared among all instances",
                            "Variables cannot be accessed outside their scope, preventing naming conflicts"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Scope Type|Declaration|Lifetime|Access\nLocal|Inside block/method|Block execution|Within block only\nInstance|Inside class, outside methods|Object lifetime|Throughout class\nStatic|With static keyword|Program duration|Via class name or instance\nParameter|Method signature|Method execution|Within method only",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-3-1",
                        "title": "Arithmetic Operators",
                        "explanations": {
                            "english": "Arithmetic operators in Java perform mathematical calculations on numeric operands, including addition (+), subtraction (-), multiplication (*), division (/), and modulo (%). The division operator performs integer division when both operands are integers, truncating the decimal portion, but floating-point division when either operand is a float or double. The modulo operator returns the remainder of division, useful for cyclic operations or checking divisibility. Compound assignment operators (+=, -=, *=, /=, %=) combine arithmetic operations with assignment for concise code. Operator precedence follows standard mathematical rules, with multiplication and division evaluated before addition and subtraction unless parentheses override the order."
                        },
                        "code": {
                            "title": "Arithmetic Operations",
                            "language": "java",
                            "content": "int a = 10, b = 3;\n\nint sum = a + b;        // 13\nint diff = a - b;       // 7\nint product = a * b;    // 30\nint quotient = a / b;   // 3 (integer division)\nint remainder = a % b;  // 1\n\n// Compound assignment\na += 5;  // a = 15\na *= 2;  // a = 30\n\n// Division with doubles\ndouble result = 10.0 / 3; // 3.333..."
                        },
                        "codeExplanations": {
                            "english": "This code demonstrates basic arithmetic operations showing integer division truncates results (10/3=3), while operations involving doubles produce precise decimal results. Compound assignment operators modify variables in place, equivalent to a = a + 5 but more concise."
                        },
                        "keyPoints": [
                            "Integer division truncates decimal results; use floating-point types for precision",
                            "Modulo operator % returns remainder and is useful for cyclic patterns",
                            "Compound assignment operators combine arithmetic with assignment (+=, -=, etc.)",
                            "Division by zero throws ArithmeticException for integers but returns Infinity for doubles"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "Checking even/odd: number % 2 == 0",
                                "Cycling through array: index = (index + 1) % array.length"
                            ]
                        }
                    },
                    {
                        "id": "s1-3-2",
                        "title": "Relational Operators",
                        "explanations": {
                            "english": "Relational operators in Java compare two operands and return a boolean value indicating the relationship between them. The equality operators == and != check whether values are equal or not equal, working with both primitives and references, though reference comparison checks memory addresses rather than content. Ordering operators include less than (<), greater than (>), less than or equal to (<=), and greater than or equal to (>=), applicable only to numeric types and characters. These operators form the foundation for conditional logic, loop control, and sorting algorithms. When comparing reference types for content equality, use the equals() method rather than == to avoid comparing memory addresses."
                        },
                        "code": {
                            "title": "Relational Comparisons",
                            "language": "java",
                            "content": "int x = 5, y = 10;\n\nboolean isEqual = (x == y);        // false\nboolean notEqual = (x != y);       // true\nboolean lessThan = (x < y);        // true\nboolean greaterThan = (x > y);     // false\nboolean lessOrEqual = (x <= 5);    // true\n\n// Reference comparison\nString s1 = new String(\"Hi\");\nString s2 = new String(\"Hi\");\nboolean refEqual = (s1 == s2);     // false\nboolean valueEqual = s1.equals(s2); // true"
                        },
                        "codeExplanations": {
                            "english": "The example shows relational operators comparing primitive values and references. Note that == compares reference addresses for objects, not content, which is why s1 == s2 is false despite having the same text. Always use equals() for logical string comparison."
                        },
                        "keyPoints": [
                            "Relational operators return boolean values based on operand comparison",
                            "== and != work with all types but compare memory addresses for references",
                            "Ordering operators (<, >, <=, >=) work only with numeric types and chars",
                            "Use equals() method for content comparison of objects, not =="
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Operator|Meaning|Example|Result\n==|Equal to|5 == 5|true\n!=|Not equal|5 != 3|true\n>|Greater than|5 > 3|true\n<|Less than|5 < 3|false\n>=|Greater or equal|5 >= 5|true\n<=|Less or equal|3 <= 5|true",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-3-3",
                        "title": "Logical Operators",
                        "explanations": {
                            "english": "Logical operators in Java combine boolean expressions to form complex conditional logic, operating on boolean operands and producing boolean results. The logical AND (&&) returns true only if both operands are true, while logical OR (||) returns true if at least one operand is true. The logical NOT (!) inverts the boolean value, converting true to false and vice versa. Short-circuit evaluation occurs with && and ||, meaning the second operand is evaluated only if necessary, improving performance and preventing potential errors like null pointer exceptions. Logical operators are essential for decision-making, validation logic, and controlling program flow based on multiple conditions."
                        },
                        "code": {
                            "title": "Logical Operations",
                            "language": "java",
                            "content": "boolean a = true, b = false;\n\nboolean and = a && b;  // false\nboolean or = a || b;   // true\nboolean not = !a;       // false\n\n// Short-circuit evaluation\nString text = null;\nif (text != null && text.length() > 0) {\n    // Safe: text.length() never called if text is null\n}\n\n// Complex condition\nint age = 25;\nboolean valid = (age >= 18) && (age <= 65);"
                        },
                        "codeExplanations": {
                            "english": "This code demonstrates logical AND, OR, and NOT operations. The short-circuit example shows how && prevents NullPointerException by not evaluating text.length() when text is null. Complex conditions combine multiple relational checks using logical operators."
                        },
                        "keyPoints": [
                            "&& (AND) returns true only if both operands are true",
                            "|| (OR) returns true if either operand is true",
                            "! (NOT) inverts the boolean value",
                            "Short-circuit evaluation skips unnecessary operand evaluation, preventing errors"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "A|B|A && B|A || B|!A\ntrue|true|true|true|false\ntrue|false|false|true|false\nfalse|true|false|true|true\nfalse|false|false|false|true",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-3-4",
                        "title": "Bitwise Operators",
                        "explanations": {
                            "english": "Bitwise operators in Java perform operations on individual bits of integer types (byte, short, int, long), enabling low-level manipulation of binary data. The bitwise AND (&) sets a bit to 1 only if both corresponding bits are 1, while OR (|) sets it to 1 if either bit is 1. XOR (^) sets the bit to 1 if the bits are different, and NOT (~) inverts all bits. Shift operators move bits left (<<) or right (>> signed, >>> unsigned), effectively multiplying or dividing by powers of two. These operators are used in flag management, cryptography, graphics programming, and performance-critical algorithms where direct bit manipulation provides efficiency advantages over arithmetic operations."
                        },
                        "code": {
                            "title": "Bitwise Operations",
                            "language": "java",
                            "content": "int a = 5;  // 0101\nint b = 3;  // 0011\n\nint and = a & b;    // 0001 (1)\nint or = a | b;     // 0111 (7)\nint xor = a ^ b;    // 0110 (6)\nint not = ~a;       // 1111...1010 (-6)\n\n// Shift operations\nint left = a << 1;  // 1010 (10)\nint right = a >> 1; // 0010 (2)\n\n// Flag management\nint READ = 4;  // 0100\nint WRITE = 2; // 0010\nint permissions = READ | WRITE; // 0110"
                        },
                        "codeExplanations": {
                            "english": "This example demonstrates bitwise operations on binary representations. The flag management example shows how OR combines permission bits into a single integer, a common pattern in systems programming where each bit represents a different capability or flag."
                        },
                        "keyPoints": [
                            "Bitwise operators work on individual bits of integer types",
                            "& (AND), | (OR), ^ (XOR), ~ (NOT) perform logical operations on each bit pair",
                            "Shift operators (<<, >>, >>>) move bits left or right for multiplication/division by 2",
                            "Commonly used for flags, masks, and low-level performance optimization"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "Checking flags: (permissions & READ) != 0",
                                "Toggling bits: flags ^= MASK"
                            ]
                        }
                    },
                    {
                        "id": "s1-3-5",
                        "title": "Ternary Operator",
                        "explanations": {
                            "english": "The ternary operator in Java provides a concise way to perform conditional assignment with the syntax condition ? valueIfTrue : valueIfFalse. It evaluates the boolean condition and returns the first expression if true, otherwise the second expression, acting as a compact alternative to simple if-else statements. The operator is right-associative, allowing chaining for multiple conditions, though excessive nesting reduces readability. Both result expressions must be compatible types that can be implicitly cast to a common type. While useful for simple conditional assignments, complex logic should use standard if-else blocks for clarity. The ternary operator improves code brevity in variable initialization, return statements, and method arguments."
                        },
                        "code": {
                            "title": "Ternary Operator Usage",
                            "language": "java",
                            "content": "// Basic usage\nint age = 20;\nString status = (age >= 18) ? \"Adult\" : \"Minor\";\n\n// Nested ternary (use sparingly)\nint score = 85;\nchar grade = (score >= 90) ? 'A' : \n             (score >= 80) ? 'B' : \n             (score >= 70) ? 'C' : 'F';\n\n// Method argument\nSystem.out.println((age > 0) ? \"Valid\" : \"Invalid\");\n\n// Return statement\npublic int max(int a, int b) {\n    return (a > b) ? a : b;\n}"
                        },
                        "codeExplanations": {
                            "english": "The code shows the ternary operator replacing simple if-else logic for variable assignment. The nested example demonstrates multiple conditions but illustrates why deep nesting should be avoided for readability. The operator works anywhere a value is expected, including method arguments and return statements."
                        },
                        "keyPoints": [
                            "Syntax: condition ? trueValue : falseValue",
                            "Provides compact alternative to simple if-else statements for assignments",
                            "Both result expressions must be compatible or implicitly castable types",
                            "Can be nested but excessive nesting harms readability"
                        ],
                        "extras": {
                            "flowDiagram": "Condition ? → True → Return Value1\n         ↓\n         False → Return Value2",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-3-6",
                        "title": "Operator Precedence",
                        "explanations": {
                            "english": "Operator precedence in Java determines the order in which operators are evaluated when multiple operators appear in an expression, following a defined hierarchy similar to mathematical conventions. Parentheses () have the highest precedence and can override default evaluation order, ensuring clarity and correctness in complex expressions. Postfix operators (++, --) evaluate before unary operators (+, -, !, ~), which precede multiplicative (*, /, %), then additive (+, -), then shift, then relational, then equality, then bitwise, then logical AND, then logical OR, and finally assignment operators. Operators with equal precedence evaluate left-to-right (left-associative) except for assignment and unary operators which are right-associative. Understanding precedence prevents subtle bugs and reduces reliance on excessive parentheses while maintaining code readability."
                        },
                        "code": {
                            "title": "Precedence Examples",
                            "language": "java",
                            "content": "// Without parentheses\nint result = 5 + 3 * 2;  // 11, not 16\n\n// With parentheses to override\nresult = (5 + 3) * 2;    // 16\n\n// Complex expression\nboolean check = 5 + 3 > 4 && 2 * 2 == 4;\n// Evaluated as: ((5 + 3) > 4) && ((2 * 2) == 4)\n// Result: true\n\n// Assignment is right-associative\nint a, b, c;\na = b = c = 10; // c=10, b=c, a=b"
                        },
                        "codeExplanations": {
                            "english": "This code demonstrates how multiplication has higher precedence than addition, requiring parentheses to force addition first. The boolean expression shows how arithmetic precedes relational operators, which precede logical AND. Right-associativity allows chained assignments from right to left."
                        },
                        "keyPoints": [
                            "Parentheses have highest precedence and override default order",
                            "Multiplication and division occur before addition and subtraction",
                            "Relational operators have higher precedence than logical operators",
                            "Assignment operators are right-associative; most others are left-associative"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Precedence|Operators|Associativity\nHighest|()|Left\nPostfix|++ --|Left\nUnary|+ - ! ~|Right\nMultiplicative|* / %|Left\nAdditive|+ -|Left\nShift|<< >> >>>|Left\nRelational|< > <= >= instanceof|Left\nEquality|== !=|Left\nBitwise AND|&|Left\nBitwise XOR|^|Left\nBitwise OR|||Left\nLogical AND|&&|Left\nLogical OR||||Left\nTernary|? :|Right\nAssignment|= += -= *= /=|Right",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-1",
                        "title": "Conditional Statements - if",
                        "explanations": {
                            "english": "The if statement in Java is a fundamental control structure that executes a block of code only when a specified boolean condition evaluates to true. It begins with the if keyword followed by a condition in parentheses and a statement or block of code in curly braces. The condition must be a boolean expression; non-boolean values like integers cannot be used directly as conditions unlike in some other languages. If statements can be nested within other if statements to create complex decision trees. This structure enables programs to make decisions and execute code selectively based on runtime conditions, forming the basis of program logic flow."
                        },
                        "code": {
                            "title": "If Statement Usage",
                            "language": "java",
                            "content": "int temperature = 75;\n\nif (temperature > 80) {\n    System.out.println(\"It's hot\");\n}\n\n// Single statement without braces (discouraged)\nif (temperature > 60)\n    System.out.println(\"It's warm\");\n\n// With boolean variable\nboolean isRaining = true;\nif (isRaining) {\n    System.out.println(\"Take an umbrella\");\n}"
                        },
                        "codeExplanations": {
                            "english": "The example shows basic if statement syntax where the code block executes only when the condition is true. The second example demonstrates optional braces for single statements, though braces are recommended to prevent errors during maintenance. Boolean variables can be used directly as conditions."
                        },
                        "keyPoints": [
                            "Executes code block only when the boolean condition is true",
                            "Condition must be boolean; non-zero integers are not treated as true",
                            "Curly braces are optional for single statements but strongly recommended",
                            "Can be nested to create complex conditional logic"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Condition? → True → Execute Block → Continue\n                ↓\n                False → Continue",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-2",
                        "title": "Conditional Statements - if-else",
                        "explanations": {
                            "english": "The if-else statement in Java provides binary decision-making capability by executing one code block when a condition is true and an alternative block when it is false. The else clause follows the if block and contains code that runs exclusively when the if condition evaluates to false. This structure creates mutually exclusive execution paths, ensuring exactly one of the two blocks runs. Multiple conditions can be chained using else-if ladders to handle three or more scenarios sequentially. The if-else structure is essential for binary choices, error handling, and branching logic where exactly one path must be taken based on runtime conditions."
                        },
                        "code": {
                            "title": "If-Else Patterns",
                            "language": "java",
                            "content": "int score = 75;\n\n// Basic if-else\nif (score >= 60) {\n    System.out.println(\"Pass\");\n} else {\n    System.out.println(\"Fail\");\n}\n\n// If-else-if ladder\nif (score >= 90) {\n    System.out.println(\"A\");\n} else if (score >= 80) {\n    System.out.println(\"B\");\n} else if (score >= 70) {\n    System.out.println(\"C\");\n} else {\n    System.out.println(\"F\");\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows a binary choice between Pass and Fail. The else-if ladder demonstrates handling multiple ranges, evaluating conditions top-down until one matches or the final else executes. Only one block in the ladder executes, making it efficient for mutually exclusive conditions."
                        },
                        "keyPoints": [
                            "Provides two mutually exclusive execution paths based on condition",
                            "Else block executes only when if condition is false",
                            "n",
                            "Else-if ladders handle multiple conditions sequentially",
                            "Only one block executes in an if-else-if chain"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Condition? → True → If Block → End\n                ↓\n                False → Else Block → End",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-3",
                        "title": "Conditional Statements - switch",
                        "explanations": {
                            "english": "The switch statement in Java provides a multi-way branch that compares a variable's value against multiple constant cases for efficient decision-making. It evaluates an expression once and jumps to the matching case label, executing code until a break statement or the end of the switch block. The switch works with byte, short, char, int, their wrapper classes, enums, and since Java 7, Strings. Without break statements, execution falls through to subsequent cases (fall-through behavior), which can be used for grouping cases but often causes bugs if forgotten. Java 12 introduced switch expressions that return values and use arrow syntax for cleaner syntax. Switch statements are more readable than long if-else ladders when comparing a single variable against discrete values."
                        },
                        "code": {
                            "title": "Switch Statement Examples",
                            "language": "java",
                            "content": "// Traditional switch\nint day = 3;\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    default:\n        System.out.println(\"Other\");\n}\n\n// Fall-through grouping\nchar grade = 'B';\nswitch (grade) {\n    case 'A':\n    case 'B':\n    case 'C':\n        System.out.println(\"Pass\");\n        break;\n    default:\n        System.out.println(\"Fail\");\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows standard switch syntax with break statements preventing fall-through. The second demonstrates intentional fall-through where multiple cases share the same code block, useful when different inputs require identical handling. The default case catches unmatched values."
                        },
                        "keyPoints": [
                            "Compares a variable against multiple constant values efficiently",
                            "Supports byte, short, char, int, enums, Strings, and wrappers",
                            "Break statements prevent fall-through to subsequent cases",
                            "Default case handles values not matching any case label"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Evaluate Expression → Match Case? → Execute → Break? → End\n                ↓ No Match\n                Default → End",
                            "comparisonTable": "Feature|If-Else|Switch\nCondition|Any boolean|Equality only\nExpressions|Multiple|Single variable\nReadability|Poor for many cases|Good for discrete values\nPerformance|Sequential checks|Jump table optimization",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-4",
                        "title": "Looping Statements - for",
                        "explanations": {
                            "english": "The for loop in Java provides a compact way to iterate with a counter-controlled structure consisting of initialization, condition, and update expressions. The syntax for(init; condition; update) executes the initialization once, checks the condition before each iteration, executes the body if true, then performs the update. This loop is ideal for iterating arrays or collections with a known size or when a specific number of iterations is required. The enhanced for loop (for-each) introduced in Java 5 simplifies iteration over arrays and Iterable collections without explicit indexing. All three traditional for components are optional, allowing infinite loops with for(;;), though break statements should terminate them."
                        },
                        "code": {
                            "title": "For Loop Patterns",
                            "language": "java",
                            "content": "// Traditional for loop\nfor (int i = 0; i < 5; i++) {\n    System.out.println(\"Iteration: \" + i);\n}\n\n// Decrementing\nfor (int i = 10; i > 0; i--) {\n    System.out.println(i);\n}\n\n// Enhanced for loop (for-each)\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) {\n    System.out.println(num);\n}\n\n// Multiple variables\nfor (int i = 0, j = 10; i < j; i++, j--) {\n    System.out.println(i + \", \" + j);\n}"
                        },
                        "codeExplanations": {
                            "english": "The traditional for loop shows initialization (int i=0), condition (i<5), and increment (i++). The enhanced for loop automatically iterates through array elements without index management. Multiple variables can be updated simultaneously in the for header, useful for bidirectional iteration."
                        },
                        "keyPoints": [
                            "Syntax: for(init; condition; update) with all parts optional",
                            "Initialization executes once; condition checked before each iteration",
                            "Enhanced for loop (for-each) simplifies array/collection iteration",
                            "Be careful with loop variable scope; it ends outside the loop"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Initialization → Condition? → True → Body → Update → Condition?\n                      ↓ False\n                      End",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-5",
                        "title": "Looping Statements - while",
                        "explanations": {
                            "english": "The while loop in Java repeatedly executes a block of code as long as a specified boolean condition remains true, evaluating the condition before each iteration. It is ideal for situations where the number of iterations is unknown beforehand and depends on runtime conditions or external factors. The condition must eventually become false to avoid infinite loops; ensure the loop body modifies variables affecting the condition. While loops work well for reading input streams, polling, or waiting for specific state changes. Unlike the for loop, the while loop typically handles variable initialization before the loop and modification within the body, making it more suitable for event-driven or condition-dependent iteration."
                        },
                        "code": {
                            "title": "While Loop Examples",
                            "language": "java",
                            "content": "// Basic while loop\nint count = 0;\nwhile (count < 5) {\n    System.out.println(\"Count: \" + count);\n    count++;\n}\n\n// Reading until condition\nScanner scanner = new Scanner(System.in);\nString input = \"\";\nwhile (!input.equals(\"quit\")) {\n    System.out.print(\"Enter text: \");\n    input = scanner.nextLine();\n    System.out.println(\"You entered: \" + input);\n}\n\n// Infinite loop with break\nwhile (true) {\n    if (someCondition) {\n        break;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows a counter-controlled while loop where count is initialized before and incremented inside. The second demonstrates an event-driven pattern common in user input handling. The infinite loop with break shows while(true) as a server or game loop pattern with internal termination logic."
                        },
                        "keyPoints": [
                            "Condition is evaluated before each iteration; body may never execute",
                            "Use when iteration count is unknown and depends on runtime conditions",
                            "Ensure condition variables are modified within the loop to avoid infinite loops",
                            "Pre-test loop suitable for input validation and event polling"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Condition? → True → Body → Condition?\n                ↓ False\n                End",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-6",
                        "title": "Looping Statements - do-while",
                        "explanations": {
                            "english": "The do-while loop in Java is a post-test loop that executes its body at least once before checking the continuation condition. The syntax places the while(condition) at the end after the do block, guaranteeing the first execution regardless of condition truth value. This loop is particularly useful for menu systems, input validation, or scenarios requiring at least one iteration such as game rounds or database queries. Like the while loop, it requires careful handling to ensure the condition eventually becomes false to prevent infinite loops. The semicolon after the while condition is mandatory and a common source of syntax errors if omitted."
                        },
                        "code": {
                            "title": "Do-While Patterns",
                            "language": "java",
                            "content": "// Basic do-while\nint i = 0;\ndo {\n    System.out.println(\"Value: \" + i);\n    i++;\n} while (i < 5);\n\n// Input validation\nScanner scanner = new Scanner(System.in);\nint number;\ndo {\n    System.out.print(\"Enter positive number: \");\n    number = scanner.nextInt();\n} while (number <= 0);\nSystem.out.println(\"Valid number: \" + number);\n\n// Menu system\nint choice;\ndo {\n    System.out.println(\"1. Start 2. Options 3. Exit\");\n    choice = scanner.nextInt();\n    processChoice(choice);\n} while (choice != 3);"
                        },
                        "codeExplanations": {
                            "english": "The examples show the do-while guarantee of at least one execution. Input validation ensures the prompt appears before checking validity. The menu system shows the classic use case where options must display at least once before checking for exit condition."
                        },
                        "keyPoints": [
                            "Post-test loop executes body at least once before checking condition",
                            "n",
                            "Semicolon required after while(condition)",
                            "Ideal for menu systems and input validation requiring initial prompt",
                            "Body executes before condition evaluation unlike standard while loop"
                        ],
                        "extras": {
                            "flowDiagram": "Start → Body → Condition? → True → Body\n                      ↓ False\n                      End",
                            "comparisonTable": "Feature|While|Do-While\nEvaluation|Pre-test|Post-test\nMinimum Executions|0|1\nUse Case|May not need iteration|Must execute at least once\nSyntax|while(condition)|do {} while(condition);",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-4-7",
                        "title": "break and continue",
                        "explanations": {
                            "english": "The break and continue statements in Java provide flow control within loops and switch statements. The break statement immediately terminates the innermost enclosing loop or switch, transferring execution to the first statement after the block. The continue statement skips the remaining code in the current iteration and jumps to the next iteration's condition check. Labeled breaks allow exiting from nested loops by specifying a label identifier before the outer loop. These statements should be used sparingly as they can make code harder to follow; often restructuring logic or extracting methods provides clearer alternatives. They are useful for early exit conditions, filtering iterations, or breaking out of complex search algorithms."
                        },
                        "code": {
                            "title": "Break and Continue Usage",
                            "language": "java",
                            "content": "// Break in loop\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) {\n        break; // Exit loop at 5\n    }\n    System.out.println(i);\n}\n\n// Continue - skip iteration\nfor (int i = 0; i < 5; i++) {\n    if (i == 2) {\n        continue; // Skip printing 2\n    }\n    System.out.println(i);\n}\n\n// Labeled break\nouter: for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        if (i == 1 && j == 1) {\n            break outer; // Exit both loops\n        }\n        System.out.println(i + \",\" + j);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The break example exits the loop completely when i reaches 5. Continue skips the current iteration when i is 2, not printing it but continuing with i=3. The labeled break demonstrates escaping nested loops by breaking to the outer label, stopping both loops immediately."
                        },
                        "keyPoints": [
                            "break exits the innermost loop or switch immediately",
                            "continue skips remaining iteration logic and checks loop condition again",
                            "Labeled breaks exit specified outer loops in nested structures",
                            "Use sparingly to maintain code readability and avoid spaghetti logic"
                        ],
                        "extras": {
                            "flowDiagram": "For Break: Loop → Condition? → True → Check Break? → True → Exit Loop\n                                   ↓ False\n                                   Continue Loop\n\nFor Continue: Loop Body → Check Continue? → True → Skip to Next Iteration",
                            "comparisonTable": "Statement|Action|Use Case\nbreak|Exit loop/switch|Early termination, found result\ncontinue|Skip to next iteration|Filter, skip specific cases\nlabeled break|Exit nested loops|Escape from deep nesting",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-5-1",
                        "title": "Method Declaration & Invocation",
                        "explanations": {
                            "english": "Methods in Java are declared within classes using a signature that includes modifiers, return type, method name, parameter list, and optional throws clause. The declaration syntax follows: modifiers returnType methodName(parameters) { body }. Method invocation occurs using the method name followed by parentheses containing arguments matching the parameter types. Static methods belong to the class and are called using ClassName.method(), while instance methods require an object reference. Methods promote code reusability, modularity, and abstraction by encapsulating specific functionality. Proper method naming follows camelCase conventions with verb-noun combinations describing the action performed."
                        },
                        "code": {
                            "title": "Method Declaration and Calling",
                            "language": "java",
                            "content": "public class Calculator {\n    // Instance method\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    // Static method\n    public static void greet() {\n        System.out.println(\"Hello!\");\n    }\n    \n    public static void main(String[] args) {\n        // Invoke static method\n        Calculator.greet();\n        \n        // Invoke instance method\n        Calculator calc = new Calculator();\n        int result = calc.add(5, 3);\n        System.out.println(result);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The example shows two method types: add is an instance method requiring object creation to invoke, while greet is static and called directly on the class. The main method demonstrates both invocation patterns, showing how static methods don't require instantiation but instance methods do."
                        },
                        "keyPoints": [
                            "Method signature includes modifiers, return type, name, and parameters",
                            "Static methods belong to class; instance methods belong to objects",
                            "Methods must be called with matching argument types and count",
                            "Return type void indicates no value returned; otherwise must return specified type"
                        ],
                        "extras": {
                            "flowDiagram": "Caller → Method Call → Parameter Passing → Execute Body → Return Value → Caller",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-5-2",
                        "title": "Method Overloading",
                        "explanations": {
                            "english": "Method overloading in Java allows multiple methods within the same class to share the same name but have different parameter lists, enabling intuitive APIs with varied input options. Overloaded methods must differ in the number of parameters, types of parameters, or order of parameters; differing only by return type causes a compilation error. The compiler determines which method to invoke based on the argument types provided at compile time (static polymorphism). Overloading improves code readability by using consistent naming for related operations while handling different data types or argument counts. Common examples include System.out.println() which is overloaded for various types like String, int, and double."
                        },
                        "code": {
                            "title": "Method Overloading Examples",
                            "language": "java",
                            "content": "public class Printer {\n    // Overloaded methods\n    public void print(String text) {\n        System.out.println(\"String: \" + text);\n    }\n    \n    public void print(int number) {\n        System.out.println(\"Integer: \" + number);\n    }\n    \n    public void print(String text, int count) {\n        for (int i = 0; i < count; i++) {\n            System.out.println(text);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Printer p = new Printer();\n        p.print(\"Hello\");\n        p.print(42);\n        p.print(\"Hi\", 3);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This code demonstrates overloading through different parameter types (String vs int) and parameter count (single vs double). The compiler selects the appropriate print method based on argument types at compile time, allowing the same method name to handle different input scenarios intuitively."
                        },
                        "keyPoints": [
                            "Same method name with different parameter lists in the same class",
                            "Differences can be in number, type, or order of parameters",
                            "Return type alone does not distinguish overloaded methods",
                            "Compile-time polymorphism: compiler binds method call to definition"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Aspect|Overloading|Overriding\nLocation|Same class|Parent-Child classes\nParameters|Must differ|Must be same\nReturn Type|Can differ|Must be same or covariant\nBinding|Compile time|Runtime\nPurpose|Different inputs|Different implementation",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-5-3",
                        "title": "Varargs",
                        "explanations": {
                            "english": "Variable-length arguments (varargs) in Java allow methods to accept zero or more arguments of a specified type, simplifying method calls with varying argument counts. The syntax uses an ellipsis (...) after the type, such as int... numbers, which the compiler converts into an array of that type within the method body. Varargs must be the last parameter in the method signature, and only one varargs parameter is permitted per method. This feature eliminates the need for multiple overloaded methods handling different argument counts or manual array creation by callers. Varargs are ideal for sum calculations, string formatting, logging utilities, and any method benefiting from flexible argument lists."
                        },
                        "code": {
                            "title": "Varargs Usage",
                            "language": "java",
                            "content": "public class VarargsDemo {\n    // Varargs method\n    public int sum(int... numbers) {\n        int total = 0;\n        for (int num : numbers) {\n            total += num;\n        }\n        return total;\n    }\n    \n    // Mixed parameters\n    public void log(String level, String... messages) {\n        System.out.print(level + \": \");\n        for (String msg : messages) {\n            System.out.print(msg + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        VarargsDemo demo = new VarargsDemo();\n        System.out.println(demo.sum());\n        System.out.println(demo.sum(1, 2));\n        System.out.println(demo.sum(1, 2, 3, 4, 5));\n        demo.log(\"INFO\", \"Server\", \"started\", \"successfully\");\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The sum method accepts any number of integers, treating them as an array internally. The log method shows varargs combined with regular parameters, where varargs must be last. Callers can pass zero, individual arguments, or arrays, with the compiler handling the conversion automatically."
                        },
                        "keyPoints": [
                            "Syntax: type... variableName creates array-like parameter",
                            "Varargs must be the last parameter in the method signature",
                            "Only one varargs allowed per method",
                            "Compiler converts arguments to array; can also pass array directly"
                        ],
                        "extras": {
                            "flowDiagram": "Call with args → Compiler packages into array → Method receives array → Iterate/process",
                            "comparisonTable": "",
                            "examples": [
                                "System.out.printf(String format, Object... args)",
                                "String.format(String format, Object... args)"
                            ]
                        }
                    },
                    {
                        "id": "s1-5-4",
                        "title": "Pass-by-Value in Java",
                        "explanations": {
                            "english": "Java strictly uses pass-by-value semantics for all method arguments, meaning the method receives a copy of the argument's value rather than the original variable itself. For primitive types, this means modifications to parameters inside the method do not affect the original variable in the caller. For reference types, the value passed is the memory address (reference), so while the reference cannot be changed to point to a different object, the object's internal state can be modified. This behavior often confuses developers expecting pass-by-reference for objects. Understanding this distinction is crucial for predicting method side effects and designing APIs that return modified values rather than relying on parameter modification."
                        },
                        "code": {
                            "title": "Pass-by-Value Demonstration",
                            "language": "java",
                            "content": "public class PassByValue {\n    public void modifyPrimitive(int x) {\n        x = 100; // Only changes local copy\n    }\n    \n    public void modifyReference(StringBuilder sb) {\n        sb.append(\" World\"); // Modifies object state\n    }\n    \n    public void reassignReference(StringBuilder sb) {\n        sb = new StringBuilder(\"New\"); // Only changes local reference\n    }\n    \n    public static void main(String[] args) {\n        int num = 50;\n        new PassByValue().modifyPrimitive(num);\n        System.out.println(num); // Still 50\n        \n        StringBuilder builder = new StringBuilder(\"Hello\");\n        new PassByValue().modifyReference(builder);\n        System.out.println(builder); // Hello World\n        \n        new PassByValue().reassignReference(builder);\n        System.out.println(builder); // Still Hello World\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The example proves primitives remain unchanged after method calls. For references, modifyReference changes the object's internal state (visible outside), but reassignReference cannot make the original variable point to a new object because only the copy of the reference was reassigned locally."
                        },
                        "keyPoints": [
                            "Java is strictly pass-by-value; method parameters are copies",
                            "Primitive modifications inside methods do not affect caller's variable",
                            "Reference types pass a copy of the memory address, allowing object mutation",
                            "Reassigning a reference parameter inside a method does not affect the original reference"
                        ],
                        "extras": {
                            "flowDiagram": "Caller: int x=5 → Pass copy (5) → Method modifies copy to 10 → Original x still 5\n\nCaller: ref → Pass copy of address → Method modifies object at address → Original ref sees changes\n\nCaller: ref → Pass copy → Method assigns new address to copy → Original ref unchanged",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-5-5",
                        "title": "Return Types",
                        "explanations": {
                            "english": "Return types in Java methods specify the data type of the value that the method sends back to its caller after execution. Methods can return primitives, reference types, or void to indicate no return value. The return statement immediately terminates method execution and passes the specified value back to the calling code. For non-void methods, every possible execution path must return a value compatible with the declared return type. Return types support polymorphism through covariant returns, where an overriding method can return a subtype of the parent method's return type. Multiple values can be returned by encapsulating them in objects, arrays, or records."
                        },
                        "code": {
                            "title": "Return Type Patterns",
                            "language": "java",
                            "content": "// Primitive return\npublic int square(int x) {\n    return x * x;\n}\n\n// Reference return\npublic String getGreeting() {\n    return \"Hello\";\n}\n\n// Void - no return\npublic void printMessage(String msg) {\n    System.out.println(msg);\n    return; // Optional in void methods\n}\n\n// Returning multiple values via array\npublic int[] getMinMax(int[] nums) {\n    int min = nums[0], max = nums[0];\n    for (int n : nums) {\n        if (n < min) min = n;\n        if (n > max) max = n;\n    }\n    return new int[]{min, max};\n}"
                        },
                        "codeExplanations": {
                            "english": "The examples demonstrate different return patterns: primitives return by value, references return memory addresses, void methods execute without returning data, and multiple values can be returned using composite types like arrays when necessary."
                        },
                        "keyPoints": [
                            "Return type declared before method name; void means no return value",
                            "Return statement exits method immediately and passes value to caller",
                            "Non-void methods must guarantee a return statement executes for all paths",
                            "Covariant return types allow returning subclasses in overridden methods"
                        ],
                        "extras": {
                            "flowDiagram": "Method Start → Execute Logic → Return Statement → Return Value to Caller → Method End",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-6-1",
                        "title": "One-Dimensional Arrays",
                        "explanations": {
                            "english": "One-dimensional arrays in Java are fixed-size, ordered collections of elements of the same type, stored contiguously in heap memory. Declaration uses syntax type[] arrayName or type arrayName[], with instantiation requiring the new keyword and size specification: new type[size]. Array indices start at 0 and range to length-1, with bounds checking performed at runtime throwing ArrayIndexOutOfBoundsException for invalid access. The length property provides the fixed capacity, not the count of filled elements. Arrays can be initialized with literal values using curly braces during declaration. They are reference types, meaning assignment copies the reference rather than creating a copy of the elements."
                        },
                        "code": {
                            "title": "1D Array Operations",
                            "language": "java",
                            "content": "// Declaration and initialization\nint[] numbers = new int[5];\nint[] scores = {85, 90, 78, 92, 88};\n\n// Access and modify\nnumbers[0] = 10;\nSystem.out.println(scores[2]); // 78\n\n// Iterate\nfor (int i = 0; i < scores.length; i++) {\n    System.out.println(scores[i]);\n}\n\n// Enhanced for loop\nfor (int score : scores) {\n    System.out.println(score);\n}"
                        },
                        "codeExplanations": {
                            "english": "The code shows two initialization styles: new int[5] creates a fixed-size array with default values (0), while the literal syntax {85, 90...} declares and populates simultaneously. Access uses zero-based indexing, and length property gives the array size. Both traditional and enhanced for loops iterate through elements."
                        },
                        "keyPoints": [
                            "Arrays have fixed size determined at creation and cannot be resized",
                            "Zero-indexed: first element at index 0, last at length-1",
                            "Length property returns total capacity, not number of elements used",
                            "ArrayIndexOutOfBoundsException thrown for invalid index access"
                        ],
                        "extras": {
                            "flowDiagram": "Index: 0 | 1 | 2 | 3 | 4\nValue: 85|90|78|92|88\nMemory: Contiguous heap allocation",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-6-2",
                        "title": "Two-Dimensional Arrays",
                        "explanations": {
                            "english": "Two-dimensional arrays in Java are arrays of arrays, creating a matrix-like structure with rows and columns. Declaration syntax is type[][] arrayName, creating a structure where each element of the outer array is itself an array. These can represent tables, matrices, grids, or coordinate systems. Initialization can specify both dimensions (rectangular arrays) or leave the second dimension variable (jagged arrays). Access requires two indices: array[row][column]. Memory is not truly contiguous in a 2D grid; instead, the outer array holds references to inner row arrays. They are useful for representing complex data structures like game boards, spreadsheets, or adjacency matrices in graph algorithms."
                        },
                        "code": {
                            "title": "2D Array Usage",
                            "language": "java",
                            "content": "// Rectangular array\nint[][] matrix = new int[3][4];\nint[][] grid = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\n\n// Access\nSystem.out.println(grid[1][2]); // 6\n\n// Iterate\nfor (int i = 0; i < grid.length; i++) {\n    for (int j = 0; j < grid[i].length; j++) {\n        System.out.print(grid[i][j] + \" \");\n    }\n    System.out.println();\n}"
                        },
                        "codeExplanations": {
                            "english": "The example creates a 3x3 matrix using initialization lists. Access requires row and column indices. The nested loop iterates rows with grid.length and columns with grid[i].length, allowing for non-rectangular (jagged) arrays where each row can have different lengths."
                        },
                        "keyPoints": [
                            "2D arrays are arrays of arrays; each row can be a different array object",
                            "Access with two indices: array[row][column]",
                            "Length of outer array is number of rows; inner arrays' lengths are columns",
                            "Can be rectangular (equal columns) or jagged (variable columns per row)"
                        ],
                        "extras": {
                            "flowDiagram": "matrix[0] → [0][1][2][3]\nmatrix[1] → [0][1][2][3]\nmatrix[2] → [0][1][2][3]",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-6-3",
                        "title": "Jagged Arrays",
                        "explanations": {
                            "english": "Jagged arrays in Java are multi-dimensional arrays where each row can have a different length, creating a ragged or triangular structure rather than a rectangular matrix. They are implemented as arrays of arrays where the outer array is allocated first, and each inner array is created separately with independent sizes. This structure is memory-efficient when data naturally has variable row lengths, such as storing student grades where each student has different numbers of courses. Declaration specifies only the first dimension initially, leaving second dimensions to be allocated per row. Jagged arrays require careful handling when iterating, as each row's length must be checked individually to avoid ArrayIndexOutOfBoundsException."
                        },
                        "code": {
                            "title": "Jagged Array Creation",
                            "language": "java",
                            "content": "// Create jagged array\nint[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[4];\njagged[2] = new int[3];\n\n// Initialization\nint[][] triangle = {\n    {1},\n    {2, 3},\n    {4, 5, 6}\n};\n\n// Safe iteration\nfor (int i = 0; i < triangle.length; i++) {\n    for (int j = 0; j < triangle[i].length; j++) {\n        System.out.print(triangle[i][j] + \" \");\n    }\n    System.out.println();\n}"
                        },
                        "codeExplanations": {
                            "english": "The code shows allocating a jagged array by only specifying the outer dimension (3 rows), then individually sizing each row. The triangle example demonstrates literal initialization of a jagged structure. Iteration uses triangle[i].length to handle variable column counts safely."
                        },
                        "keyPoints": [
                            "Each row in a jagged array can have different lengths",
                            "Declare with only first dimension: new int[rows][]",
                            "Allocate each row separately: array[i] = new int[size]",
                            "Always use array[i].length when iterating to handle variable row sizes"
                        ],
                        "extras": {
                            "flowDiagram": "Row 0: [5][2]\nRow 1: [8][1][9][3]\nRow 2: [4][7]",
                            "comparisonTable": "Rectangular|Jagged\nFixed column count|Variable column count\nMemory may waste space|Memory efficient for irregular data\nmatrix[0].length equals matrix[1].length|Each row length independent",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-6-4",
                        "title": "Array Initialization Techniques",
                        "explanations": {
                            "english": "Java provides multiple techniques for initializing arrays depending on when values are known and the array's purpose. Static initialization uses literal values in curly braces during declaration, ideal when data is known at compile time. Dynamic initialization allocates memory with 'new' and assigns values at runtime, useful for calculated or input-dependent data. Anonymous arrays allow creating and passing arrays without declaring a variable, convenient for one-time use in method arguments. The Arrays.fill() method initializes all elements to a specific value, while Arrays.setAll() uses a generator function for computed initialization. Understanding these techniques allows selecting the most concise and appropriate method for each scenario."
                        },
                        "code": {
                            "title": "Array Initialization Patterns",
                            "language": "java",
                            "content": "// Static initialization\nint[] nums = {1, 2, 3, 4, 5};\nString[] fruits = {\"Apple\", \"Banana\", \"Cherry\"};\n\n// Dynamic initialization\nint[] squares = new int[5];\nfor (int i = 0; i < squares.length; i++) {\n    squares[i] = i * i;\n}\n\n// Anonymous array\nprintArray(new int[]{10, 20, 30});\n\n// Arrays utility methods\nimport java.util.Arrays;\nint[] filled = new int[5];\nArrays.fill(filled, 42);\n\nint[] sequence = new int[5];\nArrays.setAll(sequence, i -> i * 2);"
                        },
                        "codeExplanations": {
                            "english": "Static initialization provides compact syntax for known values. Dynamic initialization uses loops for computed values. Anonymous arrays create temporary arrays for immediate use. Arrays.fill sets uniform values, while setAll applies a function to each index for functional initialization patterns."
                        },
                        "keyPoints": [
                            "Static initialization: type[] arr = {val1, val2} during declaration only",
                            "Dynamic initialization: allocate with new then assign values programmatically",
                            "Anonymous arrays: new type[]{values} for temporary array arguments",
                            "Arrays.fill() and Arrays.setAll() provide bulk initialization utilities"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Method|Use Case|Syntax\nStatic|Known compile-time values|{1, 2, 3}\nDynamic|Runtime computed values|new int[size] + loop\nAnonymous|One-time use arguments|new int[]{1, 2, 3}\nFill|Uniform values|Arrays.fill(arr, val)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-6-5",
                        "title": "Common Array Pitfalls",
                        "explanations": {
                            "english": "Common array pitfalls in Java often lead to runtime exceptions or subtle bugs due to misunderstanding array semantics and boundaries. ArrayIndexOutOfBoundsException occurs when accessing indices outside the valid 0 to length-1 range, often from off-by-one errors in loop conditions. NullPointerException arises when attempting operations on array references that haven't been initialized. Arrays are fixed-size; attempting to add elements beyond capacity requires creating a new larger array and copying data. Assignment creates reference aliases rather than copies, so modifying one reference affects all aliases. The equals() method on arrays checks reference equality, not content; use Arrays.equals() for value comparison."
                        },
                        "code": {
                            "title": "Common Array Mistakes",
                            "language": "java",
                            "content": "// Pitfall 1: Index out of bounds\nint[] arr = new int[5];\n// arr[5] = 10; // Runtime exception!\n\n// Pitfall 2: Null reference\nint[] nullArr;\n// System.out.println(nullArr.length); // NullPointerException!\n\n// Pitfall 3: Reference aliasing\nint[] a = {1, 2, 3};\nint[] b = a;\nb[0] = 100;\nSystem.out.println(a[0]); // 100 - unexpected!\n\n// Pitfall 4: Wrong equals usage\nint[] x = {1, 2};\nint[] y = {1, 2};\nSystem.out.println(x.equals(y)); // false!\nSystem.out.println(Arrays.equals(x, y)); // true"
                        },
                        "codeExplanations": {
                            "english": "The examples demonstrate critical errors: accessing index 5 in a size-5 array (valid indices 0-4), using uninitialized arrays, unexpected shared state through reference assignment (b modifies a's data), and the common mistake of using Object.equals() instead of Arrays.equals() for content comparison."
                        },
                        "keyPoints": [
                            "Always ensure indices are within 0 to array.length-1 to avoid exceptions",
                            "Initialize arrays before use; null arrays have no length or elements",
                            "Assignment copies references, not elements; use Arrays.copyOf() for true copies",
                            "Use Arrays.equals() and Arrays.toString() for proper array comparison and printing"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Mistake|Consequence|Solution\narr[n] where n>=length|ArrayIndexOutOfBoundsException|Check bounds: i < arr.length\nnullArr.length|NullPointerException|Initialize: new int[size]\nb = a; b[0]=x|Both arrays modified|Use Arrays.copyOf()\narr1.equals(arr2)|False for same content|Use Arrays.equals()",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-7-1",
                        "title": "String Immutability",
                        "explanations": {
                            "english": "Strings in Java are immutable, meaning once a String object is created, its character sequence cannot be modified. Any operation that appears to modify a string—such as concatenation, replacement, or case conversion—actually creates and returns a new String object rather than changing the original. This immutability provides security benefits, as strings can be safely shared between threads without synchronization, and used as keys in hash-based collections like HashMap. The JVM can optimize memory usage through string interning, caching literal strings in a pool to avoid duplicate objects. Understanding immutability is crucial for performance, as excessive string concatenation in loops creates many temporary objects, necessitating StringBuilder for mutable operations."
                        },
                        "code": {
                            "title": "String Immutability Demo",
                            "language": "java",
                            "content": "String original = \"Hello\";\nString modified = original.concat(\" World\");\n\nSystem.out.println(original);  // Hello (unchanged!)\nSystem.out.println(modified);  // Hello World\n\n// Reassignment creates new reference\noriginal = original + \"!\";\nSystem.out.println(original);  // Hello!\n\n// Methods return new strings\nString upper = original.toUpperCase();\nSystem.out.println(original);  // Hello! (still unchanged)"
                        },
                        "codeExplanations": {
                            "english": "This demonstrates that concat(), + operator, and toUpperCase() return new String objects rather than modifying the original. The original variable remains 'Hello' after concat, requiring assignment to capture the new value. Reassigning original just changes which object the reference points to, not the object itself."
                        },
                        "keyPoints": [
                            "String objects cannot be modified after creation; all 'modifying' methods return new instances",
                            "Immutability enables thread safety and secure sharing of string data",
                            "Reassigning a string variable changes the reference, not the object",
                            "String concatenation creates intermediate objects; use StringBuilder for loops"
                        ],
                        "extras": {
                            "flowDiagram": "\"Hello\" → concat(\" World\") → New String \"Hello World\"\n   ↑\noriginal still points to \"Hello\"",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-7-2",
                        "title": "String Pool",
                        "explanations": {
                            "english": "The String Pool in Java is a special memory region in the heap where string literals are stored and reused to optimize memory usage. When a string is created using literal syntax (String s = \"hello\"), the JVM checks the pool first and returns a reference to the existing string if found, or creates and adds it if not. Strings created with the new keyword (new String(\"hello\")) bypass the pool, creating duplicate objects in the heap. The intern() method can add heap strings to the pool and return the pooled reference. This optimization is safe due to string immutability, ensuring shared references cannot be modified by other code. Understanding the pool distinction is vital for memory optimization and correct == versus equals() usage."
                        },
                        "code": {
                            "title": "String Pool Behavior",
                            "language": "java",
                            "content": "// String pool usage\nString s1 = \"Java\";\nString s2 = \"Java\";\nSystem.out.println(s1 == s2); // true - same pool reference\n\n// Heap allocation\nString s3 = new String(\"Java\");\nSystem.out.println(s1 == s3); // false - different objects\nSystem.out.println(s1.equals(s3)); // true - same content\n\n// Interning\nString s4 = s3.intern();\nSystem.out.println(s1 == s4); // true - now in pool"
                        },
                        "codeExplanations": {
                            "english": "The example shows s1 and s2 referencing the same pooled object, making == return true. s3 created with new is a separate heap object, so == is false but equals() is true. Calling intern() on s3 adds it to the pool and returns the pooled reference, making s4 identical to s1."
                        },
                        "keyPoints": [
                            "String literals are automatically interned in the string pool for reuse",
                            "new String() creates separate heap objects bypassing the pool",
                            "Use equals() for content comparison; == checks reference equality (pool vs heap)",
                            "intern() method can manually add strings to the pool to save memory"
                        ],
                        "extras": {
                            "flowDiagram": "String Pool: \"Java\" ← s1\n                ↑ s2\n                \nHeap: new String(\"Java\") ← s3",
                            "comparisonTable": "Creation|Location|Memory|Use Case\nLiteral \"x\"|String Pool|Shared, efficient|Normal usage\nnew String(\"x\")|Heap|Separate object|Rarely needed\nintern()|String Pool|Adds to pool|Deduplication",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-7-3",
                        "title": "StringBuilder vs StringBuffer",
                        "explanations": {
                            "english": "StringBuilder and StringBuffer in Java provide mutable character sequences for efficient string manipulation without creating intermediate objects. StringBuilder, introduced in Java 5, offers better performance for single-threaded environments as it is not synchronized. StringBuffer is thread-safe through method-level synchronization, making it suitable for concurrent environments but slower due to locking overhead. Both provide append(), insert(), delete(), and reverse() methods that modify the internal character array directly. For most modern applications, StringBuilder is preferred unless explicit thread safety is required. Both are significantly more efficient than string concatenation in loops, which creates O(n²) temporary objects versus O(n) for builders."
                        },
                        "code": {
                            "title": "StringBuilder Usage",
                            "language": "java",
                            "content": "// StringBuilder (non-synchronized, faster)\nStringBuilder sb = new StringBuilder();\nsb.append(\"Hello\");\nsb.append(\" \");\nsb.append(\"World\");\nString result = sb.toString();\n\n// Chaining methods\nString reversed = new StringBuilder(\"Hello\")\n    .reverse()\n    .toString();\n\n// StringBuffer (thread-safe, synchronized)\nStringBuffer sbf = new StringBuffer();\nsbf.append(\"Thread-safe\");\nString bufferResult = sbf.toString();"
                        },
                        "codeExplanations": {
                            "english": "The code shows StringBuilder's append chain building a string efficiently without intermediate objects. Method chaining allows fluent interface usage. StringBuffer demonstrates identical API but with internal synchronization. Both require toString() to convert back to immutable String."
                        },
                        "keyPoints": [
                            "StringBuilder is faster but not thread-safe; preferred for single-threaded code",
                            "StringBuffer is synchronized and thread-safe but slower due to locking",
                            "Both are mutable; methods modify the object and often return this for chaining",
                            "Always use instead of string concatenation in loops for O(n) performance"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Feature|StringBuilder|StringBuffer\nThread-safe|No|Yes\nPerformance|Faster|Slower (synchronization)\nJava Version|1.5+|1.0+\nUse Case|Single-threaded|Multi-threaded\nAPI|Identical|Identical",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-7-4",
                        "title": "Performance Considerations",
                        "explanations": {
                            "english": "String performance optimization in Java requires understanding when to use immutable strings versus mutable builders. String concatenation with + creates a new String object and copies all characters each time, resulting in O(n²) complexity for n concatenations due to repeated copying. StringBuilder pre-allocates a character buffer that expands as needed, providing amortized O(n) complexity for append operations. Default capacity is 16 characters; exceeding this causes array copying and reallocation, so specifying expected size in the constructor improves performance. String.intern() can reduce memory for many duplicate strings but increases pool lookup overhead. For compile-time constant expressions, the compiler automatically optimizes concatenation, but runtime concatenation in loops always requires StringBuilder."
                        },
                        "code": {
                            "title": "Performance Optimization",
                            "language": "java",
                            "content": "// Bad: O(n²) complexity\nString result = \"\";\nfor (int i = 0; i < 1000; i++) {\n    result += i; // Creates new object each iteration\n}\n\n// Good: O(n) complexity\nStringBuilder sb = new StringBuilder(10000); // Pre-size\nfor (int i = 0; i < 1000; i++) {\n    sb.append(i);\n}\nString result = sb.toString();\n\n// Compile-time optimization\nString fast = \"a\" + \"b\" + \"c\"; // Compiled as \"abc\""
                        },
                        "codeExplanations": {
                            "english": "The first loop demonstrates the anti-pattern of string concatenation in loops, creating 1000 temporary objects. StringBuilder with initial capacity eliminates reallocation overhead. The last line shows compiler optimization where literal concatenation becomes a single pooled string at compile time."
                        },
                        "keyPoints": [
                            "String concatenation in loops is O(n²); StringBuilder is O(n)",
                            "Specify initial capacity in StringBuilder constructor to avoid resizing",
                            "Compiler optimizes constant string concatenation at compile time",
                            "Use StringBuilder for dynamic string construction; Strings for constants"
                        ],
                        "extras": {
                            "flowDiagram": "String + : Create new array → Copy old + new → Return (repeated)\n\nStringBuilder: Expand buffer if needed → Append to end → Return this",
                            "comparisonTable": "Operation|String|StringBuilder\nConcatenation in loop|O(n²), slow|O(n), fast\nMemory usage|Many temporary objects|Single buffer\nThread safety|Immutable (safe)|Not synchronized\nCapacity|Fixed|Auto-expanding",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-7-5",
                        "title": "Common String Operations",
                        "explanations": {
                            "english": "Java's String class provides extensive methods for text manipulation, searching, and transformation. Length retrieval (length()), character access (charAt()), and substring extraction (substring()) are fundamental accessor operations. Searching methods include indexOf() and lastIndexOf() for finding characters or substrings, while contains(), startsWith(), and endsWith() provide boolean checks. Transformation methods like toUpperCase(), toLowerCase(), trim(), and replace() return new modified strings. Split() uses regular expressions to divide strings into arrays, and join() concatenates array elements with delimiters. Understanding these operations enables efficient text parsing, validation, and formatting without manual character iteration."
                        },
                        "code": {
                            "title": "String Method Examples",
                            "language": "java",
                            "content": "String text = \"  Hello, World!  \";\n\n// Inspection\nint len = text.length(); // 17\nchar c = text.charAt(7); // 'o'\n\n// Searching\nint index = text.indexOf(\"World\"); // 9\nboolean has = text.contains(\"Hello\"); // true\n\n// Transformation\nString trimmed = text.trim(); // \"Hello, World!\"\nString upper = text.toUpperCase(); // \"  HELLO, WORLD!  \"\nString replaced = text.replace(\"World\", \"Java\");\n\n// Splitting and joining\nString[] parts = \"a,b,c\".split(\",\");\nString joined = String.join(\"-\", parts); // \"a-b-c\""
                        },
                        "codeExplanations": {
                            "english": "These examples cover essential operations: length and charAt for basic access, indexOf for searching, trim for whitespace removal, case conversion, replacement, and split/join for array conversion. All methods return new strings due to immutability, leaving the original unchanged."
                        },
                        "keyPoints": [
                            "length(), charAt(), substring() provide basic string inspection",
                            "indexOf(), lastIndexOf(), contains() search for content within strings",
                            "trim(), toUpperCase(), replace() create modified copies of strings",
                            "split() converts strings to arrays; join() combines arrays with delimiters"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Method|Purpose|Returns\nlength()|Character count|int\ncharAt(i)|Character at index|char\nsubstring(a,b)|Extract portion|String\nindexOf(s)|Find position|int (-1 if not found)\nsplit(regex)|Divide by pattern|String[]\nreplace(a,b)|Swap substrings|String",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-8-1",
                        "title": "Primitive vs Wrapper Types",
                        "explanations": {
                            "english": "Wrapper classes in Java provide object representations for the eight primitive types, allowing primitives to be used in object-oriented contexts. Each primitive has a corresponding wrapper: Integer for int, Double for double, Boolean for boolean, etc. Wrappers enable primitives to be stored in collections, passed as generic type parameters, and participate in reflection. Unlike primitives, wrappers can be null and provide utility methods like parseInt() or toString(). Primitives are more memory-efficient and faster for calculations, while wrappers offer object behavior. Java's autoboxing automatically converts between primitives and wrappers, but this convenience has performance costs and can cause NullPointerException if unboxing null wrappers."
                        },
                        "code": {
                            "title": "Primitive and Wrapper Usage",
                            "language": "java",
                            "content": "// Primitives\nint primitive = 42;\ndouble pi = 3.14;\n\n// Wrappers\nInteger wrapped = Integer.valueOf(42);\nDouble wrappedPi = 3.14; // Autoboxing\n\n// Required for collections\nList<Integer> list = new ArrayList<>();\nlist.add(100); // Autoboxed\nint val = list.get(0); // Unboxed\n\n// Wrapper utilities\nString str = Integer.toString(42);\nint parsed = Integer.parseInt(\"123\");",
                            "codeExplanations": {
                                "english": "The code shows primitives for efficient storage and wrappers for object contexts. Autoboxing automatically converts int to Integer when adding to collections, and unboxing converts back when retrieving. Wrappers provide static utility methods for string conversion and parsing not available on primitives."
                            },
                            "keyPoints": [
                                "Wrapper classes (Integer, Double, etc.) objectify primitive types",
                                "Primitives stored in stack; wrappers are heap objects with overhead",
                                "Wrappers enable use in generics and collections; primitives do not",
                                "Autoboxing/unboxing provides automatic conversion but impacts performance"
                            ],
                            "extras": {
                                "flowDiagram": "",
                                "comparisonTable": "Feature|Primitive|Wrapper\nMemory|Stack (efficient)|Heap (object overhead)\nNullability|Cannot be null|Can be null\nGenerics|Not allowed|Required\nMethods|None|Utility methods (parse, toString)\nStorage|In collections via boxing|Directly in collections",
                                "examples": []
                            }
                        }
                    },
                    {
                        "id": "s1-8-2",
                        "title": "Autoboxing & Unboxing",
                        "explanations": {
                            "english": "Autoboxing and unboxing in Java provide automatic conversion between primitive types and their corresponding wrapper classes. Autoboxing occurs when a primitive is assigned to a wrapper variable or passed to a method expecting a wrapper, automatically invoking valueOf(). Unboxing happens when a wrapper is assigned to a primitive or used in arithmetic operations, automatically calling methods like intValue(). This feature simplifies code by eliminating manual conversions, but creates subtle issues: wrapper equality with == compares references for values outside the cache range, and unboxing null throws NullPointerException. Performance-critical code should avoid autoboxing in loops due to object creation overhead."
                        },
                        "code": {
                            "title": "Autoboxing in Practice",
                            "language": "java",
                            "content": "// Autoboxing\nInteger num = 50; // int automatically boxed to Integer\nDouble price = 19.99;\n\n// Unboxing\nint primitive = num; // Integer unboxed to int\ndouble calc = price + 5.0; // Unboxed for arithmetic\n\n// Method arguments\nprintInteger(100); // Autoboxed\n\n// Potential pitfalls\nInteger a = 1000, b = 1000;\nSystem.out.println(a == b); // false (different objects)\n\nInteger c = 100, d = 100;\nSystem.out.println(c == d); // true (cached objects)"
                        },
                        "codeExplanations": {
                            "english": "The examples show automatic conversion in assignments and arithmetic. The pitfall section demonstrates that == compares object references for wrappers; small values (-128 to 127) are cached so == appears to work, but larger values create different objects even with the same value."
                        },
                        "keyPoints": [
                            "Autoboxing: compiler automatically converts primitive to wrapper (valueOf)",
                            "Unboxing: compiler converts wrapper to primitive (xxxValue methods)",
                            "Unboxing null wrappers throws NullPointerException",
                            "== compares references for wrappers; use equals() for value comparison"
                        ],
                        "extras": {
                            "flowDiagram": "Primitive int → Autoboxing → Integer object\nInteger object → Unboxing → Primitive int",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-8-3",
                        "title": "Wrapper Caching",
                        "explanations": {
                            "english": "Wrapper classes in Java cache frequently used objects to improve memory efficiency and performance of autoboxing. The Byte, Short, Integer, and Long classes cache values from -128 to 127 by default, returning the same object instance for values in this range when using valueOf() or autoboxing. Character caches values 0 to 127, and Boolean caches TRUE and FALSE instances. This caching is why == appears to work for small wrapper values but returns false for larger values outside the cache range. The cache size can be configured for Integer using the java.lang.Integer.IntegerCache.high system property. Understanding caching is crucial for avoiding reference equality bugs and optimizing memory usage in applications with many wrapper instances."
                        },
                        "code": {
                            "title": "Wrapper Caching Behavior",
                            "language": "java",
                            "content": "// Cached (same object)\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b); // true\n\n// Not cached (different objects)\nInteger c = 128;\nInteger d = 128;\nSystem.out.println(c == d); // false\nSystem.out.println(c.equals(d)); // true\n\n// Boolean caching\nBoolean t1 = true;\nBoolean t2 = true;\nSystem.out.println(t1 == t2); // always true\n\n// Explicit valueOf uses cache\nInteger e = Integer.valueOf(100);\nInteger f = Integer.valueOf(100);\nSystem.out.println(e == f); // true"
                        },
                        "codeExplanations": {
                            "english": "The code demonstrates that values within -128 to 127 return identical cached objects, making == return true. Values outside this range create new objects, so == returns false despite equal values. Always use equals() for value comparison, or valueOf() to ensure caching benefits."
                        },
                        "keyPoints": [
                            "Integer caches -128 to 127; other types have similar ranges",
                            "Autoboxing uses valueOf() which returns cached instances when available",
                            "== compares references; cached objects appear equal with ==, new ones do not",
                            "Always use equals() for value comparison of wrapper objects"
                        ],
                        "extras": {
                            "flowDiagram": "valueOf(100) → Check Cache → Found? → Return cached object\n                          ↓ No\n                   Create new Integer → Add to cache? → Return new object",
                            "comparisonTable": "Type|Cache Range\nByte|-128 to 127\nShort|-128 to 127\nInteger|-128 to 127 (configurable)\nLong|-128 to 127\nCharacter|0 to 127\nBoolean|TRUE, FALSE",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-8-4",
                        "title": "Use Cases of Wrapper Classes",
                        "explanations": {
                            "english": "Wrapper classes serve essential roles in Java where object semantics are required for primitive data. They are mandatory for generic collections (List<Integer>, Map<String, Double>) as generics do not support primitives. Wrappers provide utility methods for parsing strings to numbers (parseInt, parseDouble), converting to other bases (toBinaryString, toHexString), and comparing values (compareTo). They enable nullability to represent missing or uninitialized data, unlike primitives which default to zero or false. In reflection, method parameters and return types are represented as Class objects, requiring wrappers for numeric types. Wrappers also facilitate serialization, where object state must be preserved, and allow primitives to be synchronized upon when used as locks in multithreading."
                        },
                        "code": {
                            "title": "Wrapper Use Cases",
                            "language": "java",
                            "content": "// Collections require wrappers\nList<Double> prices = new ArrayList<>();\nprices.add(19.99); // Autoboxed\n\n// Parsing strings\nint port = Integer.parseInt(\"8080\");\ndouble rate = Double.parseDouble(\"3.14\");\n\n// Nullability for missing data\nInteger age = null; // Unknown age\n\n// Utility methods\nString binary = Integer.toBinaryString(255); // \"11111111\"\nint max = Integer.max(10, 20); // 20\n\n// Reflection\nClass<?> intClass = int.class; // Primitive\nClass<?> integerClass = Integer.class; // Wrapper"
                        },
                        "codeExplanations": {
                            "english": "Examples show wrappers enabling generics with ArrayList, parsing configuration strings to numbers, representing nullable database fields, converting numbers to different string representations, and providing comparison utilities. Reflection shows the distinction between primitive and wrapper class literals."
                        },
                        "keyPoints": [
                            "Required for generic collections which cannot use primitives",
                            "Provide parsing methods to convert strings to numeric types",
                            "Allow null representation for undefined or missing values",
                            "Offer utility methods for base conversion, comparison, and constants (MAX_VALUE)"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Use Case|Example|Primitive Alternative\nCollections|List<Integer>|Not possible\nParsing|Integer.parseInt()|Manual parsing\nNullability|Integer age = null|int defaults to 0\nUtilities|toHexString(), compare()|Not available\nReflection|Method param types|Class objects only",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-9-1",
                        "title": "Enum Basics",
                        "explanations": {
                            "english": "Enumerations (enums) in Java are special classes that define a fixed set of named constants, providing type-safe representation of discrete values. Declared with the enum keyword, enums implicitly extend java.lang.Enum and compile to classes with static final instances for each constant. Enums are full-fledged classes that can have fields, methods, constructors, and implement interfaces, unlike simple constants in other languages. The constants are implicitly public static final and are the only instances allowed, ensuring singleton behavior per constant. Enums provide built-in methods like values() returning an array of all constants, and valueOf(String) for lookup by name, making them more robust than integer or string constants."
                        },
                        "code": {
                            "title": "Basic Enum Declaration",
                            "language": "java",
                            "content": "public enum Day {\n    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, \n    THURSDAY, FRIDAY, SATURDAY\n}\n\n// Usage\nDay today = Day.MONDAY;\nif (today == Day.MONDAY) {\n    System.out.println(\"Start of work week\");\n}\n\n// Enum methods\nfor (Day d : Day.values()) {\n    System.out.println(d);\n}\n\nDay parsed = Day.valueOf(\"FRIDAY\");"
                        },
                        "codeExplanations": {
                            "english": "The Day enum defines seven constants representing days of the week. Usage resembles static fields with type safety. The values() method iterates all constants, and valueOf() converts strings to enum constants, throwing IllegalArgumentException for invalid names."
                        },
                        "keyPoints": [
                            "Enums define a fixed set of named constants with type safety",
                            "Implicitly extend java.lang.Enum; cannot extend other classes",
                            "Constants are public static final instances of the enum type",
                            "Built-in methods: values(), valueOf(), ordinal(), name(), compareTo()"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-9-2",
                        "title": "Type-safe Constants",
                        "explanations": {
                            "english": "Type-safe constants via enums eliminate the weaknesses of traditional integer or string constant patterns, preventing invalid values at compile time rather than runtime. Unlike public static final int constants, enum constants cannot be assigned arbitrary integers or confused with unrelated constants of the same value. Enums participate in switch statements with compiler checking for exhaustive coverage, warning if cases are missing. The type system ensures that methods accepting an enum parameter only receive valid declared constants, eliminating the need for defensive validation. This safety extends to serialization, where enums maintain singleton guarantees, and to debugging, where meaningful names replace magic numbers."
                        },
                        "code": {
                            "title": "Type Safety Benefits",
                            "language": "java",
                            "content": "// Integer constants (unsafe)\npublic static final int STATUS_PENDING = 0;\npublic static final int STATUS_ACTIVE = 1;\nsetStatus(999); // Compiles but invalid!\n\n// Enum (type-safe)\npublic enum Status { PENDING, ACTIVE, CLOSED }\n\npublic void setStatus(Status s) { /* ... */ }\n\nsetStatus(Status.PENDING); // Valid\n// setStatus(999); // Compile error!\n// setStatus(\"PENDING\"); // Compile error!\n\n// Switch safety\nswitch (status) {\n    case PENDING: break;\n    case ACTIVE: break;\n    case CLOSED: break;\n    // Missing case causes compiler warning\n}"
                        },
                        "codeExplanations": {
                            "english": "The comparison shows integer constants accepting any int value at compile time, requiring runtime validation. Enums reject invalid values at compile time. The switch statement demonstrates exhaustiveness checking, where the compiler can verify all enum constants are handled."
                        },
                        "keyPoints": [
                            "Compiler prevents assignment of invalid values, catching errors early",
                            "Cannot confuse enum constants with different enums or arbitrary values",
                            "Switch statements provide exhaustiveness checking for enums",
                            "Eliminates need for manual range checking and validation code"
                        ],
                        "extras": {
                            "flowDiagram": "Integer constant: setStatus(999) → Compile OK → Runtime error/bug\nEnum constant: setStatus(999) → Compile ERROR → Catch early",
                            "comparisonTable": "Feature|int Constants|Enums\nType safety|None|Full\nNamespace|Global|Scoped to enum\nSwitch safety|None|Exhaustiveness check\nValidation|Manual|Automatic\nDebugging|Magic numbers|Meaningful names",
                            "examples": []
                        }
                    },
                    {
                        "id": "s1-9-3",
                        "title": "Enum Fields & Methods",
                        "explanations": {
                            "english": "Enums in Java can declare fields, methods, and constructors to associate data and behavior with constants, making them powerful class-like structures. Each enum constant can have its own implementation of abstract methods, effectively allowing polymorphic behavior per constant. Constructors must be private or package-private, invoked automatically when constants are created during class loading. Fields store state specific to each constant instance, such as display names or associated values. Methods can operate on the enum's state or provide utility functionality. This capability transforms enums from simple constant lists into rich objects with encapsulation, enabling complex domain modeling like state machines with transition logic or configuration with associated metadata."
                        },
                        "code": {
                            "title": "Enum with Fields and Methods",
                            "language": "java",
                            "content": "public enum Planet {\n    MERCURY(3.303e+23, 2.4397e6),\n    VENUS(4.869e+24, 6.0518e6),\n    EARTH(5.976e+24, 6.37814e6);\n    \n    private final double mass;\n    private final double radius;\n    \n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    \n    public double surfaceGravity() {\n        return 6.67300E-11 * mass / (radius * radius);\n    }\n    \n    public double surfaceWeight(double otherMass) {\n        return otherMass * surfaceGravity();\n    }\n}\n\n// Usage\ndouble weightOnEarth = Planet.EARTH.surfaceWeight(80);"
                        },
                        "codeExplanations": {
                            "english": "This enum defines planets with mass and radius fields initialized via a private constructor. Each constant (MERCURY, VENUS, EARTH) calls the constructor with its specific values. Instance methods calculate surface gravity and weight, demonstrating how enums encapsulate data and behavior like regular classes."
                        },
                        "keyPoints": [
                            "Enums can have fields, constructors, and methods like regular classes",
                            "Constructors must be private; called automatically for each constant",
                            "Each enum constant can have unique data passed via constructor",
                            "Abstract methods can be overridden per constant for polymorphic behavior"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "State machine with transitions",
                                "Error codes with messages and HTTP status"
                            ]
                        }
                    },
                    {
                        "id": "s1-9-4",
                        "title": "Enum vs Constant Interfaces",
                        "explanations": {
                            "english": "Constant interfaces are an anti-pattern where interfaces are used solely to export constants to implementing classes, a practice deprecated by Java's static import feature and enums. Enums provide superior type safety, namespace scoping, and compile-time checking compared to constants scattered across interfaces or classes. Constant interfaces pollute the implementing class's public API, expose implementation details, and cannot prevent values from changing. Enums group related constants under a single type with built-in iteration and conversion methods. While constant interfaces were common in early Java for event codes or status flags, modern practice favors enums for discrete value sets or static final fields in utility classes for constants not requiring type safety."
                        },
                        "code": {
                            "title": "Comparison Patterns",
                            "language": "java",
                            "content": "// Constant Interface (Anti-pattern)\npublic interface MathConstants {\n    double PI = 3.14159;\n    double E = 2.71828;\n}\n\n// Enum replacement\npublic enum MathConstant {\n    PI(3.14159),\n    E(2.71828);\n    \n    private final double value;\n    MathConstant(double v) { this.value = v; }\n    public double value() { return value; }\n}\n\n// Static import alternative\npublic class Constants {\n    public static final int MAX_SIZE = 100;\n}\n// import static Constants.MAX_SIZE;"
                        },
                        "codeExplanations": {
                            "english": "The constant interface pattern forces implementers to inherit constants, polluting their namespace. The enum version provides type-safe, scoped constants with the ability to attach behavior. For simple constants not needing type safety, static imports from utility classes are preferred over interfaces."
                        },
                        "keyPoints": [
                            "Constant interfaces are anti-patterns; avoid using interfaces for constants only",
                            "Enums provide type safety and scoping that constant interfaces lack",
                            "n",
                            "Static imports provide namespace access without interface implementation",
                            "Enums prevent namespace pollution and provide iteration/lookup utilities"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Aspect|Constant Interface|Enum\nType safety|None|Full\nNamespace|Pollutes implementer|Scoped to enum\nIteration|Not possible|values() method\nImplementation|Inheritance required|No inheritance\nCompile-time checking|None|Exhaustive switch checks",
                            "examples": []
                        }
                    }
                ]
            },
            {
                "id": "section-2",
                "title": "Object-Oriented Programming (OOP) Concepts",
                "topics": [
                    {
                        "id": "s2-1-1",
                        "title": "Class Structure",
                        "explanations": {
                            "english": "A class in Java is a blueprint or template that defines the structure and behavior of objects. It serves as a user-defined data type that encapsulates data (fields/attributes) and operations (methods) that operate on that data. A class declaration includes modifiers (public, abstract, final), the class keyword, the class name, optional inheritance (extends) and interface implementation (implements) clauses, and a body containing fields, constructors, methods, and nested types. The class body defines the state variables (instance and static fields) and behaviors that instances of the class will possess. Well-designed classes follow the Single Responsibility Principle, keeping related data and behavior together while hiding implementation details from outside access."
                        },
                        "code": {
                            "title": "Class Declaration Structure",
                            "language": "java",
                            "content": "public class Employee {\n    // Fields (state)\n    private String name;\n    private int id;\n    private double salary;\n    \n    // Constructor\n    public Employee(String name, int id, double salary) {\n        this.name = name;\n        this.id = id;\n        this.salary = salary;\n    }\n    \n    // Methods (behavior)\n    public void raiseSalary(double percentage) {\n        this.salary += this.salary * (percentage / 100);\n    }\n    \n    public String getDetails() {\n        return id + \": \" + name + \" ($\" + salary + \")\";\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This Employee class demonstrates the standard structure: private fields encapsulate state, a constructor initializes new instances, and public methods provide controlled access to behavior. The raiseSalary method modifies internal state while getDetails provides formatted read access, illustrating data hiding with behavior."
                        },
                        "keyPoints": [
                            "Classes are templates defining object structure (fields) and behavior (methods)",
                            "Access modifiers control visibility; private fields with public methods is standard",
                            "Constructors initialize new objects; multiple constructors can be overloaded",
                            "Class names use PascalCase and typically represent nouns or entities"
                        ],
                        "extras": {
                            "flowDiagram": "Class Declaration → Fields → Constructors → Methods → Nested Types",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-1-2",
                        "title": "Object Creation",
                        "explanations": {
                            "english": "Object creation in Java involves instantiation, where the 'new' keyword allocates memory and invokes a constructor to initialize a new instance of a class. The process begins with the new operator allocating heap memory for the object's instance fields, then calling the constructor to set initial state. The 'new' expression returns a reference (memory address) stored in a reference variable, allowing access to the object's members via the dot (.) operator. Each object maintains its own copy of instance variables, separate from other instances of the same class. Object creation triggers the class constructor chain, potentially invoking parent class constructors first through implicit or explicit super() calls."
                        },
                        "code": {
                            "title": "Creating Objects",
                            "language": "java",
                            "content": "// Declaration and instantiation\nEmployee emp1 = new Employee(\"Alice\", 101, 50000.0);\n\n// Multiple references to same object\nEmployee emp2 = emp1;\nemp2.raiseSalary(10); // Affects emp1 too\n\n// Separate objects\nEmployee emp3 = new Employee(\"Bob\", 102, 60000.0);\n\n// Anonymous object\nnew Employee(\"Temp\", 999, 0.0).getDetails();"
                        },
                        "codeExplanations": {
                            "english": "The code shows object instantiation with new, assignment of references, and the difference between copying references (emp2=emp1 points to same object) and creating new objects (emp3 is separate). Anonymous objects are created and used immediately without storing references, useful for one-time operations."
                        },
                        "keyPoints": [
                            "new keyword allocates memory and invokes constructor to create instances",
                            "Object references store memory addresses pointing to heap-allocated objects",
                            "Multiple variables can reference the same object (aliasing)",
                            "Each new operation creates a distinct object with its own field values"
                        ],
                        "extras": {
                            "flowDiagram": "new Employee() → Heap Allocation → Constructor Execution → Reference Return → Variable Assignment",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-1-3",
                        "title": "State vs Behavior",
                        "explanations": {
                            "english": "State and behavior are the two fundamental aspects of objects in OOP. State represents the current condition or data of an object, stored in fields (instance variables) that maintain values specific to each instance. Behavior represents what an object can do or what can be done to it, implemented through methods that operate on the object's state. The separation of state (data) and behavior (operations) allows objects to maintain consistent internal conditions while exposing controlled functionality to other objects. Well-designed objects hide their state (encapsulation) and expose behavior through well-defined interfaces, ensuring that state changes occur only through validated methods that maintain object integrity and invariants."
                        },
                        "code": {
                            "title": "State and Behavior Example",
                            "language": "java",
                            "content": "public class BankAccount {\n    // State (fields)\n    private String accountNumber;\n    private double balance;\n    private boolean active;\n    \n    // Behavior (methods)\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    public boolean withdraw(double amount) {\n        if (amount > 0 && balance >= amount) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "BankAccount encapsulates state (accountNumber, balance, active) and exposes behavior (deposit, withdraw, getBalance). The balance state can only be modified through methods that enforce business rules (positive amounts, sufficient funds), preventing invalid states that direct field access would allow."
                        },
                        "keyPoints": [
                            "State (fields) represents object data; behavior (methods) represents operations",
                            "State should be private; behavior public to control access",
                            "Methods maintain object invariants by validating state changes",
                            "Behavior can depend on current state to make decisions"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Aspect|State|Behavior\nRepresentation|Fields/Variables|Methods\nAccess|Private (encapsulated)|Public (interface)\nPurpose|Store data|Operate on data\nModification|Through methods only|Executes logic",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-1-4",
                        "title": "Object Lifecycle",
                        "explanations": {
                            "english": "The object lifecycle in Java encompasses creation, usage, and destruction phases managed by the JVM. Creation occurs when 'new' is invoked, allocating memory and running constructors to reach a ready state. During usage, the object is referenced by variables and actively participates in program operations, with its state potentially changing through method invocations. Objects become eligible for destruction when no live thread holds any reference to them (unreachable). The JVM garbage collector automatically reclaims this memory, calling the finalize() method (deprecated in modern Java) before destruction if overridden. Unlike C++, Java does not support object destruction on demand, relying on automatic garbage collection to prevent memory leaks while simplifying developer responsibility."
                        },
                        "code": {
                            "title": "Lifecycle Demonstration",
                            "language": "java",
                            "content": "public class LifecycleDemo {\n    public LifecycleDemo() {\n        System.out.println(\"Object created\");\n    }\n    \n    public void doWork() {\n        System.out.println(\"Object in use\");\n    }\n    \n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"Object being destroyed\");\n    }\n    \n    public static void main(String[] args) {\n        LifecycleDemo obj = new LifecycleDemo(); // Creation\n        obj.doWork(); // Usage\n        obj = null; // Dereference\n        System.gc(); // Suggest garbage collection\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The constructor prints on creation, doWork represents the active usage phase, and setting the reference to null makes the object eligible for garbage collection. finalize() (deprecated) would print before destruction if called. System.gc() is a hint to the JVM, not a forced destruction command."
                        },
                        "keyPoints": [
                            "Objects begin life when new allocates memory and constructors run",
                            "Active phase involves method calls and state modifications",
                            "Objects become eligible for GC when unreachable (no references)",
                            "Garbage collector automatically reclaims memory; destruction timing is non-deterministic"
                        ],
                        "extras": {
                            "flowDiagram": "new → [Created] → Reference Assigned → [In Use] → Reference Null → [Eligible for GC] → finalize() → [Destroyed]",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-2-1",
                        "title": "Single Inheritance",
                        "explanations": {
                            "english": "Single inheritance in Java allows a class to extend exactly one parent class, establishing an 'is-a' relationship where the subclass inherits fields and methods from its superclass. This prevents the complexity and ambiguity of multiple inheritance (diamond problem) while enabling code reuse and hierarchical classification. The subclass gains access to inherited members based on their visibility (public and protected members are accessible, private are not). Java uses the 'extends' keyword to establish this relationship. Single inheritance promotes cleaner class hierarchies and forces developers to use composition for sharing functionality from multiple sources, leading to more maintainable and less coupled designs."
                        },
                        "code": {
                            "title": "Single Inheritance Example",
                            "language": "java",
                            "content": "// Parent class\npublic class Vehicle {\n    protected String brand;\n    \n    public void honk() {\n        System.out.println(\"Beep beep!\");\n    }\n}\n\n// Child class\npublic class Car extends Vehicle {\n    private int trunkCapacity;\n    \n    public void displayBrand() {\n        System.out.println(\"Brand: \" + brand); // Inherited field\n    }\n}\n\n// Usage\nCar myCar = new Car();\nmyCar.honk(); // Inherited method\nmyCar.displayBrand(); // Own method"
                        },
                        "codeExplanations": {
                            "english": "Vehicle is the parent with a protected field brand and method honk(). Car extends Vehicle, inheriting these members and adding its own trunkCapacity field. The Car instance can use both inherited honk() and its own displayBrand() method, demonstrating the is-a relationship."
                        },
                        "keyPoints": [
                            "Java supports single inheritance: a class can extend only one direct superclass",
                            "extends keyword establishes the parent-child relationship",
                            "Child inherits accessible fields and methods from parent",
                            "Promotes composition over multiple inheritance for cleaner designs"
                        ],
                        "extras": {
                            "flowDiagram": "Vehicle (superclass)\n    ↑ extends\n   Car (subclass)",
                            "comparisonTable": "Feature|Inheritance|Composition\nRelationship|Is-a|Has-a\nKeyword|extends|Instance field\nCoupling|Tight|Loose\nMultiple|Not allowed|Unlimited",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-2-2",
                        "title": "Multilevel Inheritance",
                        "explanations": {
                            "english": "Multilevel inheritance creates a chain of inheritance where a class extends a subclass, which in turn extends another class, forming a hierarchy with multiple levels. While this allows progressive specialization (e.g., Vehicle → Car → ElectricCar), deep inheritance chains increase complexity and reduce maintainability. Each level inherits all accessible members from its ancestors, potentially leading to fragile base class problems where changes in high-level classes break lower-level implementations. Java permits this pattern but recommends keeping inheritance hierarchies shallow (preferably no deeper than 3 levels) to preserve code clarity and reduce coupling between distant ancestors and descendants."
                        },
                        "code": {
                            "title": "Multilevel Chain",
                            "language": "java",
                            "content": "class Animal {\n    void eat() { System.out.println(\"Eating...\"); }\n}\n\nclass Mammal extends Animal {\n    void breathe() { System.out.println(\"Breathing...\"); }\n}\n\nclass Dog extends Mammal {\n    void bark() { System.out.println(\"Woof!\"); }\n}\n\n// Usage\nDog dog = new Dog();\ndog.eat();      // From Animal\ndog.breathe();  // From Mammal\ndog.bark();     // Own method"
                        },
                        "codeExplanations": {
                            "english": "The inheritance chain extends three levels: Animal is the grandparent, Mammal is parent to Dog and child to Animal, and Dog is the grandchild. Dog inherits eat() from Animal and breathe() from Mammal while defining its own bark(). This demonstrates how features accumulate down the hierarchy."
                        },
                        "keyPoints": [
                            "Multilevel inheritance creates parent-child-grandchild relationships",
                            "Each class inherits from its immediate parent, which may inherit from another",
                            "Deep hierarchies complicate maintenance and increase fragility",
                            "Keep inheritance chains shallow (recommended max 3 levels) for maintainability"
                        ],
                        "extras": {
                            "flowDiagram": "Animal\n    ↑\n  Mammal\n    ↑\n    Dog",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-2-3",
                        "title": "Hierarchical Inheritance",
                        "explanations": {
                            "english": "Hierarchical inheritance occurs when multiple classes extend a single parent class, creating a tree-like structure where one superclass has multiple subclasses. This pattern is common for creating specialized variants of a general concept, such as different types of BankAccount (SavingsAccount, CheckingAccount, LoanAccount) extending a base Account class. Each sibling class inherits common functionality from the parent while adding specific features. This promotes code reuse by placing shared behavior in the parent while allowing customization in children. The parent class should be designed to be general enough to support all child implementations without knowing their specific details, following the Liskov Substitution Principle."
                        },
                        "code": {
                            "title": "Hierarchical Structure",
                            "language": "java",
                            "content": "abstract class Shape {\n    protected String color;\n    \n    public abstract double calculateArea();\n    \n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width, height;\n    \n    public double calculateArea() {\n        return width * height;\n    }\n}\n\nclass Triangle extends Shape {\n    private double base, height;\n    \n    public double calculateArea() {\n        return 0.5 * base * height;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Shape serves as the parent with common color field and abstract calculateArea(). Three subclasses (Circle, Rectangle, Triangle) inherit color and setColor() but provide distinct area calculations. This hierarchy allows treating all shapes polymorphically while each implements specific geometry."
                        },
                        "keyPoints": [
                            "Multiple classes extend the same parent class",
                            "Parent contains common functionality; children add specialization",
                            "Enables polymorphic treatment of sibling classes",
                            "Supports code reuse while allowing specific implementations"
                        ],
                        "extras": {
                            "flowDiagram": "    Shape\n    /  |  \\\nCircle Rectangle Triangle",
                            "comparisonTable": "",
                            "examples": [
                                "Employee ← Manager/Engineer/SalesPerson",
                                "Vehicle ← Car/Truck/Motorcycle"
                            ]
                        }
                    },
                    {
                        "id": "s2-2-4",
                        "title": "super Keyword",
                        "explanations": {
                            "english": "The super keyword in Java provides access to superclass members (fields, methods, constructors) from within a subclass. super.field accesses hidden parent fields when names conflict due to shadowing. super.method() invokes overridden parent methods, allowing extension rather than replacement of behavior. super() calls parent class constructors and must be the first statement in a subclass constructor; if omitted, the compiler inserts a call to the parent's no-arg constructor implicitly. This ensures proper initialization of inherited state before subclass initialization. Using super is essential when the subclass needs to leverage or extend parent class functionality while maintaining encapsulation."
                        },
                        "code": {
                            "title": "Super Keyword Usage",
                            "language": "java",
                            "content": "class Person {\n    protected String name;\n    \n    public Person(String name) {\n        this.name = name;\n    }\n    \n    public void display() {\n        System.out.println(\"Name: \" + name);\n    }\n}\n\nclass Employee extends Person {\n    private int employeeId;\n    \n    public Employee(String name, int id) {\n        super(name); // Call parent constructor\n        this.employeeId = id;\n    }\n    \n    @Override\n    public void display() {\n        super.display(); // Call parent method\n        System.out.println(\"ID: \" + employeeId);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Employee constructor uses super(name) to initialize the inherited name field before setting its own employeeId. The overridden display() method uses super.display() to reuse parent's name printing logic, then adds ID printing. Both uses of super prevent code duplication and ensure proper initialization."
                        },
                        "keyPoints": [
                            "super() calls parent constructor; must be first statement in child constructor",
                            "super.method() invokes parent version of overridden methods",
                            "super.field accesses parent fields when hidden by child fields",
                            "If super() is omitted, compiler inserts super() (no-arg) implicitly"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Usage|Syntax|Purpose\nConstructor call|super(args)|Initialize parent state\nMethod call|super.method()|Access parent method implementation\nField access|super.field|Access hidden parent field",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-2-5",
                        "title": "Method Overriding",
                        "explanations": {
                            "english": "Method overriding occurs when a subclass provides a specific implementation for a method already defined in its parent class with identical signature (name, parameter types, return type). The override must have same or less restrictive access modifier and can throw same or fewer checked exceptions (covariant return types allowed). The @Override annotation should be used to signal intent and enable compile-time verification. Overriding enables runtime polymorphism, allowing objects to exhibit different behaviors based on their actual class rather than reference type. The JVM uses dynamic method dispatch to determine which implementation to invoke at runtime based on the object's actual class."
                        },
                        "code": {
                            "title": "Method Overriding",
                            "language": "java",
                            "content": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof\");\n    }\n}\n\n// Usage\nAnimal myPet = new Cat();\nmyPet.makeSound(); // Outputs \"Meow\""
                        },
                        "codeExplanations": {
                            "english": "Animal defines makeSound(), which Cat and Dog override with specific implementations. The @Override annotation verifies the method exists in the parent. When myPet (declared as Animal but holding a Cat) calls makeSound(), the JVM dispatches to Cat's version at runtime, demonstrating polymorphic behavior."
                        },
                        "keyPoints": [
                            "Subclass provides specific implementation of parent method with same signature",
                            "Use @Override annotation to catch signature mismatches at compile time",
                            "Access modifier cannot be more restrictive; return type can be covariant",
                            "Enables runtime polymorphism through dynamic method dispatch"
                        ],
                        "extras": {
                            "flowDiagram": "Reference: Animal → Object: Cat → Calls Cat.makeSound()\nDespite declared type Animal, runtime type determines method",
                            "comparisonTable": "Feature|Overloading|Overriding\nLocation|Same class|Parent-Child classes\nParameters|Must differ|Must be identical\nReturn Type|Can differ|Same or covariant\nBinding|Compile time|Runtime",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-3-1",
                        "title": "Compile-time Polymorphism",
                        "explanations": {
                            "english": "Compile-time polymorphism (static polymorphism) in Java is achieved through method overloading, where multiple methods in the same class share a name but differ in parameter lists. The compiler determines which method to invoke based on the method signature at compile time, hence 'static' binding. This includes differences in parameter count, types, or order. The resolution happens during compilation, making execution faster as no runtime decision is needed. Method overloading provides intuitive interfaces where similar operations share names but handle different data types or argument counts. It improves code readability and reduces the need for artificially distinct method names for related operations."
                        },
                        "code": {
                            "title": "Compile-time Polymorphism",
                            "language": "java",
                            "content": "class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\n// Usage determined at compile time\nCalculator calc = new Calculator();\nint sum1 = calc.add(5, 3);        // Calls int version\ndouble sum2 = calc.add(5.5, 3.2); // Calls double version\nint sum3 = calc.add(1, 2, 3);     // Calls 3-param version"
                        },
                        "codeExplanations": {
                            "english": "The Calculator class demonstrates compile-time polymorphism through three add methods. The compiler selects the appropriate method during compilation based on argument types and count. The int parameters call the int version, doubles call the double version, and three arguments resolve to the three-parameter version."
                        },
                        "keyPoints": [
                            "Achieved through method overloading in the same class",
                            "Compiler binds method calls to definitions during compilation",
                            "Resolution based on method signature (name + parameter types/count)",
                            "Also known as static binding or early binding"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Aspect|Compile-time|Runtime\nBinding time|Compilation|Execution\nMechanism|Overloading|Overriding\nDecision maker|Compiler|JVM\nPerformance|Faster|Runtime overhead",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-3-2",
                        "title": "Runtime Polymorphism",
                        "explanations": {
                            "english": "Runtime polymorphism (dynamic polymorphism) in Java is achieved through method overriding, where the actual object's type determines which method implementation is executed, not the reference type. This allows a parent class reference to point to child class objects and invoke overridden methods specific to the child's implementation. The JVM uses dynamic method dispatch to resolve the method call at runtime by examining the object's class in memory. This enables writing flexible, extensible code that works with superclass references while executing subclass-specific behaviors. It's the foundation of frameworks, plugin architectures, and dependency injection where implementations can be swapped without changing client code."
                        },
                        "code": {
                            "title": "Runtime Polymorphism",
                            "language": "java",
                            "content": "interface Payment {\n    void process(double amount);\n}\n\nclass CreditCard implements Payment {\n    public void process(double amount) {\n        System.out.println(\"Processing credit card: $\" + amount);\n    }\n}\n\nclass PayPal implements Payment {\n    public void process(double amount) {\n        System.out.println(\"Processing PayPal: $\" + amount);\n    }\n}\n\n// Flexible client code\npublic void checkout(Payment payment, double amount) {\n    payment.process(amount); // Runtime decision\n}\n\n// Usage\ncheckout(new CreditCard(), 100.0); // CreditCard's process\ncheckout(new PayPal(), 50.0);      // PayPal's process"
                        },
                        "codeExplanations": {
                            "english": "The checkout method accepts any Payment implementation. At runtime, the JVM determines whether the actual object is CreditCard or PayPal and invokes the appropriate process() method. The same checkout code works with any future Payment implementation without modification, demonstrating extensibility through runtime polymorphism."
                        },
                        "keyPoints": [
                            "Method call resolved at runtime based on actual object type, not reference type",
                            "Requires inheritance (class extends) or interface implementation",
                            "n",
                            "Enables substitution of different implementations interchangeably",
                            "Foundation of loosely coupled, extensible architectures"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "Collections.sort() with different Comparator implementations"
                            ]
                        }
                    },
                    {
                        "id": "s2-3-3",
                        "title": "Method Overloading vs Overriding",
                        "explanations": {
                            "english": "Method overloading and overriding are distinct polymorphism mechanisms serving different purposes. Overloading occurs within the same class (or parent-child with inheritance), using the same method name but different parameters; it's a compile-time concept for convenience. Overriding occurs between parent and child classes with identical signatures, allowing runtime specialization; it's an object-oriented concept for behavioral inheritance. Overloading is about 'how many' or 'what type' of arguments, while overriding is about 'which implementation' based on object type. Overloading requires parameter differences, while overriding requires identical signatures. Understanding both is crucial for designing intuitive APIs and inheritance hierarchies."
                        },
                        "code": {
                            "title": "Overloading vs Overriding",
                            "language": "java",
                            "content": "class Parent {\n    // Overloading example\n    public void display(int x) { }\n    public void display(String s) { } // Overloaded\n    \n    public void show() { \n        System.out.println(\"Parent\");\n    }\n}\n\nclass Child extends Parent {\n    // Overriding example\n    @Override\n    public void show() { \n        System.out.println(\"Child\"); // Overridden\n    }\n    \n    // Overloading inherited method\n    public void display(double d) { } // Also overloaded\n}"
                        },
                        "codeExplanations": {
                            "english": "Parent demonstrates overloading with two display methods differing by parameter type. Child overrides show() to provide specific behavior and also overloads display() adding a double version. This shows overloading can occur within a class or across inheritance, while overriding is specific to inheritance."
                        },
                        "keyPoints": [
                            "Overloading: Same name, different parameters, compile-time resolution",
                            "Overriding: Same signature, different implementation, runtime resolution",
                            "Overloading is horizontal (same level); overriding is vertical (hierarchy)",
                            "Overloading is independent of inheritance; overriding requires it"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Criteria|Overloading|Overriding\nClass scope|Same class|Parent-Child\nParameters|Must differ|Must be identical\nReturn type|Can differ|Same or covariant\nAccess modifier|Any|Cannot be more restrictive\nStatic|Allowed|Not applicable to instance methods\nBinding|Compile time|Runtime",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-3-4",
                        "title": "Dynamic Method Dispatch",
                        "explanations": {
                            "english": "Dynamic method dispatch is the mechanism by which the JVM determines which overridden method to invoke at runtime based on the actual object's class, not the reference type. When a method is called on a reference, the JVM examines the object's class in the heap to find the implementation, walking up the inheritance hierarchy if necessary. This late binding enables polymorphism, allowing methods to work with superclass references while executing subclass-specific code. The dispatch is optimized through method tables (vtables) that map methods to their implementations for each class. This mechanism is fundamental to achieving loose coupling and dependency inversion in object-oriented design."
                        },
                        "code": {
                            "title": "Dispatch Mechanism",
                            "language": "java",
                            "content": "class Animal {\n    void speak() { System.out.println(\"Animal speaks\"); }\n}\n\nclass Dog extends Animal {\n    void speak() { System.out.println(\"Dog barks\"); }\n}\n\nclass Cat extends Animal {\n    void speak() { System.out.println(\"Cat meows\"); }\n}\n\npublic void makeItSpeak(Animal animal) {\n    animal.speak(); // JVM decides at runtime\n}\n\n// Demonstration\nmakeItSpeak(new Dog()); // \"Dog barks\"\nmakeItSpeak(new Cat()); // \"Cat meows\""
                        },
                        "codeExplanations": {
                            "english": "makeItSpeak accepts an Animal reference but the JVM inspects the actual object type (Dog or Cat) at runtime to determine which speak() method to execute. This late binding allows the same method call to produce different behaviors without conditional logic, following the Open/Closed Principle."
                        },
                        "keyPoints": [
                            "JVM determines method implementation at runtime based on actual object class",
                            "Enables calling subclass methods through parent class references",
                            "Method resolution walks up hierarchy if method not found in child",
                            "Implemented efficiently via method tables (vtables) for performance"
                        ],
                        "extras": {
                            "flowDiagram": "Call animal.speak() → JVM checks object type → \nIf Dog: execute Dog.speak() → \nIf Cat: execute Cat.speak() →\nFallback to Animal.speak() if not overridden",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-4-1",
                        "title": "Abstract Classes",
                        "explanations": {
                            "english": "Abstract classes in Java are declared with the abstract modifier and cannot be instantiated directly; they serve as templates for concrete subclasses. They may contain abstract methods (declared without implementation) that force subclasses to provide specific implementations, as well as concrete methods with default behavior. Abstract classes can have fields, constructors, and static methods, unlike interfaces pre-Java 8. They represent 'is-a' relationships with partial implementation, useful for sharing code among related classes while enforcing certain methods must be implemented. When a class extends an abstract class, it must implement all abstract methods or be declared abstract itself."
                        },
                        "code": {
                            "title": "Abstract Class Implementation",
                            "language": "java",
                            "content": "abstract class Shape {\n    protected String color;\n    \n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    // Abstract method\n    public abstract double calculateArea();\n    \n    // Concrete method\n    public void displayColor() {\n        System.out.println(\"Color: \" + color);\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Shape is abstract with both an abstract method (calculateArea) forcing implementation and a concrete method (displayColor) providing shared functionality. Circle extends Shape, implements calculateArea, and calls super constructor. Abstract classes cannot be instantiated with 'new', only subclassed."
                        },
                        "keyPoints": [
                            "Cannot be instantiated; must be extended by concrete classes",
                            "n",
                            "Can contain both abstract (no body) and concrete (with body) methods",
                            "May have fields, constructors, and initialization blocks",
                            "Forces subclass implementation of abstract methods via compilation checks"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-4-2",
                        "title": "Interfaces",
                        "explanations": {
                            "english": "Interfaces in Java define contracts that classes agree to implement, specifying methods without providing implementation (prior to Java 8). Declared with the interface keyword, they contain method signatures and static final constants by default. Since Java 8, interfaces can include default methods with implementations and static methods. Java 9 added private methods for code reuse within interfaces. Interfaces support multiple inheritance of type, allowing a class to implement multiple interfaces. They represent 'can-do' capabilities (e.g., Comparable, Serializable) and enable loose coupling by programming to interfaces rather than concrete classes. All methods are implicitly public abstract unless specified otherwise."
                        },
                        "code": {
                            "title": "Interface Definition",
                            "language": "java",
                            "content": "interface Drawable {\n    // Implicitly public abstract\n    void draw();\n    \n    // Default method (Java 8+)\n    default void printInfo() {\n        System.out.println(\"This is drawable\");\n    }\n    \n    // Static method\n    static void describe() {\n        System.out.println(\"Drawable interface\");\n    }\n}\n\nclass Rectangle implements Drawable {\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing rectangle\");\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Drawable interface defines a contract with abstract draw() method that Rectangle must implement. The default method printInfo() provides shared implementation that implementing classes can use or override. Static method describe() belongs to the interface itself, not instances. Rectangle provides concrete implementation of the abstract method."
                        },
                        "keyPoints": [
                            "Defines method signatures without implementation (contracts)",
                            "Classes implement interfaces using implements keyword",
                            "Support multiple inheritance (class can implement multiple interfaces)",
                            "Java 8+ allows default and static methods with implementations"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "List, Runnable, Comparable, Serializable"
                            ]
                        }
                    },
                    {
                        "id": "s2-4-3",
                        "title": "Abstract Class vs Interface",
                        "explanations": {
                            "english": "Abstract classes and interfaces serve different design purposes in Java. Abstract classes represent 'is-a' relationships with shared state or partial implementation, allowing fields and constructors. Interfaces represent 'can-do' capabilities without state, providing only behavior contracts. A class extends only one abstract class (single inheritance) but implements multiple interfaces. Abstract classes are ideal for closely related classes sharing code, while interfaces suit unrelated classes sharing capabilities. Since Java 8 with default methods, the line has blurred, but state remains the key differentiator—interfaces cannot have instance fields (only constants). Choose abstract classes for class hierarchies, interfaces for cross-cutting concerns and multiple inheritance of type."
                        },
                        "code": {
                            "title": "Choosing Between Them",
                            "language": "java",
                            "content": "// Abstract class for shared state\nabstract class Vehicle {\n    protected String engineType; // State shared\n    \n    public void startEngine() { // Shared behavior\n        System.out.println(\"Engine started\");\n    }\n    \n    public abstract void move();\n}\n\n// Interface for capabilities across hierarchies\ninterface Flyable {\n    void fly(); // No state, just ability\n}\n\ninterface Swimmable {\n    void swim();\n}\n\n// Concrete implementation\nclass AmphibiousPlane extends Vehicle implements Flyable, Swimmable {\n    public void move() { /* ... */ }\n    public void fly() { /* ... */ }\n    public void swim() { /* ... */ }\n}"
                        },
                        "codeExplanations": {
                            "english": "Vehicle as abstract class shares engineType state and startEngine behavior among land vehicles. Flyable and Swimmable are interfaces representing capabilities that cross inheritance boundaries. AmphibiousPlane inherits state from Vehicle while gaining multiple capabilities from interfaces, demonstrating when to use each construct."
                        },
                        "keyPoints": [
                            "Abstract classes: State + partial implementation, single inheritance",
                            "Interfaces: Behavior contracts only, multiple inheritance allowed",
                            "Use abstract classes for 'is-a' relationships with shared code",
                            "Use interfaces for 'can-do' capabilities across class hierarchies"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Feature|Abstract Class|Interface\nInheritance|Single (extends)|Multiple (implements)\nState|Instance fields allowed|Only constants (static final)\nConstructors|Allowed|Not allowed\nMethod implementation|Allowed|Allowed (default/static since Java 8)\nAccess modifiers|Any|Methods implicitly public\nUse case|Shared base code|Capability contracts",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-4-4",
                        "title": "Default Methods",
                        "explanations": {
                            "english": "Default methods, introduced in Java 8, allow interfaces to contain method implementations with the default keyword, bridging the gap between interfaces and abstract classes. They enable adding new methods to existing interfaces without breaking backward compatibility, as implementing classes inherit the default implementation. Default methods have default access (implicitly public) and can be overridden by implementing classes if specific behavior is needed. They cannot override Object methods (equals, hashCode, toString) and can access only static interface members. When a class implements multiple interfaces with conflicting default methods, it must override the method to resolve ambiguity. Default methods facilitate API evolution while maintaining functional interfaces."
                        },
                        "code": {
                            "title": "Default Method Usage",
                            "language": "java",
                            "content": "interface Logger {\n    void log(String message);\n    \n    default void logInfo(String message) {\n        log(\"[INFO] \" + message);\n    }\n    \n    default void logError(String message) {\n        log(\"[ERROR] \" + message);\n    }\n}\n\nclass ConsoleLogger implements Logger {\n    public void log(String message) {\n        System.out.println(message);\n    }\n    // Inherits logInfo and logError automatically\n}\n\nclass FileLogger implements Logger {\n    public void log(String message) {\n        // Write to file\n    }\n    \n    @Override\n    public void logError(String message) {\n        // Custom error handling with timestamp\n        log(\"[ERROR] \" + System.currentTimeMillis() + \" \" + message);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Logger interface defines abstract log() that all implementers must provide, while default methods logInfo and logError provide standard formatting that classes can inherit. ConsoleLogger uses inherited defaults, while FileLogger overrides logError to add timestamps. This allows interface extension without forcing all implementers to update."
                        },
                        "keyPoints": [
                            "Allow interfaces to provide method implementations with default keyword",
                            "Added in Java 8 to enable interface evolution without breaking existing code",
                            "Implementing classes inherit default implementation automatically",
                            "Can be overridden when custom behavior is needed; resolve conflicts if multiple interfaces define same default"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "List.sort() default method in Collections API"
                            ]
                        }
                    },
                    {
                        "id": "s2-5-1",
                        "title": "Private Fields",
                        "explanations": {
                            "english": "Private fields in Java encapsulate object state by restricting direct access from outside the class, enforcing data hiding and integrity. Declared with the private modifier, these fields are accessible only within the declaring class, preventing external code from setting invalid values or corrupting object state. This encapsulation allows the class to maintain invariants—conditions that must always be true—by controlling all modifications through methods that validate changes. Private fields represent the internal implementation details that can change without affecting client code, adhering to the principle of loose coupling. Proper encapsulation with private fields is fundamental to robust object-oriented design, ensuring that objects manage their own state consistently."
                        },
                        "code": {
                            "title": "Private Field Encapsulation",
                            "language": "java",
                            "content": "public class BankAccount {\n    private String accountNumber;\n    private double balance;\n    private int transactionCount;\n    \n    public BankAccount(String accountNumber, double initialBalance) {\n        if (accountNumber == null || accountNumber.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid account number\");\n        }\n        if (initialBalance < 0) {\n            throw new IllegalArgumentException(\"Initial balance cannot be negative\");\n        }\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n        this.transactionCount = 0;\n    }\n    \n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            transactionCount++;\n        }\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "All fields are private, preventing direct external modification. The constructor validates inputs to establish valid initial state. deposit() method controls how balance changes, ensuring only positive amounts are added and tracking transaction count. External code must use methods to interact with state, maintaining data integrity."
                        },
                        "keyPoints": [
                            "Private fields hide internal state from external access",
                            "Access restricted to methods within the same class",
                            "Enables validation and control over all state changes",
                            "Protects class invariants and allows internal implementation changes"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Modifier|Class|Package|Subclass|World\nprivate|Yes|No|No|No\nprotected|Yes|Yes|Yes|No\npublic|Yes|Yes|Yes|Yes\ndefault|Yes|Yes|No|No",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-5-2",
                        "title": "Getters & Setters",
                        "explanations": {
                            "english": "Getters (accessors) and setters (mutators) provide controlled access to private fields, forming the standard JavaBeans pattern for property access. Getters retrieve field values, often named getFieldName() for objects/isFieldName() for booleans, allowing read access without exposing the field directly. Setters modify field values, named setFieldName(), enabling validation, logging, or triggering side effects during modification. This indirection allows changing internal representation (e.g., storing age as birth year) while maintaining the same public interface. Modern IDEs generate these methods automatically, and validation in setters ensures objects maintain valid states. They form the foundation of read-only (getter only), write-only (setter only), or calculated properties."
                        },
                        "code": {
                            "title": "Getter and Setter Pattern",
                            "language": "java",
                            "content": "public class Person {\n    private String name;\n    private int age;\n    private boolean active;\n    \n    // Getter\n    public String getName() {\n        return name;\n    }\n    \n    // Setter with validation\n    public void setAge(int age) {\n        if (age < 0 || age > 150) {\n            throw new IllegalArgumentException(\"Invalid age\");\n        }\n        this.age = age;\n    }\n    \n    // Getter for boolean (is convention)\n    public boolean isActive() {\n        return active;\n    }\n    \n    // Read-only property (no setter)\n    public int getBirthYear(int currentYear) {\n        return currentYear - age;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Standard naming conventions: getName returns the name field, setAge validates before setting to ensure valid data. Boolean property uses isActive() convention. Read-only calculated property getBirthYear computes value from age without storing separate field. No setter for name makes it effectively immutable after construction."
                        },
                        "keyPoints": [
                            "Getters provide read access to private fields with get/is prefix",
                            "Setters provide controlled write access with validation logic",
                            "Enable calculated properties and internal representation changes",
                            "Follow naming conventions: getX(), setX(), isX() for booleans"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Type|Method|Access\nRead/Write|getX() + setX()|Full access\nRead-only|getX() only|Immutable after construction\nWrite-only|setX() only|Rare, for dependency injection\nCalculated|getX() computes|Virtual property, no backing field",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-5-3",
                        "title": "Data Hiding",
                        "explanations": {
                            "english": "Data hiding is an OOP principle that conceals internal object state and implementation details from external access, exposing only necessary functionality through well-defined interfaces. By making fields private and providing public methods for access, classes protect their invariants and prevent invalid states that could arise from direct manipulation. This abstraction allows internal representations to change—such as changing from storing full name to first and last names separately—without affecting client code using the class. Data hiding reduces system complexity by preventing direct dependencies on implementation details and minimizes the ripple effect of changes. It enforces encapsulation, ensuring that objects remain in consistent states and that behavior is the primary interaction mechanism."
                        },
                        "code": {
                            "title": "Data Hiding Implementation",
                            "language": "java",
                            "content": "public class CreditCard {\n    // Hidden implementation details\n    private String cardNumber;\n    private String encryptedData;\n    private LocalDate expiryDate;\n    \n    public CreditCard(String cardNumber, LocalDate expiry) {\n        this.cardNumber = maskNumber(cardNumber);\n        this.encryptedData = encrypt(cardNumber);\n        this.expiryDate = expiry;\n    }\n    \n    public String getMaskedNumber() {\n        return cardNumber; // Returns masked version only\n    }\n    \n    public boolean isValid() {\n        return expiryDate.isAfter(LocalDate.now());\n    }\n    \n    private String maskNumber(String number) {\n        return \"****-****-****-\" + number.substring(12);\n    }\n    \n    private String encrypt(String data) {\n        // Encryption logic\n        return \"encrypted_\" + data;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "CreditCard hides sensitive data: raw card number is never exposed; only masked version is available via getter. Internal storage uses encryption, but this detail is hidden from clients. isValid() provides behavior-based access rather than exposing the date. Implementation can change encryption algorithm without affecting users."
                        },
                        "keyPoints": [
                            "Hide internal state and implementation complexity from clients",
                            "Prevent unauthorized or invalid state modifications",
                            "Allow internal representation changes without breaking client code",
                            "Expose only necessary operations through public methods"
                        ],
                        "extras": {
                            "flowDiagram": "Client Code → Public Methods (Getters/Setters/Business Logic) → Private Fields/Implementation\nDirect access to fields blocked: X",
                            "comparisonTable": "Aspect|Without Hiding|With Hiding\nState access|Direct, uncontrolled|Via methods only\nValidation|In client code|In class methods\nCoupling|Tight|Loose\nMaintenance|Changes break clients|Internal changes hidden",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-5-4",
                        "title": "Benefits of Encapsulation",
                        "explanations": {
                            "english": "Encapsulation provides numerous software engineering benefits by bundling data and behavior while restricting direct access to internal state. It enables modularity by creating self-contained units with clear interfaces, reducing system complexity. Maintenance becomes easier as internal implementations can change without affecting dependent code, provided the public interface remains stable. Encapsulation supports validation by ensuring all state changes pass through methods that enforce business rules and invariants. It enhances security by protecting sensitive data from external tampering. The principle also facilitates debugging by localizing state management within the class, making it easier to track modifications. Overall, encapsulation creates robust, flexible systems that withstand requirements changes and reduce defect introduction during evolution."
                        },
                        "code": {
                            "title": "Encapsulation Benefits",
                            "language": "java",
                            "content": "public class Temperature {\n    private double celsius;\n    \n    // Validation benefit: reject invalid temperatures\n    public void setCelsius(double value) {\n        if (value < -273.15) {\n            throw new IllegalArgumentException(\"Below absolute zero\");\n        }\n        this.celsius = value;\n    }\n    \n    // Flexibility benefit: change representation, keep interface\n    public double getFahrenheit() {\n        return (celsius * 9/5) + 32;\n    }\n    \n    public void setFahrenheit(double f) {\n        this.celsius = (f - 32) * 5/9;\n    }\n    \n    // Read-only calculated property\n    public boolean isFreezing() {\n        return celsius <= 0;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This class demonstrates encapsulation benefits: validation prevents physically impossible temperatures in setCelsius. Flexibility allows offering both Celsius and Fahrenheit interfaces while storing only Celsius internally—could switch to Kelvin storage without changing public API. isFreezing() provides derived information without exposing raw data."
                        },
                        "keyPoints": [
                            "Decouples interface from implementation, allowing internal changes",
                            "Enables input validation and invariant enforcement at class boundaries",
                            "Creates modular, self-contained components with clear contracts",
                            "Protects object integrity and facilitates maintenance"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Benefit|Description\nFlexibility|Change internals without breaking clients\nValidation|Centralize business rules in setters\nSecurity|Protect sensitive data from direct access\nDebugging|Control points for state changes\nMaintenance|Localized impact of modifications",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-6-1",
                        "title": "Default Constructor",
                        "explanations": {
                            "english": "A default constructor in Java is a no-argument constructor provided automatically by the compiler when no constructors are explicitly defined in a class. It initializes objects with default values (zero for numbers, false for booleans, null for references) and calls the superclass no-arg constructor implicitly. If any constructor is explicitly defined, the compiler does not generate a default constructor, requiring explicit definition if no-arg instantiation is needed. The default constructor has the same access modifier as the class. While convenient, relying on default constructors often leads to objects in invalid states; explicit constructors with parameters are preferred for ensuring proper initialization. Understanding when the compiler provides defaults versus requiring explicit definition is crucial for class design."
                        },
                        "code": {
                            "title": "Default Constructor Behavior",
                            "language": "java",
                            "content": "public class Employee {\n    private String name;\n    private int id;\n    \n    // No constructors defined - compiler provides:\n    // public Employee() { super(); }\n}\n\npublic class Manager {\n    private String department;\n    \n    // Explicit constructor prevents default\n    public Manager(String department) {\n        this.department = department;\n    }\n    \n    // Must explicitly define if needed\n    public Manager() {\n        this.department = \"Unassigned\";\n    }\n}\n\n// Usage\nEmployee emp = new Employee(); // Works - default constructor\nManager mgr = new Manager();   // Works - explicit no-arg constructor"
                        },
                        "codeExplanations": {
                            "english": "Employee has no constructors defined, so Java provides a public default constructor allowing new Employee(). Manager originally had only a parameterized constructor, which would prevent default instantiation until the explicit no-arg constructor was added. This shows the importance of providing both when both instantiation patterns are needed."
                        },
                        "keyPoints": [
                            "Compiler provides no-arg constructor only if no constructors are defined",
                            "n",
                            "Initializes fields to default values (0, false, null)",
                            "Calls super() implicitly to initialize parent class",
                            "Once you define any constructor, default is not generated"
                        ],
                        "extras": {
                            "flowDiagram": "new Employee()\n    ↓\nProvided by compiler:\nEmployee() {\n    super();\n    name = null;\n    id = 0;\n}",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-6-2",
                        "title": "Parameterized Constructor",
                        "explanations": {
                            "english": "Parameterized constructors accept arguments to initialize object state with specific values rather than defaults, ensuring objects are created in valid states. They allow mandatory data to be required at instantiation time, preventing null or invalid values that could occur with setters called after construction. Multiple parameterized constructors can be provided through overloading, offering different initialization options based on available data. The 'this' keyword distinguishes between parameters and fields with the same name. Parameterized constructors should validate arguments and throw exceptions for invalid inputs. They are essential for immutable objects where all state must be set during creation, and they establish class invariants immediately."
                        },
                        "code": {
                            "title": "Parameterized Constructor Usage",
                            "language": "java",
                            "content": "public class Book {\n    private final String isbn;\n    private String title;\n    private int pageCount;\n    \n    // Primary constructor\n    public Book(String isbn, String title, int pages) {\n        if (isbn == null || isbn.isEmpty()) {\n            throw new IllegalArgumentException(\"ISBN required\");\n        }\n        if (pages <= 0) {\n            throw new IllegalArgumentException(\"Invalid page count\");\n        }\n        this.isbn = isbn;\n        this.title = title;\n        this.pageCount = pages;\n    }\n    \n    // Overloaded constructor\n    public Book(String isbn, String title) {\n        this(isbn, title, 0); // Delegate to primary\n    }\n}\n\n// Usage\nBook book = new Book(\"978-0134685991\", \"Clean Code\", 464);"
                        },
                        "codeExplanations": {
                            "english": "The primary constructor validates all inputs, ensuring non-null ISBN and positive page count, establishing valid state immediately. The overloaded constructor delegates to the primary using this(), providing flexibility while maintaining validation in one place. Final field isbn must be set in constructor, enforcing immutability for that field."
                        },
                        "keyPoints": [
                            "Accept parameters to initialize objects with specific values",
                            "Should validate inputs to ensure objects start in valid states",
                            "Multiple constructors can be overloaded for flexibility",
                            "Use this() to delegate initialization to primary constructor"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Type|Parameters|Use Case\nDefault|None|Simple objects with defaults\nParameterized|Required fields|Objects requiring specific initial state\nCopy|Object to copy|Creating duplicates\nBuilder pattern|Multiple optional|Complex objects with many options",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-6-3",
                        "title": "Constructor Chaining",
                        "explanations": {
                            "english": "Constructor chaining in Java involves calling one constructor from another within the same class using this(), or from a subclass using super(). This technique consolidates initialization logic in a single primary constructor while providing convenience constructors with fewer parameters. The call must be the first statement in the constructor body and cannot create circular references. Chaining ensures all validation and setup code exists in one location, reducing duplication and maintenance overhead. Subclass constructors must call super() as their first statement (explicitly or implicitly) to ensure parent class initialization before child initialization. Proper chaining creates clean initialization hierarchies and prevents code duplication across overloaded constructors."
                        },
                        "code": {
                            "title": "Constructor Chaining Patterns",
                            "language": "java",
                            "content": "public class Rectangle {\n    private int width;\n    private int height;\n    private String color;\n    \n    // Primary constructor\n    public Rectangle(int width, int height, String color) {\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Dimensions must be positive\");\n        }\n        this.width = width;\n        this.height = height;\n        this.color = color;\n    }\n    \n    // Chain to primary\n    public Rectangle(int width, int height) {\n        this(width, height, \"White\");\n    }\n    \n    // Chain again\n    public Rectangle() {\n        this(10, 10);\n    }\n}\n\n// Parent-child chaining\nclass Square extends Rectangle {\n    public Square(int side) {\n        super(side, side); // Chain to parent\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Rectangle demonstrates this() chaining: the two-arg constructor delegates to the three-arg primary with default color, and the no-arg constructor delegates to two-arg with default dimensions. This keeps validation logic in one place. Square shows super() chaining, passing side twice to Rectangle's constructor to create a square."
                        },
                        "keyPoints": [
                            "Use this() to call another constructor in the same class",
                            "Use super() to call parent class constructor (must be first)",
                            "Consolidates initialization logic to avoid duplication",
                            "First statement in constructor; cannot have both this() and super()"
                        ],
                        "extras": {
                            "flowDiagram": "Rectangle() → this(10,10) → Rectangle(10,10) → this(10,10,\"White\") → Rectangle(10,10,\"White\") → Initialize\n\nSquare(side) → super(side,side) → Rectangle(width,height)",
                            "comparisonTable": "Keyword|Calls|Location|Restriction\nthis()|Another constructor same class|First statement|Cannot coexist with super()\nsuper()|Parent constructor|First statement|Implicit if omitted (no-arg)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-6-4",
                        "title": "Copy Constructor Pattern",
                        "explanations": {
                            "english": "The copy constructor pattern creates a new object as a copy of an existing object, performing deep or shallow copying of field values. While Java doesn't provide built-in copy constructors like C++, the pattern is implemented by accepting an instance of the same class as a parameter and copying its fields. This approach allows control over copying behavior—whether to copy references (shallow) or create new objects (deep)—and handles final fields that cannot be set after construction. Copy constructors are preferable to Cloneable interface as they don't require throws clauses, work with final fields, and don't require casting. They provide explicit, readable object duplication and are essential for immutable objects that need modified copies."
                        },
                        "code": {
                            "title": "Copy Constructor Implementation",
                            "language": "java",
                            "content": "public class Address {\n    private final String street;\n    private final String city;\n    private final List<String> residents;\n    \n    public Address(String street, String city, List<String> residents) {\n        this.street = street;\n        this.city = city;\n        this.residents = new ArrayList<>(residents);\n    }\n    \n    // Copy constructor (deep copy)\n    public Address(Address other) {\n        this.street = other.street;\n        this.city = other.city;\n        // Deep copy of mutable field\n        this.residents = new ArrayList<>(other.residents);\n    }\n    \n    public List<String> getResidents() {\n        return new ArrayList<>(residents); // Defensive copy\n    }\n}\n\n// Usage\nAddress original = new Address(\"123 Main\", \"NYC\", Arrays.asList(\"Alice\"));\nAddress copy = new Address(original); // Independent copy"
                        },
                        "codeExplanations": {
                            "english": "The copy constructor creates a new Address from an existing one, copying primitive values directly but creating new ArrayList for the mutable residents field (deep copy). This prevents shared mutable state between original and copy. Defensive copying in getter prevents external modification of internal list."
                        },
                        "keyPoints": [
                            "Accepts same class instance as parameter to create a copy",
                            "Allows explicit control over shallow vs deep copying",
                            "Preferred over clone() as it handles final fields and no casting",
                            "Enables creating modified copies of immutable objects"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Approach|Pros|Cons\nCopy Constructor|Explicit, handles finals, no casting|Manual implementation\nclone()|Standard interface|Shallow by default, requires Cloneable, checked exception\nSerialization|Deep copy easy|Performance, all fields must be serializable",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-7-1",
                        "title": "Packages in Java",
                        "explanations": {
                            "english": "Packages in Java are namespaces that organize related classes and interfaces into hierarchical groups, preventing naming conflicts and controlling access. Similar to folders in a file system, packages provide structure for large applications, grouping classes by functionality (e.g., java.util, java.io). The package declaration must be the first statement in a source file, determining the class's fully qualified name. Packages correspond to directory structures, with dots representing subdirectories. They enable encapsulation at a higher level than classes, as package-private (default) access allows classes within the same package to access each other's members while hiding them from external packages. Proper package organization improves code maintainability, reusability, and enables modular architecture."
                        },
                        "code": {
                            "title": "Package Organization",
                            "language": "java",
                            "content": "// File: src/com/example/banking/Account.java\npackage com.example.banking;\n\nimport com.example.common.Validator;\nimport java.math.BigDecimal;\n\npublic class Account {\n    private BigDecimal balance;\n    \n    public void deposit(BigDecimal amount) {\n        Validator.validatePositive(amount);\n        balance = balance.add(amount);\n    }\n}\n\n// File: src/com/example/banking/Transaction.java\npackage com.example.banking;\n\n// Same package, no import needed for Account\npublic class Transaction {\n    private Account fromAccount;\n    private Account toAccount;\n}"
                        },
                        "codeExplanations": {
                            "english": "Package declaration uses reverse domain notation (com.example.banking) to ensure uniqueness. Classes in the same package (Account and Transaction) can access each other's package-private members without imports. Other package classes require import statements or fully qualified names (java.math.BigDecimal)."
                        },
                        "keyPoints": [
                            "Organize classes into namespaces to prevent naming conflicts",
                            "Package declaration matches directory structure (com.example → com/example)",
                            "Classes in same package have special access privileges (package-private)",
                            "Use reverse domain naming convention for uniqueness (com.company.project)"
                        ],
                        "extras": {
                            "flowDiagram": "com\n └── example\n      ├── banking\n      │    ├── Account.java\n      │    └── Transaction.java\n      └── common\n           └── Validator.java",
                            "comparisonTable": "",
                            "examples": [
                                "java.util",
                                "java.lang",
                                "org.springframework.core"
                            ]
                        }
                    },
                    {
                        "id": "s2-7-2",
                        "title": "private",
                        "explanations": {
                            "english": "The private access modifier provides the most restrictive visibility in Java, limiting access to the declaring class only. Private members (fields, methods, constructors, nested classes) are completely hidden from other classes, including subclasses and classes in the same package. This strict encapsulation ensures that implementation details cannot be accessed or modified externally, maintaining object invariants and allowing internal changes without affecting client code. Private constructors prevent instantiation from outside, enabling singleton patterns or utility classes. While private members cannot be overridden, they can be accessed within the same top-level class, even from different instances. This modifier is fundamental to information hiding and robust encapsulation."
                        },
                        "code": {
                            "title": "Private Access Usage",
                            "language": "java",
                            "content": "public class SecureData {\n    private String secretKey;\n    private int accessCount;\n    \n    private void logAccess() {\n        accessCount++;\n    }\n    \n    public String decrypt(String data) {\n        logAccess(); // Internal use only\n        // Decryption logic\n        return \"decrypted\";\n    }\n    \n    // Private constructor pattern\n    private SecureData(String key) {\n        this.secretKey = key;\n    }\n    \n    public static SecureData create(String key) {\n        if (key == null) throw new IllegalArgumentException();\n        return new SecureData(key);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "secretKey and accessCount are completely hidden from external access. logAccess() is a private helper method for internal use only. Private constructor forces use of factory method create(), which can validate parameters before instantiation, ensuring objects are created in valid states only."
                        },
                        "keyPoints": [
                            "Access restricted strictly to the declaring class",
                            "Not visible to subclasses, package mates, or external classes",
                            "Enables complete encapsulation of implementation details",
                            "Private constructors control instantiation (singleton, factory patterns)"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Modifier|Same Class|Same Package|Subclass|Universe\nprivate|Yes|No|No|No\n(default)|Yes|Yes|No|No\nprotected|Yes|Yes|Yes|No\npublic|Yes|Yes|Yes|Yes",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-7-3",
                        "title": "default",
                        "explanations": {
                            "english": "Default access (package-private) occurs when no access modifier is specified, granting visibility to classes within the same package only. This is more restrictive than protected but less than public. Package-private access is useful for implementation classes that should not be exposed outside the package, such as helper classes or strategy implementations. It allows related classes to cooperate closely while hiding implementation from external code. This level is often used in modular design where a package exports public APIs through specific classes while keeping supporting classes package-private. Careful use of default access reduces the public API surface, minimizing maintenance burden and allowing internal refactoring without breaking changes."
                        },
                        "code": {
                            "title": "Package-Private Pattern",
                            "language": "java",
                            "content": "// In package com.example.service\npublic class UserService {\n    // Package-private helper\n    UserValidator validator = new UserValidator();\n    \n    public void createUser(String email) {\n        if (validator.isValid(email)) {\n            // Create user\n        }\n    }\n}\n\n// Package-private class (no modifier)\nclass UserValidator {\n    boolean isValid(String email) {\n        return email != null && email.contains(\"@\");\n    }\n}\n\n// Different package cannot access UserValidator:\n// import com.example.service.UserValidator; // Compile error!"
                        },
                        "codeExplanations": {
                            "english": "UserValidator has default access, so it's only visible within com.example.service package. UserService can instantiate and use it, but external packages cannot even see the class. This hides implementation details while allowing cooperation between related classes in the same package."
                        },
                        "keyPoints": [
                            "No modifier keyword; accessible only within the same package",
                            "Useful for helper classes not meant for external use",
                            "Reduces public API surface area",
                            "Allows package-internal collaboration while maintaining encapsulation"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-7-4",
                        "title": "protected",
                        "explanations": {
                            "english": "The protected access modifier provides visibility to the declaring class, same-package classes, and subclasses (even in different packages). It is designed for inheritance scenarios, allowing parent classes to expose members specifically for child class extension while hiding them from general external use. Protected members are accessible in subclasses through inheritance, but cannot be accessed via reference to parent class instances from external packages. This modifier balances encapsulation with extensibility, enabling template method patterns where subclasses override protected methods called by public parent methods. Careful use is required as protected members become part of the API contract for subclasses, requiring backward compatibility considerations."
                        },
                        "code": {
                            "title": "Protected Access Pattern",
                            "language": "java",
                            "content": "package com.example.framework;\n\npublic class Controller {\n    protected void beforeAction() {\n        // Hook for subclasses\n    }\n    \n    protected void afterAction() {\n        // Hook for subclasses\n    }\n    \n    public final void process() {\n        beforeAction();\n        doAction();\n        afterAction();\n    }\n    \n    protected abstract void doAction();\n}\n\n// Different package\npackage com.example.app;\n\npublic class UserController extends Controller {\n    @Override\n    protected void beforeAction() {\n        // Valid override\n        System.out.println(\"Preparing user action\");\n    }\n    \n    @Override\n    protected void doAction() {\n        // Implementation\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Controller defines protected hook methods (beforeAction, afterAction) that can be overridden by subclasses in different packages, but uses public final process() to enforce the algorithm structure. This template method pattern allows customization extension points while preventing modification of the overall process flow."
                        },
                        "keyPoints": [
                            "Accessible within package and to subclasses (even in other packages)",
                            "Designed for inheritance: allows parent to expose members to children only",
                            "Subclass can access protected members inherited from parent",
                            "Cannot access protected members via parent reference from external package"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-7-5",
                        "title": "public",
                        "explanations": {
                            "english": "The public access modifier provides unrestricted visibility, making members accessible from any class in any package. Classes, methods, and fields intended for use by external code must be public, forming the published API of a library or module. Public classes must be declared in files matching their names, and there can be only one public class per compilation unit. While necessary for interfaces, excessive use of public members reduces encapsulation and increases maintenance burden, as public APIs require backward compatibility. Public fields break encapsulation and should be avoided in favor of private fields with public getters/setters. The modifier is appropriate for entry points, service interfaces, and constants meant for widespread use."
                        },
                        "code": {
                            "title": "Public API Design",
                            "language": "java",
                            "content": "public class Calculator {\n    // Public constant\n    public static final double PI = 3.14159;\n    \n    // Public API method\n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    // Private implementation detail\n    private double internalPrecision = 0.0001;\n    \n    // Package-private for testing\n    void setPrecision(double p) {\n        this.internalPrecision = p;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Calculator exposes PI as a public constant and add() as public API. internalPrecision remains private, and setPrecision is package-private for test access. This demonstrates selecting minimal necessary visibility: public for API, private for internals, default for test helpers."
                        },
                        "keyPoints": [
                            "Unrestricted access from any class in any package",
                            "Forms the public API; requires backward compatibility maintenance",
                            "Public class must match filename; one per file",
                            "Avoid public fields; use private fields with accessors instead"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-7-6",
                        "title": "Package Design Best Practices",
                        "explanations": {
                            "english": "Effective package design organizes classes by functionality and layer rather than by type, following principles like high cohesion and low coupling. Packages should encapsulate related concepts and expose minimal public interfaces, hiding implementation classes as package-private. The 'separation of concerns' principle suggests organizing by feature (user management, order processing) rather than technical layers (controllers, services). Stability rules indicate that less stable packages should depend on more stable ones; stable packages contain interfaces and abstract classes. Package naming follows reverse domain notation (com.company.project.module) to ensure global uniqueness. Avoid circular dependencies between packages, as they complicate maintenance and testing. Well-designed packages enable modular deployment and clear dependency management."
                        },
                        "code": {
                            "title": "Package Structure Example",
                            "language": "java",
                            "content": "com.example.ecommerce\n    ├── customer\n    │    ├── Customer.java (public)\n    │    ├── CustomerRepository.java (public)\n    │    └── CustomerValidator.java (package-private)\n    ├── order\n    │    ├── Order.java (public)\n    │    ├── OrderService.java (public)\n    │    └── OrderCalculator.java (package-private)\n    └── common\n         ├── exception\n         └── util\n\n// customer package uses order package\nimport com.example.ecommerce.order.Order;\n\npublic class Customer {\n    // Avoid depending on internal details of other packages\n    // Use public OrderService, not package-private OrderCalculator\n}"
                        },
                        "codeExplanations": {
                            "english": "The structure organizes by domain feature (customer, order) rather than layer (dao, service). Each package exports public classes (Customer, OrderService) while hiding implementation (Validator, Calculator) as package-private. Shared utilities go in common. Customer depends only on public Order, not internal package-private classes, maintaining encapsulation boundaries."
                        },
                        "keyPoints": [
                            "Organize by feature/domain, not by technical layer",
                            "Hide implementation classes; export minimal public interfaces",
                            "Follow reverse domain naming convention",
                            "Avoid circular dependencies between packages"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Anti-Pattern|Better Approach\ncom.example.dao, com.example.service|com.example.user, com.example.product\ncom.example.controllers.UserController, ProductController|Feature packages with internal layers\nDeep nesting (a.b.c.d.e)|Flat structure (max 3-4 levels)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-8-1",
                        "title": "Static Variables & Methods",
                        "explanations": {
                            "english": "Static members in Java belong to the class itself rather than to any specific instance, shared across all objects of the class. Static variables (class variables) store data common to all instances, such as counters or configuration constants. Static methods operate on class-level data and can be invoked without creating an object using ClassName.method() syntax. They cannot access instance fields or methods directly since they exist independently of any object state. Static members are allocated in the method area (metaspace) when the class is loaded and persist for the program duration. Utility classes like Math or Collections consist entirely of static members. While convenient for shared functionality, overuse of static state can hinder testing and create hidden dependencies between classes."
                        },
                        "code": {
                            "title": "Static Members Usage",
                            "language": "java",
                            "content": "public class Counter {\n    // Static variable - shared across all instances\n    private static int totalCount = 0;\n    \n    // Instance variable - per object\n    private int instanceCount = 0;\n    \n    public void increment() {\n        instanceCount++;\n        totalCount++;\n    }\n    \n    // Static method\n    public static int getTotalCount() {\n        return totalCount;\n        // Cannot access instanceCount here\n    }\n}\n\n// Usage\nCounter c1 = new Counter();\nCounter c2 = new Counter();\nc1.increment();\nc2.increment();\nSystem.out.println(Counter.getTotalCount()); // 2"
                        },
                        "codeExplanations": {
                            "english": "totalCount is static and shared; both increments affect the same variable. instanceCount is per-object. getTotalCount() is static and called on the class, not an instance. Static methods cannot access instance variables because they operate without an instance context."
                        },
                        "keyPoints": [
                            "Belong to class, not instances; shared across all objects",
                            "Access via ClassName.member; can also access via instance (discouraged)",
                            "Static methods cannot access instance fields or methods directly",
                            "Initialized when class is loaded, not when object is created"
                        ],
                        "extras": {
                            "flowDiagram": "Class Area (Method Area):\nCounter.totalCount = 2\n\nHeap Objects:\nc1: instanceCount = 1\nc2: instanceCount = 1",
                            "comparisonTable": "Aspect|Instance|Static\nBelongs to|Object|Class\nMemory|Heap|Metaspace\nAccess|object.field|Class.field\nLifetime|Object exists|Program duration\nCan access instance?|Yes|No",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-8-2",
                        "title": "Static Blocks",
                        "explanations": {
                            "english": "Static initialization blocks in Java execute when the class is first loaded into memory, performing one-time initialization of static variables. They run before any static methods are called or instances are created, making them ideal for complex static initialization that cannot be done in single expressions. Multiple static blocks execute in the order they appear in the code. They can throw exceptions but must handle checked exceptions or declare them in the class signature. Static blocks are commonly used to load native libraries, initialize database connections, or set up complex static data structures. Since Java 8, static methods combined with private static helpers often replace static blocks for better readability and testability."
                        },
                        "code": {
                            "title": "Static Initialization",
                            "language": "java",
                            "content": "public class DatabaseConfig {\n    private static final String URL;\n    private static final int MAX_CONNECTIONS;\n    private static final Map<String, String> properties;\n    \n    static {\n        // Complex initialization\n        URL = System.getenv(\"DB_URL\");\n        MAX_CONNECTIONS = Integer.parseInt(System.getenv(\"DB_MAX_CONN\"));\n        \n        properties = new HashMap<>();\n        properties.put(\"timeout\", \"30\");\n        properties.put(\"encoding\", \"UTF-8\");\n        \n        System.out.println(\"DatabaseConfig initialized\");\n    }\n    \n    public static String getUrl() {\n        return URL;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The static block runs once when the class loads, reading environment variables and populating the map. This handles complex initialization logic that simple assignment cannot. The final variables are guaranteed initialized before use, and the block executes before any static method calls or instance creation."
                        },
                        "keyPoints": [
                            "Execute once when class is loaded, before any instances created",
                            "Used for complex static variable initialization",
                            "n",
                            "Multiple blocks execute in declaration order",
                            "Can handle exceptions but checked exceptions must be caught or declared"
                        ],
                        "extras": {
                            "flowDiagram": "Class Loading → Static Blocks Execute (in order) → Class Ready → Static Methods/Instances Available",
                            "comparisonTable": "Block Type|Execution|Use Case\nStatic|Once per class loading|Class-level setup\nInstance|Each new object|Object-level setup\nConstructor|Each new object|Parameterized initialization",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-8-3",
                        "title": "Final Variables",
                        "explanations": {
                            "english": "Final variables in Java represent constants that can be assigned only once, ensuring immutability after initialization. For primitives, final means the value cannot change; for references, the reference cannot change to point to a different object, though the object's internal state may still be mutable if it's not immutable. Final instance variables must be initialized by the time the constructor completes, either at declaration, in an instance initializer block, or in every constructor. Static final variables create compile-time or runtime constants. Blank finals (declared without initialization) allow different constructors to initialize the value differently. Final variables enable safe publication of values across threads without synchronization and help compilers optimize code."
                        },
                        "code": {
                            "title": "Final Variable Patterns",
                            "language": "java",
                            "content": "public class Configuration {\n    // Compile-time constant\n    public static final int MAX_SIZE = 100;\n    \n    // Runtime constant\n    public static final String VERSION = loadVersion();\n    \n    // Blank final - set in constructor\n    private final String instanceId;\n    \n    // Reference final - object mutable, reference fixed\n    private final List<String> tags = new ArrayList<>();\n    \n    public Configuration(String id) {\n        this.instanceId = id; // Must assign blank final\n    }\n    \n    public void addTag(String tag) {\n        tags.add(tag); // Legal - mutating object\n        // tags = new ArrayList<>(); // Illegal - cannot reassign reference\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "MAX_SIZE is a compile-time constant. VERSION is static final loaded at runtime. instanceId is a blank final assigned in the constructor, making each instance have a permanent ID. tags is a final reference—the ArrayList object can be modified (addTag works) but the reference cannot point to a different list object."
                        },
                        "keyPoints": [
                            "Can be assigned exactly once; immutable reference/value after initialization",
                            "Final reference prevents pointer change, not object mutation",
                            "Instance finals must be assigned before constructor completes",
                            "Static finals create constants; conventionally uppercase with underscores"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Type|Primitive|Object Reference\nfinal int|Value cannot change|N/A\nfinal List|N/A|Reference fixed, object mutable\nImmutable List|N/A|Reference fixed, object immutable",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-8-4",
                        "title": "Final Methods",
                        "explanations": {
                            "english": "Final methods in Java cannot be overridden by subclasses, preventing modification of critical algorithm steps or security-sensitive operations. When a method is declared final, the compiler may inline the method call for performance optimization, eliminating the overhead of virtual method lookup. Final methods are appropriate for template methods where the overall algorithm should remain fixed while allowing extension via non-final protected methods they call. They protect against accidental breaking of class contracts through overriding and prevent malicious subclassing in security-sensitive classes. However, excessive use of final methods reduces polymorphism flexibility; they should be reserved for methods whose behavior must remain consistent across all subclasses."
                        },
                        "code": {
                            "title": "Final Method Protection",
                            "language": "java",
                            "content": "public class SecureHasher {\n    // Algorithm must not be modified for security\n    public final String hash(String input) {\n        String salted = addSalt(input);\n        return computeHash(salted);\n    }\n    \n    // Protected helper can be overridden\n    protected String addSalt(String input) {\n        return \"salt_\" + input;\n    }\n    \n    private String computeHash(String data) {\n        // Hash computation\n        return Integer.toHexString(data.hashCode());\n    }\n}\n\n// Subclass\npublic class AdvancedHasher extends SecureHasher {\n    @Override\n    protected String addSalt(String input) {\n        return \"advanced_\" + super.addSalt(input);\n    }\n    \n    // Cannot override hash() - final method\n}"
                        },
                        "codeExplanations": {
                            "english": "hash() is final to prevent tampering with the security algorithm while allowing salt customization via addSalt(). Subclass can override the protected helper to customize salt generation but cannot alter the main hash method, ensuring consistent security behavior with customizable parameters."
                        },
                        "keyPoints": [
                            "Cannot be overridden by subclasses",
                            "Allows compiler optimizations like method inlining",
                            "Use for methods with critical algorithms or security requirements",
                            "Protected helper methods can be overridden while final method structure remains fixed"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "java.lang.Math methods",
                                "Security class verification methods"
                            ]
                        }
                    },
                    {
                        "id": "s2-8-5",
                        "title": "Final Classes",
                        "explanations": {
                            "english": "Final classes in Java cannot be extended or inherited, preventing subclassing entirely. This is appropriate for utility classes (like java.lang.Math or java.lang.System), immutable classes (like java.lang.String, java.time.LocalDate), and security-sensitive classes where subclassing could compromise behavior. Final classes implicitly have all methods as final (since they cannot be overridden), though methods are not explicitly marked final (redundant). Making a class final is the strongest form of restriction, eliminating the possibility of polymorphic extension. Design considerations should evaluate whether composition could serve the purpose instead of inheritance. Final classes can still implement interfaces and extend other non-final classes (unless already extending a final class)."
                        },
                        "code": {
                            "title": "Final Class Examples",
                            "language": "java",
                            "content": "// Utility class - should not be instantiated or extended\npublic final class StringUtils {\n    private StringUtils() {} // Private constructor\n    \n    public static boolean isEmpty(String s) {\n        return s == null || s.isEmpty();\n    }\n}\n\n// Immutable class - final fields and final class\npublic final class Point {\n    private final int x;\n    private final int y;\n    \n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    public int getX() { return x; }\n    public int getY() { return y; }\n}\n\n// Cannot do: public class MutablePoint extends Point {} // Compile error"
                        },
                        "codeExplanations": {
                            "english": "StringUtils is final with private constructor, preventing both extension and instantiation—pure utility class. Point is final immutable class with final fields, ensuring state cannot change after creation or through malicious subclassing. Both demonstrate patterns where immutability or utility semantics must be preserved."
                        },
                        "keyPoints": [
                            "Cannot be extended; prevents all inheritance",
                            "Implicitly makes all methods final (cannot be overridden)",
                            "Use for immutable data classes and utility classes",
                            "Complete restriction allowing maximum control over class behavior"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Restriction|Effect\nfinal class|No extension allowed\nfinal method|No overriding allowed\nfinal variable|No reassignment allowed\nprivate constructor|No instantiation (for utilities)",
                            "examples": [
                                "java.lang.String",
                                "java.time.LocalDateTime",
                                "java.lang.Math"
                            ]
                        }
                    },
                    {
                        "id": "s2-9-1",
                        "title": "Static Nested Classes",
                        "explanations": {
                            "english": "Static nested classes in Java are declared within another class with the static modifier, behaving like top-level classes logically grouped with their outer class. They do not maintain an implicit reference to an instance of the enclosing class, allowing them to be instantiated independently: OuterClass.NestedClass obj = new OuterClass.NestedClass(). This independence makes them memory-efficient when the nested class doesn't need access to outer class instance fields. They can access static members of the outer class but cannot access instance fields or methods directly. Static nested classes are appropriate for helper classes, builders, or components tightly coupled with the outer class but not requiring instance context, such as Entry in Map interfaces."
                        },
                        "code": {
                            "title": "Static Nested Class Pattern",
                            "language": "java",
                            "content": "public class Department {\n    private static String companyName = \"TechCorp\";\n    private String departmentName;\n    \n    // Static nested class\n    public static class Employee {\n        private String name;\n        private int id;\n        \n        public void work() {\n            // Can access static members of outer class\n            System.out.println(\"Working at \" + companyName);\n            // Cannot access departmentName directly (non-static)\n        }\n    }\n}\n\n// Usage\nDepartment.Employee emp = new Department.Employee();\n// No Department instance required"
                        },
                        "codeExplanations": {
                            "english": "Employee is static and does not require a Department instance to exist. It can access static field companyName but not instance field departmentName. Instantiation uses the Outer.Inner syntax without needing an outer object, making it behave like a regular class with namespace organization."
                        },
                        "keyPoints": [
                            "Declared static; no implicit reference to outer class instance",
                            "Can be instantiated without outer class instance",
                            "Can access only static members of outer class",
                            "Used for grouping related classes (e.g., Builder pattern)"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Type|Instance Reference|Access to Outer|Instantiation\nStatic Nested|No|Static only|new Outer.Inner()\nInner|Yes|All members|outer.new Inner()\nLocal|Yes|All members|Within method only\nAnonymous|Yes|All members|At creation point only",
                            "examples": [
                                "Map.Entry",
                                "Builder patterns"
                            ]
                        }
                    },
                    {
                        "id": "s2-9-2",
                        "title": "Non-static Inner Classes",
                        "explanations": {
                            "english": "Non-static inner classes (member inner classes) are defined within another class without the static modifier, maintaining an implicit reference to an instance of the enclosing class. This link allows them to access all members of the outer class, including private fields and methods. They are instantiated through an instance of the outer class: OuterClass.InnerClass inner = outer.new InnerClass(). Each inner class instance is tied to a specific outer instance and cannot exist independently. Inner classes are used when a class logically belongs to another and needs direct access to its implementation details, such as iterators in collections or UI event handlers. They can lead to memory leaks if the inner class outlives the outer instance, as it retains the reference."
                        },
                        "code": {
                            "title": "Inner Class Usage",
                            "language": "java",
                            "content": "public class Car {\n    private String model;\n    private boolean engineRunning;\n    \n    // Non-static inner class\n    public class Engine {\n        private int horsepower;\n        \n        public void start() {\n            // Access outer class private members directly\n            engineRunning = true;\n            System.out.println(model + \" engine started\");\n        }\n        \n        public Car getCar() {\n            return Car.this; // Explicit outer reference\n        }\n    }\n}\n\n// Usage\nCar myCar = new Car();\nCar.Engine engine = myCar.new Engine(); // Bound to myCar instance\nengine.start();"
                        },
                        "codeExplanations": {
                            "english": "Engine is a member inner class with implicit access to Car's private fields model and engineRunning. Instantiation requires an existing Car object (myCar.new Engine()). Car.this provides explicit reference to the outer instance if needed. This tight coupling represents the engine being part of a specific car."
                        },
                        "keyPoints": [
                            "Maintain implicit reference to outer class instance",
                            "Can access all outer class members including private",
                            "Must be instantiated via outer instance: outer.new Inner()",
                            "Each inner instance bound to specific outer instance"
                        ],
                        "extras": {
                            "flowDiagram": "Car object (outer)\n    ↓ reference\nEngine object (inner)\n    ↓ implicit access\nCar fields/methods",
                            "comparisonTable": "",
                            "examples": [
                                "Iterator implementations",
                                "UI event listeners"
                            ]
                        }
                    },
                    {
                        "id": "s2-9-3",
                        "title": "Local Inner Classes",
                        "explanations": {
                            "english": "Local inner classes are defined within a method or block scope, existing only within that block's execution context. They have access to all members of the enclosing class and final or effectively final local variables of the containing method (due to closure requirements). Local classes are not members of the outer class and cannot have access modifiers (public, private) or static modifiers. They are useful when a class is needed only within a specific method for temporary functionality, such as custom data structures or action handlers. Being confined to a method reduces class namespace pollution and encapsulates implementation details that shouldn't be visible at the class level."
                        },
                        "code": {
                            "title": "Local Class Implementation",
                            "language": "java",
                            "content": "public class ProcessManager {\n    private int processId = 100;\n    \n    public void startProcess(final String processName) {\n        int timeout = 30; // Effectively final\n        \n        // Local class defined inside method\n        class ProcessRunner {\n            public void run() {\n                System.out.println(\"Starting \" + processName + \n                                 \" with ID \" + processId);\n                System.out.println(\"Timeout: \" + timeout);\n            }\n        }\n        \n        ProcessRunner runner = new ProcessRunner();\n        runner.run();\n        \n        // Class not accessible outside this method\n    }\n    \n    public void stopProcess() {\n        // ProcessRunner not visible here\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "ProcessRunner is local to startProcess method, accessing outer class field processId and the final parameter processName plus the effectively final local variable timeout. The class cannot be accessed outside the method, providing complete encapsulation of the helper class within the method scope where it's needed."
                        },
                        "keyPoints": [
                            "Defined within a method or block, not as class members",
                            "No access modifiers allowed; scope limited to enclosing block",
                            "n",
                            "Can access final/effectively final local variables and all outer class members",
                            "Useful for temporary helper classes needed only within a method"
                        ],
                        "extras": {
                            "flowDiagram": "Method Execution:\nstartProcess()\n    ↓\n    Define Local Class ProcessRunner\n    ↓\n    Instantiate and use\n    ↓\nMethod Ends → Class scope ends → Not accessible elsewhere",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s2-9-4",
                        "title": "Anonymous Inner Classes",
                        "explanations": {
                            "english": "Anonymous inner classes are unnamed local classes declared and instantiated in a single expression, typically used for implementing interfaces or extending classes exactly where needed. The syntax combines class definition with instantiation: new Interface() { implementation }. They have the same access rules as local classes (access to final variables and outer members) but exist only at the point of creation. Commonly used for event listeners, Runnable implementations, or Comparator definitions. While concise, they can reduce readability if complex; lambdas (Java 8+) often replace anonymous classes for functional interfaces. Anonymous classes cannot have constructors (except instance initializers) and compile to separate class files named OuterClass$1.class."
                        },
                        "code": {
                            "title": "Anonymous Class Patterns",
                            "language": "java",
                            "content": "// Implementing interface anonymously\nRunnable task = new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Running in thread\");\n    }\n};\n\n// Extending class anonymously\nList<String> list = new ArrayList<String>() {\n    @Override\n    public boolean add(String s) {\n        System.out.println(\"Adding: \" + s);\n        return super.add(s);\n    }\n};\n\n// As argument (common for listeners)\nbutton.addActionListener(new ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        System.out.println(\"Clicked\");\n    }\n});"
                        },
                        "codeExplanations": {
                            "english": "The first example creates an anonymous Runnable implementation. The second creates an anonymous subclass of ArrayList that overrides add(). The third shows the common pattern passing an anonymous listener implementation directly to a method. Each creates a one-time use class without a named declaration."
                        },
                        "keyPoints": [
                            "Unnamed class declared and instantiated in one expression",
                            "Must extend a class or implement an interface",
                            "Cannot have explicit constructors; use instance initializers",
                            "Replaced by lambdas for functional interfaces (Java 8+)"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Feature|Anonymous|Lambda (Java 8+)\nSyntax|new Type() { }|(params) -> expression\nType|Class or interface|Functional interface only\nthis reference|Anonymous class instance|Enclosing class instance\nCapturing|Same as local class|Same (effectively final)\nReadability|Verbose for simple cases|Concise for simple cases",
                            "examples": [
                                "Thread creation",
                                "Event handlers",
                                "Comparator implementations"
                            ]
                        }
                    }
                ]
            },
            {
                "id": "section-3",
                "title": "Memory Management",
                "topics": [
                    {
                        "id": "s3-1-1",
                        "title": "Stack Memory Usage",
                        "explanations": {
                            "english": "Stack memory is used for static memory allocation and thread execution in the JVM. Each thread has its own private stack created when the thread starts, storing local primitive variables, method parameters, return addresses, and intermediate calculation results. Stack memory follows Last-In-First-Out (LIFO) ordering, where a new stack frame is pushed onto the top when a method is invoked and popped off when the method completes. This automatic cleanup makes stack memory management very efficient, as variables are automatically destroyed when they go out of scope. However, stack size is limited, and deep recursion or excessive method nesting can cause StackOverflowError."
                        },
                        "code": {
                            "title": "Stack Frame Example",
                            "language": "java",
                            "content": "public class StackDemo {\n    public static void main(String[] args) {\n        int x = 10;              // Stored in main's stack frame\n        int result = calculate(x); // New frame pushed for calculate\n        System.out.println(result);\n    }\n    \n    static int calculate(int value) { // Parameter in calculate's frame\n        int temp = value * 2;    // Local variable in calculate's frame\n        return add(temp);        // New frame pushed for add\n    }\n    \n    static int add(int n) {      // New frame\n        int sum = n + 5;         // Local variable\n        return sum;              // Frame popped, value returned\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The code demonstrates how stack frames are created and destroyed. When main calls calculate, a new frame with parameter value and local variable temp is pushed. When calculate calls add, another frame is pushed on top. As each method returns, its frame is popped, automatically cleaning up local variables."
                        },
                        "keyPoints": [
                            "Each thread has its own private stack memory created at thread startup",
                            "Stores local variables, method parameters, and return addresses in stack frames",
                            "LIFO structure: frames pushed on method call, popped on return",
                            "Limited size; deep recursion causes StackOverflowError"
                        ],
                        "extras": {
                            "flowDiagram": "Thread Stack:\n[add(): n, sum] ← Top (current)\n[calculate(): value, temp]\n[main(): x, result, args] ← Bottom",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-1-2",
                        "title": "Heap Memory Usage",
                        "explanations": {
                            "english": "Heap memory is the runtime data area shared among all threads where all Java objects and arrays are allocated. Unlike the stack, objects in the heap persist beyond the scope of the method that created them, remaining alive as long as they are referenced. Memory is allocated dynamically using the 'new' keyword and deallocated automatically by the garbage collector when objects become unreachable. The heap is typically much larger than the stack but has slower access due to synchronization and garbage collection overhead. It is divided into generations (Young and Old) to optimize garbage collection performance based on object lifetime."
                        },
                        "code": {
                            "title": "Heap Allocation Example",
                            "language": "java",
                            "content": "public class HeapDemo {\n    public static void main(String[] args) {\n        // Object created in heap, reference stored in stack\n        Person person = new Person(\"Alice\", 30);\n        \n        // Method returns object allocated in heap\n        Person newPerson = modifyPerson(person);\n        \n        // Both references exist after method returns\n        System.out.println(person.getName());      // Alice\n        System.out.println(newPerson.getName());   // Bob\n    }\n    \n    static Person modifyPerson(Person p) {\n        // New object in heap, survives method return\n        return new Person(\"Bob\", 25);\n    }\n}\n\nclass Person {\n    private String name; // reference in heap (object in heap)\n    private int age;     // primitive in heap\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() { return name; }\n}"
                        },
                        "codeExplanations": {
                            "english": "Person objects are allocated in heap memory. The person reference variable is stored in main's stack frame but points to heap memory. When modifyPerson returns a new Person, that object remains in heap even after the method frame is popped, accessible via the newPerson reference in main."
                        },
                        "keyPoints": [
                            "Shared among all threads; stores all objects and arrays created with 'new'",
                            "Managed by garbage collector; objects persist while referenced",
                            "Larger than stack but slower access due to GC and synchronization",
                            "Divided into generations (Young/Old) to optimize collection efficiency"
                        ],
                        "extras": {
                            "flowDiagram": "Heap Memory:\n[Person object: name→\"Alice\", age=30]\n[Person object: name→\"Bob\", age=25]\n[String object: \"Alice\"]\n[String object: \"Bob\"]\n\nStack (main):\nperson → ref to Alice\nnewPerson → ref to Bob",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-1-3",
                        "title": "Object References vs Actual Objects",
                        "explanations": {
                            "english": "It is essential to distinguish between object references and the actual objects they refer to in Java memory management. A reference variable is stored on the stack (or in registers) and contains the memory address pointing to an object in the heap, while the object itself holds the actual data and state. When you assign one reference variable to another, you copy the memory address, creating an alias that points to the same object, not a copy of the object. Multiple references can point to a single heap object, meaning changes made through one reference are visible through all others. Understanding this distinction prevents confusion about pass-by-value semantics and object mutation."
                        },
                        "code": {
                            "title": "Reference vs Object Demonstration",
                            "language": "java",
                            "content": "public class ReferenceDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder(\"Hello\");\n        StringBuilder sb2 = sb1; // Copy reference, not object\n        \n        // Both references point to same object in heap\n        sb2.append(\" World\");\n        System.out.println(sb1); // Hello World\n        System.out.println(sb1 == sb2); // true (same reference)\n        \n        // Reassigning reference doesn't affect object\n        sb2 = new StringBuilder(\"New\");\n        System.out.println(sb1); // Still Hello World\n        System.out.println(sb2); // New\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "sb1 contains a reference to the StringBuilder object in heap. Assigning sb1 to sb2 copies the reference address, so both point to the same object. Appending via sb2 modifies the shared object, visible through sb1. Reassigning sb2 to a new object only changes sb2's reference, not sb1's reference or the original object."
                        },
                        "keyPoints": [
                            "Reference variables store memory addresses; objects store actual data in heap",
                            "Assignment copies the reference value, creating aliases to the same object",
                            "Multiple references can point to one object; changes affect all references",
                            "Reassigning a reference variable changes what object it points to, not the object itself"
                        ],
                        "extras": {
                            "flowDiagram": "Before sb2 = new StringBuilder:\nsb1 ───→ [StringBuilder: \"Hello World\"]\nsb2 ───→ (same object)\n\nAfter reassignment:\nsb1 ───→ [StringBuilder: \"Hello World\"]\nsb2 ───→ [StringBuilder: \"New\"]",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-1-4",
                        "title": "Common Memory Issues",
                        "explanations": {
                            "english": "Common memory issues in Java include StackOverflowError, OutOfMemoryError, and memory leaks. StackOverflowError occurs when the stack exceeds its limit due to infinite recursion or excessively deep method call chains. OutOfMemoryError in the heap happens when objects cannot be allocated due to insufficient space, often caused by memory leaks or inadequate heap size settings. Memory leaks occur when objects are no longer needed but remain referenced by accidental pointers (like static collections growing unbounded), preventing garbage collection. NullPointerExceptions arise when attempting to use null references. Understanding these issues requires monitoring heap dumps, stack traces, and using profiling tools."
                        },
                        "code": {
                            "title": "Memory Problem Examples",
                            "language": "java",
                            "content": "// StackOverflowError - infinite recursion\npublic void infiniteRecursion() {\n    infiniteRecursion(); // Stack frames grow until overflow\n}\n\n// Memory Leak - growing static collection\npublic class Cache {\n    private static List<Object> leak = new ArrayList<>();\n    \n    public void add(Object obj) {\n        leak.add(obj); // Never removed, grows forever\n    }\n}\n\n// OutOfMemoryError - heap exhaustion\npublic void heapExhaustion() {\n    List<byte[]> list = new ArrayList<>();\n    while (true) {\n        list.add(new byte[1024 * 1024]); // 1MB chunks\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The infinite recursion creates stack frames until StackOverflowError. The static Cache list prevents garbage collection of added objects, causing a memory leak as it grows. The heap exhaustion loop allocates large byte arrays continuously until the heap is full, throwing OutOfMemoryError."
                        },
                        "keyPoints": [
                            "StackOverflowError: Stack exceeds maximum depth (infinite recursion)",
                            "OutOfMemoryError: Heap cannot allocate new objects",
                            "Memory leaks: Unnecessary references prevent GC (static collections, listeners)",
                            "Use profilers and heap dumps (-XX:+HeapDumpOnOutOfMemoryError) to diagnose"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Error|Cause|Solution\nStackOverflowError|Deep recursion, cyclic calls|Increase stack (-Xss) or fix logic\nOutOfMemoryError|Heap full, memory leaks|Increase heap (-Xmx) or fix leaks\nMemory Leak|Accidental references|Remove references, use weak references",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-2-1",
                        "title": "What is Garbage Collection",
                        "explanations": {
                            "english": "Garbage Collection (GC) is the automatic memory management process in Java that identifies and removes objects no longer reachable by the program. The JVM tracks object references starting from GC roots (local variables, static fields, active threads), marking reachable objects as alive. Unmarked objects are considered garbage and have their memory reclaimed. This automation eliminates manual memory management errors like forgetting to free memory, double-freeing, or dangling pointers. GC runs in the background as daemon threads, triggered when heap space runs low or explicitly requested via System.gc(). Different collectors use various algorithms (mark-sweep, copying, mark-compact) optimized for different application needs."
                        },
                        "code": {
                            "title": "Garbage Collection Trigger",
                            "language": "java",
                            "content": "public class GCDemo {\n    public static void main(String[] args) {\n        for (int i = 0; i < 100000; i++) {\n            // Temporary objects become eligible for GC\n            String temp = new String(\"Object \" + i);\n            // temp goes out of scope, becomes unreachable\n        }\n        \n        // Suggest GC (not guaranteed to run immediately)\n        System.gc();\n        \n        // Force finalization (deprecated in modern Java)\n        Runtime.getRuntime().runFinalization();\n    }\n    \n    @Override\n    protected void finalize() throws Throwable {\n        // Called before object destruction (deprecated since Java 9)\n        System.out.println(\"Object being garbage collected\");\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The loop creates many temporary String objects that become eligible for garbage collection after each iteration when the reference is overwritten or goes out of scope. System.gc() is merely a suggestion to the JVM to run GC, not a command. The finalize() method (now deprecated) would be called before destruction if overridden."
                        },
                        "keyPoints": [
                            "Automatic process that reclaims memory from unreachable objects",
                            "Identifies garbage by tracing from GC roots (stack, statics, registers)",
                            "Runs in background threads; System.gc() is only a hint",
                            "Prevents memory leaks and eliminates manual deallocation errors"
                        ],
                        "extras": {
                            "flowDiagram": "GC Roots → Reachable Objects (Marked Alive)\n      ↓\nUnreachable Objects → Marked for Collection → Memory Freed",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-2-2",
                        "title": "Generational Garbage Collection",
                        "explanations": {
                            "english": "Generational garbage collection is based on the weak generational hypothesis: most objects die young while few survive long-term. The heap is divided into Young Generation (for new objects) and Old Generation (Tenured) for long-lived objects. The Young Generation consists of Eden space and two Survivor spaces (S0, S1). New objects are allocated in Eden; when it fills, Minor GC moves surviving objects to Survivor spaces. Objects surviving multiple Minor GC cycles are promoted to the Old Generation. Major GC (Full GC) occurs less frequently in the Old space. This separation allows efficient collection of short-lived objects using fast copying algorithms without scanning long-lived objects repeatedly."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "Heap divided into Young (new objects) and Old (long-lived objects) generations",
                            "Young Generation contains Eden and two Survivor spaces (S0, S1)",
                            "Minor GC cleans Young space frequently; Major GC cleans Old space occasionally",
                            "Objects promoted to Old space after surviving threshold (default 15) Minor GCs"
                        ],
                        "extras": {
                            "flowDiagram": "New Object → Eden Space\n                ↓ Full\n         Minor GC\n                ↓\n    [Dead]    [Alive]\n      ↓         ↓\n   Freed    Survivor S0\n                ↓\n           Minor GC × 15\n                ↓\n         Old Generation (Tenured)\n                ↓\n          Major GC/Full GC",
                            "comparisonTable": "Generation|Contents|Collection Frequency|Algorithm\nYoung|New objects|Very frequent|Copying (fast)\nOld|Long-lived objects|Rare|Mark-sweep-compact (slower)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-2-3",
                        "title": "G1 Garbage Collector",
                        "explanations": {
                            "english": "The Garbage-First (G1) collector is a server-style, regionalized collector designed for large memory heaps (multiple gigabytes). It divides the heap into multiple equal-sized regions (typically 1MB to 32MB) that can be Eden, Survivor, or Old generation regions dynamically. G1 performs concurrent global marking to track live data, then prioritizes collecting regions with the most garbage first (hence 'Garbage-First'), maximizing reclamation efficiency. It targets user-defined pause times (default 200ms) by selecting regions to collect incrementally. G1 compacts the heap during evacuation to prevent fragmentation, replacing the Concurrent Mark Sweep (CMS) collector as the default in Java 9+."
                        },
                        "code": {
                            "title": "G1 Configuration",
                            "language": "java",
                            "content": "// JVM Arguments for G1\n// -XX:+UseG1GC\n// -XX:MaxGCPauseMillis=200\n// -XX:InitiatingHeapOccupancyPercent=35\n// -XX:G1HeapRegionSize=16m\n\n// Enable GC logging (Java 9+)\n// -Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=100m"
                        },
                        "codeExplanations": {
                            "english": "G1 is enabled with -XX:+UseG1GC. MaxGCPauseMillis sets the target pause time (default 200ms) that G1 attempts to meet by selecting an appropriate number of regions to collect. InitiatingHeapOccupancyPercent triggers marking when heap reaches 35% occupancy. Region size can be set manually or auto-tuned based on heap size."
                        },
                        "keyPoints": [
                            "Regionalized collector dividing heap into equal-sized regions (1-32MB)",
                            "Prioritizes regions with most garbage for collection efficiency",
                            "Targets pause time goals through incremental collection",
                            "Replaces CMS; default collector from Java 9"
                        ],
                        "extras": {
                            "flowDiagram": "Heap divided into regions:\n[E][E][S][O][O][E][E][O][S][E]\n    \nConcurrent Marking → Identify mostly garbage regions\n    ↓\nEvacuate (copy live objects) → Compact selected regions\n    ↓\nFree space reclaimed",
                            "comparisonTable": "Feature|CMS|G1\nHeap Structure|Contiguous|Regionalized\nCompaction|No (fragmentation)|Yes\nPause Time Target|No|Yes (configurable)\nDefault (Java 9+)|No|Yes",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-2-4",
                        "title": "ZGC Overview",
                        "explanations": {
                            "english": "Z Garbage Collector (ZGC) is a scalable, low-latency collector designed for heaps ranging from small to terabytes of memory. Introduced in Java 11 as experimental and production-ready in Java 15, it performs all heavy work concurrently with application threads, maintaining pause times below 10 milliseconds regardless of heap size. ZGC uses colored pointers (metadata in 64-bit pointers) and load barriers to enable concurrent relocation of objects without stopping threads. It is non-generational (single generation) and uses reference processing during relocation. ZGC is ideal for latency-sensitive applications like financial trading, gaming servers, and large-scale web applications where consistent response times are critical."
                        },
                        "code": {
                            "title": "ZGC Configuration",
                            "language": "java",
                            "content": "// Enable ZGC (Java 15+)\n// -XX:+UseZGC\n\n// Optional: Set max heap size\n// -Xmx16G\n\n// ZGC specific options\n// -XX:ZCollectionInterval=5 (seconds)\n// -XX:ZAllocationSpikeTolerance=2"
                        },
                        "codeExplanations": {
                            "english": "ZGC is enabled with -XX:+UseZGC flag. It works best with large heaps and requires 64-bit JVM. Unlike G1, ZGC does not require setting pause time goals as it consistently achieves sub-10ms pauses. The collection interval and allocation spike tolerance can be tuned for specific allocation patterns."
                        },
                        "keyPoints": [
                            "Ultra-low latency: sub-10ms pause times regardless of heap size",
                            "Handles heaps from small to terabytes effectively",
                            "Uses colored pointers and load barriers for concurrent operations",
                            "Non-generational; single generation heap layout"
                        ],
                        "extras": {
                            "flowDiagram": "Application Threads Running\n      ↓\nConcurrent Mark (remap pointers)\n      ↓\nConcurrent Relocate (move objects)\n      ↓\nLoad Barriers fix references on access\n      ↓\nApplication Threads Running (minimal pause)",
                            "comparisonTable": "Feature|G1|ZGC\nPause Time|~200ms target|<10ms guaranteed\nHeap Size|Large|Massive (TB)\nGenerations|Yes|No\nJava Version|9+|15+ (production)\nBest For|Balanced|Ultra-low latency",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-2-5",
                        "title": "GC Tuning Basics",
                        "explanations": {
                            "english": "GC tuning involves selecting appropriate collectors and configuring heap parameters to balance throughput, latency, and memory footprint for your application. Key JVM flags include -Xms (initial heap size), -Xmx (maximum heap size), and -XX:+UseG1GC or -XX:+UseZGC to select collectors. For throughput-intensive batch jobs, Parallel GC may suffice; for responsive web services, G1 or ZGC is preferrable. Monitoring tools like VisualVM, JConsole, or GC logs (-Xlog:gc) help analyze collection frequency and pause times. The optimal configuration depends on application behavior: allocation rate, object lifetime distribution, and acceptable pause times. Profiling helps identify memory leaks and excessive GC overhead indicating undersized heaps or code issues."
                        },
                        "code": {
                            "title": "Common GC Flags",
                            "language": "java",
                            "content": "// Heap sizing\n// -Xms2G -Xmx2G (fixed 2GB heap prevents resizing pauses)\n\n// GC selection\n// -XX:+UseG1GC (Java 8+)\n// -XX:+UseZGC (Java 15+)\n// -XX:+UseParallelGC (throughput)\n\n// Logging (Java 9+)\n// -Xlog:gc*:file=gc.log:time,uptime,level,tags\n\n// G1 specific\n// -XX:MaxGCPauseMillis=100\n// -XX:G1HeapRegionSize=4m\n\n// OOM handling\n// -XX:+HeapDumpOnOutOfMemoryError\n// -XX:HeapDumpPath=/path/to/dumps"
                        },
                        "codeExplanations": {
                            "english": "Setting Xms equal to Xmx prevents heap resizing pauses. G1 is selected for balanced workloads, ZGC for latency-sensitive, Parallel for throughput. GC logging helps analyze behavior in production. Heap dumps on OOM enable post-mortem analysis of memory issues using tools like Eclipse MAT."
                        },
                        "keyPoints": [
                            "Balance three metrics: throughput, latency, memory footprint",
                            "Size heap appropriately: Xmx should be less than physical RAM to avoid swapping",
                            "Use GC logs and monitoring to measure pause times and frequency",
                            "Choose collector based on application requirements and Java version"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Collector|Best For|Pause Time|Throughput\nSerial|Single thread|High|Low\nParallel|Batch processing|Medium|High\nG1|General server|Low (configurable)|Medium\nZGC|Low latency apps|Very low (<10ms)|Medium",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-3-1",
                        "title": "Class Loader Types",
                        "explanations": {
                            "english": "The Java Virtual Machine uses a hierarchical delegation system with three built-in class loaders. The Bootstrap Class Loader (primordial) is written in native code and loads core Java classes (java.lang, java.util) from the bootstrap classpath (rt.jar/modules). The Platform/Extension Class Loader (changed from Extension in Java 9) loads classes from extension directories or platform modules. The Application/System Class Loader loads application classes from the classpath specified by -cp or CLASSPATH environment variable. These loaders form a parent-child hierarchy where requests delegate upward. Developers can create custom class loaders by extending java.lang.ClassLoader to implement hot-swapping, modular isolation, or loading classes from non-standard sources like networks or databases."
                        },
                        "code": {
                            "title": "Class Loader Hierarchy",
                            "language": "java",
                            "content": "public class ClassLoaderDemo {\n    public static void main(String[] args) {\n        // Show class loader hierarchy\n        ClassLoader appLoader = ClassLoaderDemo.class.getClassLoader();\n        System.out.println(\"Application: \" + appLoader);\n        \n        ClassLoader platformLoader = appLoader.getParent();\n        System.out.println(\"Platform: \" + platformLoader);\n        \n        ClassLoader bootstrapLoader = platformLoader.getParent();\n        System.out.println(\"Bootstrap: \" + bootstrapLoader); // null (native)\n        \n        // String class loaded by bootstrap\n        System.out.println(\"String loader: \" + String.class.getClassLoader()); // null\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The code displays the three-level hierarchy: Application loader (sun.misc.Launcher$AppClassLoader), Platform loader (sun.misc.Launcher$ExtClassLoader/PlatformClassLoader), and Bootstrap loader (represented as null because it's native code). Core classes like String return null for getClassLoader() indicating bootstrap origin."
                        },
                        "keyPoints": [
                            "Bootstrap: Loads core JDK classes from rt.jar/modules, native code",
                            "Platform/Extension: Loads extension classes from lib/ext",
                            "Application/System: Loads application classpath classes",
                            "Custom: User-defined loaders for special loading requirements (OSGi, Tomcat)"
                        ],
                        "extras": {
                            "flowDiagram": "Custom Loader\n      ↓ delegates\nApplication Loader\n      ↓ delegates\nPlatform Loader\n      ↓ delegates\nBootstrap Loader (native)",
                            "comparisonTable": "Loader|Loads From|Language\nBootstrap|rt.jar, core modules|Native (C++)\nPlatform|lib/ext, platform modules|Java\nApplication|CLASSPATH, -cp|Java\nCustom|Network, DB, encrypted|Java (extends ClassLoader)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-3-2",
                        "title": "Loading Phase",
                        "explanations": {
                            "english": "The Loading phase is the first step of class loading where the ClassLoader locates and reads the binary bytecode from the filesystem, network, or other sources. The JVM creates a java.lang.Class object representing the loaded type and stores the class metadata (method bytecode, field data, constant pool) in the Metaspace (or PermGen in Java 7 and earlier). This phase performs basic format verification—checking magic numbers, version compatibility, and structural integrity—but does not perform full bytecode verification. The loaded class is not yet ready for use; it enters the linking phase next. Loading can be triggered explicitly via Class.forName() or implicitly when encountering class references during execution."
                        },
                        "code": {
                            "title": "Loading Trigger Examples",
                            "language": "java",
                            "content": "// Explicit loading\nClass<?> clazz = Class.forName(\"java.util.ArrayList\");\n\n// Loading with specific loader\nClassLoader cl = Thread.currentThread().getContextClassLoader();\nClass<?> loaded = cl.loadClass(\"com.example.MyClass\");\n\n// Implicit loading occurs when:\n// - Creating new instances (new MyClass())\n// - Accessing static members (MyClass.staticMethod())\n// - Using class literals (MyClass.class)"
                        },
                        "codeExplanations": {
                            "english": "Class.forName() explicitly triggers the loading phase. The thread context class loader can be used for loading in web application contexts. Implicit loading happens automatically when the JVM encounters references to classes that haven't been loaded yet, ensuring classes are available when needed."
                        },
                        "keyPoints": [
                            "Reads .class file bytes and creates Class object in Metaspace",
                            "Performs basic format verification (magic number 0xCAFEBABE, version)",
                            "Does not perform full bytecode verification (happens in Linking)",
                            "Triggered explicitly by Class.forName() or implicitly by first usage"
                        ],
                        "extras": {
                            "flowDiagram": "findClass() → Locate .class file → Read bytes → Define Class Object → Store in Metaspace",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-3-3",
                        "title": "Linking Phase",
                        "explanations": {
                            "english": "Linking prepares the loaded class for execution by combining it with the runtime state. It consists of three sequential steps: Verification checks bytecode for type safety, operand stack consistency, and valid control flow using the Bytecode Verifier; Preparation allocates memory for static fields and initializes them to default values (0, false, null); Resolution transforms symbolic references in the constant pool (class names, field/method references) into direct memory addresses pointing to actual classes/methods. Resolution can be eager (immediate) or lazy (when first used). Linking ensures the class is safe and correctly connected to dependent classes before initialization."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "Verification: Bytecode checking for safety and structural correctness",
                            "Preparation: Allocate static field memory, set default values",
                            "Resolution: Convert symbolic references to direct memory pointers",
                            "Can occur lazily (on first use) or eagerly (during loading)"
                        ],
                        "extras": {
                            "flowDiagram": "Loaded Class → Verification (safe?) → Preparation (alloc statics) → Resolution (fix pointers) → Ready for Init",
                            "comparisonTable": "Step|Action|Checks\nVerification|Bytecode analysis|Type safety, stack consistency\nPreparation|Memory allocation|None (just zero memory)\nResolution|Reference binding|Class existence, access rights",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-3-4",
                        "title": "Initialization Phase",
                        "explanations": {
                            "english": "Initialization is the final phase where the JVM executes static initializers and static field assignments in the order they appear in source code. This occurs when the class is first actively used: instantiating with new, accessing a static member (except constants), calling static methods, or using reflection. The JVM ensures parent classes are fully initialized before subclasses. Static blocks and field initializers run in textual order within the class. Initialization is thread-safe; the JVM locks the Class object during initialization to prevent concurrent initialization issues. If initialization fails with an exception, the class is marked erroneous and future attempts throw NoClassDefFoundError with the original exception suppressed."
                        },
                        "code": {
                            "title": "Initialization Order",
                            "language": "java",
                            "content": "public class InitDemo {\n    static {\n        System.out.println(\"Static block 1\");\n    }\n    \n    static int value = initialize();\n    \n    static {\n        System.out.println(\"Static block 2\");\n    }\n    \n    static int initialize() {\n        System.out.println(\"Initializing value\");\n        return 42;\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Main started\");\n        System.out.println(InitDemo.value);\n    }\n}\n// Output order:\n// Static block 1\n// Initializing value\n// Static block 2\n// Main started\n// 42"
                        },
                        "codeExplanations": {
                            "english": "The example demonstrates that static initialization occurs in textual order when the class is first accessed (in main). Static block 1 runs first, then the field initializer (which calls initialize()), then static block 2. Only after initialization completes does the main method continue execution."
                        },
                        "keyPoints": [
                            "Executes static blocks and static field initializers in source order",
                            "Triggered by first active use (new, static access, reflection)",
                            "Parent classes initialized before child classes",
                            "Thread-safe: JVM locks Class object during initialization"
                        ],
                        "extras": {
                            "flowDiagram": "First Active Use → Parent Initialized? → Execute Static Blocks (in order) → Execute Static Field Initializers → Class Ready",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-3-5",
                        "title": "Delegation Model",
                        "explanations": {
                            "english": "The delegation model is the class loading mechanism where a class loader delegates class loading requests to its parent loader before attempting to load itself. When loadClass() is invoked, the loader first calls parent.loadClass(); if parents return null, it calls findClass() to load locally. This ensures core Java classes are loaded by the Bootstrap loader, preventing rogue code from replacing java.lang.Object with malicious versions. The model provides security and uniqueness guarantees. However, some containers (like Tomcat) break delegation for web applications to provide isolation, using child-first loading to override parent classes while still delegating system classes."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "ClassLoader delegates to parent before attempting to load class itself",
                            "Parents check bootstrap → platform → then return down the chain",
                            "Prevents duplicate loading and ensures core classes loaded by bootstrap",
                            "Breakable for special cases like servlet container isolation"
                        ],
                        "extras": {
                            "flowDiagram": "loadClass() called\n    ↓\nCheck if already loaded? → Yes → Return Class\n    ↓ No\nDelegate to parent\n    ↓\nParent loaded? → Yes → Return Class\n    ↓ No\nfindClass() locally\n    ↓\nReturn Class or ClassNotFoundException",
                            "comparisonTable": "Model|Behavior|Use Case\nParent-first (standard)|Delegate up then load|Security, consistency\nChild-first (break)|Load locally first|Web app isolation\nOSGi|Network of loaders|Modular systems",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-4-1",
                        "title": "Program Counter (PC) Register",
                        "explanations": {
                            "english": "The Program Counter Register is a small, thread-private memory area containing the address of the currently executing JVM instruction (opcode) for each thread. As the JVM is stack-based, the PC tracks execution flow within the method area by pointing to the next instruction to execute in the bytecode stream. If the current method is native (non-Java), the PC value is undefined. The PC register enables thread switching and resumption by remembering exactly where execution left off. It is the only memory area that does not throw OutOfMemoryError since it requires only a small fixed amount of memory per thread."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "Thread-private register storing current instruction address",
                            "Points to next instruction in method bytecode",
                            "Undefined when executing native methods",
                            "Smallest memory area; never throws OutOfMemoryError"
                        ],
                        "extras": {
                            "flowDiagram": "Thread Execution:\nPC = 0: iload_1\nPC = 1: iload_2  \nPC = 2: iadd\nPC = 3: istore_3",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-4-2",
                        "title": "Java Stack",
                        "explanations": {
                            "english": "The Java Virtual Machine Stack (Java Stack) is a thread-private memory area that stores stack frames for method invocations. Each frame contains local variables, operand stack, dynamic linking information, and return address. When a method is called, a new frame is pushed; when it completes, the frame is popped. The stack size is fixed at thread creation (-Xss flag) and can generate StackOverflowError if exceeded (infinite recursion) or OutOfMemoryError if trying to create a new thread when insufficient memory exists for its stack. Stack frames are allocated efficiently and automatically cleaned up when methods return, making allocation faster than heap allocation."
                        },
                        "code": {
                            "title": "Stack Frame Contents",
                            "language": "java",
                            "content": "public int calculate(int a, int b) {\n    int c = a + b;  // Local variables a, b, c stored in frame\n    return c * 2;   // Operand stack used for calculation\n}\n\n// Frame contains:\n// - Local variable array: [a, b, c]\n// - Operand stack: push a, push b, iadd, push 2, imul\n// - Constant pool reference for dynamic linking\n// - Return address to caller"
                        },
                        "codeExplanations": {
                            "english": "Each method invocation creates a frame containing space for parameters and local variables in the local variable array. The operand stack is used for intermediate calculations during bytecode execution. The return address tells the JVM where to continue after the method completes."
                        },
                        "keyPoints": [
                            "Thread-private; one Java Stack per thread",
                            "Stores frames with local variables, operand stack, return address",
                            "Fixed size per thread; StackOverflowError if exceeded",
                            "Faster allocation/deallocation than heap (simple pointer bump)"
                        ],
                        "extras": {
                            "flowDiagram": "Thread 1 Stack:\n[calculate frame: locals=[a,b,c], operands=[]]\n[main frame: locals=[args, result]]\n\nThread 2 Stack:\n[run frame: ...]\n[main frame: ...]",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-4-3",
                        "title": "Heap",
                        "explanations": {
                            "english": "The Heap is the primary, shared runtime data area allocated at JVM startup that stores all object instances and arrays. It is the largest memory area and is managed automatically by the garbage collector. The heap is divided into generations (Eden, Survivor, Old/Teured) or regions (G1) to optimize garbage collection. Objects persist as long as they are referenced; when unreachable, they become eligible for GC. Heap size is controlled by -Xms (initial) and -Xmx (maximum). Unlike the stack, heap allocation is slower due to synchronization requirements and GC management, but objects can outlive the method that created them."
                        },
                        "code": {
                            "title": "",
                            "language": "",
                            "content": ""
                        },
                        "codeExplanations": {
                            "english": ""
                        },
                        "keyPoints": [
                            "Shared among all threads; stores all objects and arrays",
                            "Managed by garbage collector; objects survive while referenced",
                            "Sized by -Xms (initial) and -Xmx (maximum)",
                            "Divided into generations/regions for GC efficiency"
                        ],
                        "extras": {
                            "flowDiagram": "Heap Structure (Generational):\n[Young Gen]: Eden Space [E][E][E...]\n           Survivor 0 [S]\n           Survivor 1 [S]\n[Old Gen]: Tenured Space [O][O][O...]",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-4-4",
                        "title": "Metaspace",
                        "explanations": {
                            "english": "Metaspace, introduced in Java 8, replaced the Permanent Generation (PermGen) as the storage area for class metadata. It stores the runtime constant pool, field and method data, constructor bytecode, and class-level information. Unlike the fixed-size PermGen which caused OutOfMemoryError when full, Metaspace uses native memory (outside the Java heap) and expands dynamically, limited only by available system memory unless capped with -XX:MaxMetaspaceSize. Class metadata is garbage collected when their defining class loaders are unloaded, preventing leaks in dynamic class loading scenarios (like app servers redeploys). While eliminating PermGen errors requires monitoring to prevent native memory exhaustion."
                        },
                        "code": {
                            "title": "Metaspace Configuration",
                            "language": "java",
                            "content": "// JVM Flags for Metaspace\n// -XX:MetaspaceSize=64m (initial size)\n// -XX:MaxMetaspaceSize=256m (max limit, default unlimited)\n// -XX:MinMetaspaceFreeRatio=40\n// -XX:MaxMetaspaceFreeRatio=80\n\n// Check Metaspace usage\n// jcmd <pid> VM.metaspace"
                        },
                        "codeExplanations": {
                            "english": "MetaspaceSize sets the initial committed space, similar to -Xms for heap. MaxMetaspaceSize prevents unbounded growth that could exhaust native memory. The ratio settings control when to resize based on free space percentage. Monitoring commands help diagnose class loading issues in production."
                        },
                        "keyPoints": [
                            "Stores class metadata (methods, fields, constant pool) replacing PermGen",
                            "Uses native memory (off-heap), expands automatically",
                            "No default limit (unlike PermGen's fixed 64MB default), set MaxMetaspaceSize to cap",
                            "Garbage collected when class loaders are unloaded"
                        ],
                        "extras": {
                            "flowDiagram": "Class Loaders → Load Classes → Store metadata in Metaspace\n                            ↓\nClass Loader Unloaded → Metaspace GC reclaims metadata",
                            "comparisonTable": "Feature|PermGen (Java 7)|Metaspace (Java 8+)\nLocation|Heap|Native memory\nSize|Fixed, -XX:MaxPermSize|Dynamic, -XX:MaxMetaspaceSize\nGC|Rare|When classloader unloads\nOutOfMemory|Yes (common)|Only if native memory exhausted",
                            "examples": []
                        }
                    },
                    {
                        "id": "s3-4-5",
                        "title": "Native Method Stack",
                        "explanations": {
                            "english": "The Native Method Stack (C Stack) supports the execution of native methods written in languages like C or C++ using the Java Native Interface (JNI). When a thread invokes a native method, it switches from the Java Stack to the Native Method Stack, which uses the standard C stack convention rather than Java's stack frame structure. This area is thread-private and created when the thread starts. Native stacks are not directly configurable via standard JVM flags like -Xss (which configures the Java Stack). They can generate StackOverflowError if native code recurses deeply or allocates large stack frames. The size is implementation-dependent, typically matching the process stack size."
                        },
                        "code": {
                            "title": "Native Method Usage",
                            "language": "java",
                            "content": "public class NativeDemo {\n    // Native method declaration\n    public native void nativeMethod();\n    \n    static {\n        // Load native library\n        System.loadLibrary(\"nativeLib\");\n    }\n    \n    public void callNative() {\n        // Switch to native stack here\n        nativeMethod();\n        // Return to Java stack\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "When nativeMethod() is called, the JVM switches from Java bytecode execution to native code execution on the Native Method Stack. The library containing the native implementation is loaded via System.loadLibrary(). Native stacks handle C-style calling conventions and memory management separate from the Java Stack."
                        },
                        "keyPoints": [
                            "Separate stack for native (JNI) method execution using C conventions",
                            "Thread-private; switches from Java Stack when calling native code",
                            "Size typically not independently configurable; uses OS process stack",
                            "Can throw StackOverflowError from deep recursion in native code"
                        ],
                        "extras": {
                            "flowDiagram": "Thread:\n[Java Stack] → Call nativeMethod() → [Native Stack (C code)]\n                                          ↓\n                                    Return to Java Stack",
                            "comparisonTable": "Stack Type|Language|Frame Structure|Config\nJava Stack|Java|JVM specific (locals, operands)|-Xss\nNative Stack|C/C++|Platform ABI (registers, C locals)|OS dependent",
                            "examples": []
                        }
                    }
                ]
            },
            {
                "id": "section-4",
                "title": "Exception Handling",
                "topics": [
                    {
                        "id": "s4-1-1",
                        "title": "Throwable",
                        "explanations": {
                            "english": "Throwable is the root superclass of all error and exception classes in Java, forming the top of the exception hierarchy. Only objects that are instances of Throwable or its subclasses can be thrown by the JVM or caught by catch blocks. It provides the fundamental mechanisms for error handling: stack trace information (via fillInStackTrace), detail messages, and cause chaining (wrapped exceptions). Throwable has two direct subclasses: Error for unrecoverable system failures and Exception for application-level conditions that programs should catch. Understanding Throwable is essential for designing robust error handling strategies, as it defines the common interface for all exceptional conditions including message retrieval, stack trace printing, and exception chaining."
                        },
                        "code": {
                            "title": "Throwable Hierarchy",
                            "language": "java",
                            "content": "// Throwable is checked; must be caught or declared\npublic void riskyMethod() throws Throwable {\n    throw new Throwable(\"Something went wrong\");\n}\n\n// Catching base Throwable (usually not recommended in production)\ntry {\n    riskyMethod();\n} catch (Throwable t) {\n    System.out.println(\"Message: \" + t.getMessage());\n    t.printStackTrace(); // Print full stack trace\n    \n    // Cause chaining\n    Throwable cause = t.getCause();\n    if (cause != null) {\n        System.out.println(\"Caused by: \" + cause);\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This example demonstrates Throwable as the base type that can be thrown and caught. While possible to catch Throwable, it's generally bad practice except at the very top level of thread execution because it catches everything including Errors (like OutOfMemoryError) that applications typically cannot handle meaningfully. The example shows common Throwable methods: getMessage(), printStackTrace(), and getCause()."
                        },
                        "keyPoints": [
                            "Root superclass of all errors and exceptions in Java",
                            "Only Throwable objects can be thrown by JVM or caught by catch blocks",
                            "Provides common functionality: message, stack trace, cause chaining",
                            "Two main subclasses: Error (unrecoverable) and Exception (application-level)"
                        ],
                        "extras": {
                            "flowDiagram": "Throwable (abstract/base)\n    ├── Error (unchecked)\n    │   ├── OutOfMemoryError\n    │   ├── StackOverflowError\n    │   └── ...\n    └── Exception\n        ├── RuntimeException (unchecked)\n        │   ├── NullPointerException\n        │   └── IllegalArgumentException\n        └── Other Exceptions (checked)\n            ├── IOException\n            └── SQLException",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-1-2",
                        "title": "Error",
                        "explanations": {
                            "english": "Error represents serious, unrecoverable problems that applications should not attempt to catch, arising from external factors beyond program control. These include conditions like OutOfMemoryError, StackOverflowError, LinkageError, and VirtualMachineError that indicate fundamental system failures, resource exhaustion, or internal JVM errors. Unlike exceptions, errors typically warrant immediate application termination as recovery is usually impossible or dangerous. For example, OutOfMemoryError means the heap is exhausted; catching it may allow code to run briefly but will likely fail again immediately. While technically catchable, catching Errors is strongly discouraged except for logging or attempting graceful shutdown of critical resources before termination."
                        },
                        "code": {
                            "title": "Error Handling (Anti-pattern)",
                            "language": "java",
                            "content": "// Do NOT do this in production\npublic void dangerousCatch() {\n    try {\n        causeStackOverflow();\n    } catch (Error e) { // Bad practice\n        System.out.println(\"Caught error: \" + e);\n        // Application state may be corrupted; continuing is dangerous\n    }\n}\n\n// Acceptable: Top-level thread exception handler\nThread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {\n    if (throwable instanceof Error) {\n        // Log the error\n        logger.error(\"Fatal JVM error\", throwable);\n        // Attempt graceful shutdown\n        shutdownCriticalResources();\n        // Exit the application\n        System.exit(1);\n    }\n});"
                        },
                        "codeExplanations": {
                            "english": "The first example shows catching Error directly, which is dangerous because the JVM may be in an unstable state. The second example shows an acceptable pattern: a top-level uncaught exception handler that catches Errors only to log them and perform emergency cleanup before terminating the process, acknowledging that recovery is impossible."
                        },
                        "keyPoints": [
                            "Indicates serious, unrecoverable problems (system failures, resource exhaustion)",
                            "Subclasses include OutOfMemoryError, StackOverflowError, VirtualMachineError",
                            "Applications should NOT catch Errors; allow JVM to terminate",
                            "Catching Error may capture OutOfMemoryError but recovery is usually impossible"
                        ],
                        "extras": {
                            "flowDiagram": "System Failure → Error Thrown → (Do Not Catch) → JVM terminates\n                                    ↓\n                           Catch for logging only → Immediate shutdown",
                            "comparisonTable": "Aspect|Error|Exception\nRecovery|None|Possible\nCatching|Discouraged|Expected\nExamples|OutOfMemoryError|IOException\nHandling|Log and exit|Recover and continue",
                            "examples": [
                                "OutOfMemoryError",
                                "StackOverflowError",
                                "NoClassDefFoundError",
                                "VirtualMachineError"
                            ]
                        }
                    },
                    {
                        "id": "s4-1-3",
                        "title": "Exception",
                        "explanations": {
                            "english": "Exception is the superclass for all application-level conditions that programs should catch and handle, distinguishing them from fatal Errors. It represents scenarios like file not found, network timeouts, or invalid user input where recovery is possible and the program can continue execution meaningfully. Exception itself and its non-RuntimeException subclasses are checked exceptions, meaning the compiler requires them to be either caught with try-catch or declared in the method signature with throws. This forces developers to acknowledge potential failures and design appropriate error handling strategies. Well-designed applications use specific Exception subclasses (like IOException or SQLException) rather than generic Exception to provide precise error context."
                        },
                        "code": {
                            "title": "Exception Handling Pattern",
                            "language": "java",
                            "content": "// Checked exception must be caught or declared\npublic void readConfig() throws FileNotFoundException {\n    FileInputStream fis = new FileInputStream(\"app.config\");\n}\n\n// Proper handling\ntry {\n    readConfig();\n    processConfig();\n} catch (FileNotFoundException e) {\n    // Specific handling for missing config\n    useDefaultConfig();\n} catch (IOException e) {\n    // Broader handling for other IO issues\n    logger.error(\"IO error\", e);\n    throw new ApplicationException(\"Config failed\", e);\n}"
                        },
                        "codeExplanations": {
                            "english": "FileNotFoundException is a checked Exception subclass. The method declares it with throws, forcing callers to handle it. The try-catch shows specific exception handling (FileNotFoundException) before general (IOException), demonstrating proper ordering. Recovery strategies (useDefaultConfig) allow the program to continue despite the exception."
                        },
                        "keyPoints": [
                            "Superclass for application-level conditions that should be caught",
                            "Checked by compiler: must be caught or declared in throws clause",
                            "Recovery is possible; program can continue execution",
                            "Prefer specific subclasses over generic Exception for precise handling"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "",
                            "examples": [
                                "IOException",
                                "SQLException",
                                "ClassNotFoundException",
                                "ParseException"
                            ]
                        }
                    },
                    {
                        "id": "s4-1-4",
                        "title": "RuntimeException",
                        "explanations": {
                            "english": "RuntimeException is the superclass of all unchecked exceptions representing programming errors and precondition violations that typically indicate bugs in the code. These exceptions (NullPointerException, IllegalArgumentException, IndexOutOfBoundsException) are unchecked, meaning the compiler does not require explicit catch or throws declarations, though they can be caught if desired. They usually result from improper API usage, invalid assumptions, or logic errors that should be fixed rather than caught. Unlike checked exceptions that represent external conditions, RuntimeExceptions represent internal program state violations. Best practices suggest validating inputs to prevent these exceptions rather than catching them, though defensive programming may catch specific ones like NumberFormatException for user input parsing."
                        },
                        "code": {
                            "title": "RuntimeException Examples",
                            "language": "java",
                            "content": "// Programming errors - should fix code, not catch\npublic void process(String data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    int value = Integer.parseInt(data); // NumberFormatException possible\n}\n\n// Defensive handling for user input\ntry {\n    int age = Integer.parseInt(userInput);\n} catch (NumberFormatException e) {\n    // Expected possible user error\n    showError(\"Please enter a valid number\");\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows proper validation throwing IllegalArgumentException (RuntimeException) for API contract violations. The second shows catching NumberFormatException (also RuntimeException) for user input parsing, which is acceptable because user input is unpredictable, unlike internal programming errors."
                        },
                        "keyPoints": [
                            "Superclass of unchecked exceptions indicating programming errors",
                            "Unchecked: compiler does not enforce catching or declaration",
                            "Represents precondition violations, invalid arguments, null dereferences",
                            "Usually indicate bugs; fix the code rather than catching the exception"
                        ],
                        "extras": {
                            "flowDiagram": "",
                            "comparisonTable": "Exception Type|Checked|Cause|Handling\nException|Yes|External conditions|Catch and recover\nRuntimeException|No|Programming errors|Fix the bug\nError|No|System failure|Do not catch",
                            "examples": [
                                "NullPointerException",
                                "IllegalArgumentException",
                                "IndexOutOfBoundsException",
                                "NumberFormatException"
                            ]
                        }
                    },
                    {
                        "id": "s4-2-1",
                        "title": "Compile-time Checking",
                        "explanations": {
                            "english": "Compile-time checking refers to the compiler's enforcement of checked exceptions, requiring that any method throwing a checked exception must either catch it with a try-catch block or declare it in the method signature using the throws clause. This creates a compile-time contract documenting which exceptions can propagate from a method, forcing developers to consider error handling during development rather than discovering failures at runtime. The compiler verifies that checked exceptions in the throws clause are either caught by callers or declared in their own throws clauses, creating a chain of accountability up to the appropriate handler. This mechanism ensures that recoverable error conditions (I/O failures, database errors, missing files) are explicitly acknowledged in the API design."
                        },
                        "code": {
                            "title": "Checked Exception Enforcement",
                            "language": "java",
                            "content": "// Method declares checked exception\npublic void readFile(String path) throws IOException {\n    FileReader reader = new FileReader(path);\n    // ...\n}\n\n// Caller must handle or declare\npublic void processFile(String path) {\n    // Compiler error if try-catch missing\n    try {\n        readFile(path);\n    } catch (IOException e) {\n        // Must handle\n        log.error(\"Read failed\", e);\n    }\n}\n\n// OR declare it\npublic void processFile(String path) throws IOException {\n    readFile(path); // OK, declares throws\n}"
                        },
                        "codeExplanations": {
                            "english": "The readFile method declares IOException with throws. The compiler forces callers (processFile) to either catch IOException in a try-catch block or add throws IOException to their own signature. This creates a chain of explicit handling obligations up the call stack until someone catches it."
                        },
                        "keyPoints": [
                            "Compiler verifies checked exceptions are caught or declared",
                            "Forces explicit documentation of potential failure modes in APIs",
                            "Creates compile-time safety for recoverable error conditions",
                            "Unchecked exceptions (RuntimeException/Error) bypass this checking"
                        ],
                        "extras": {
                            "flowDiagram": "Method A throws IOException → Method B calls A → Compile Error unless: \n    ↓\nMethod B catches OR Method B declares throws IOException",
                            "comparisonTable": "Checking Type|When|Exceptions|Action Required\nChecked|Compile time|IOException, SQLException|Catch or declare\nUnchecked|Runtime|RuntimeException, Error|Optional handling",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-2-2",
                        "title": "Runtime Exceptions",
                        "explanations": {
                            "english": "Runtime exceptions represent programming errors and precondition violations that occur during program execution but are not checked by the compiler. They typically result from logic errors, invalid assumptions, or improper API usage that should be prevented through proper validation rather than caught. Common examples include NullPointerException when dereferencing null, IllegalArgumentException for invalid parameters, and IndexOutOfBoundsException for array/string access violations. Because these indicate bugs, the recommended approach is to validate inputs and state proactively rather than catching these exceptions. However, they may be caught at high-level boundaries (like controller layers) to convert them to user-friendly error messages or logged for debugging, not for business logic flow control."
                        },
                        "code": {
                            "title": "Runtime Exception Prevention",
                            "language": "java",
                            "content": "// Bad: Relying on catch for flow control\ntry {\n    int value = Integer.parseInt(input);\n} catch (NumberFormatException e) {\n    value = 0; // Using exception for logic\n}\n\n// Good: Validation before operation\nif (input != null && input.matches(\"\\\\d+\")) {\n    int value = Integer.parseInt(input);\n} else {\n    value = 0; // Explicit handling\n}\n\n// Guard clauses to prevent NPE\npublic void processUser(User user) {\n    if (user == null) {\n        throw new IllegalArgumentException(\"User required\");\n    }\n    if (user.getEmail() == null) {\n        throw new IllegalStateException(\"Email required\");\n    }\n    // Process safely\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows anti-pattern: using exceptions for flow control. The improved version validates format before parsing. The guard clause pattern validates preconditions and throws IllegalArgumentException (RuntimeException) immediately if contract is violated, preventing downstream NullPointerExceptions and making failures explicit."
                        },
                        "keyPoints": [
                            "Unchecked: compiler does not enforce handling",
                            "Indicate programming errors and precondition violations",
                            "Prevent with validation rather than catching",
                            "May be caught at boundaries for logging/user messages only"
                        ],
                        "extras": {
                            "flowDiagram": "Invalid Input → NullPointerException → (Should have validated)\nValid Input → Process → Success",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-2-3",
                        "title": "When to Use Which",
                        "explanations": {
                            "english": "Choosing between checked and unchecked exceptions depends on whether the caller can reasonably recover from the condition and whether the exception represents a programming error or external failure. Use checked exceptions for recoverable conditions where the caller is expected to handle the failure (IOException, SQLException, ParseException). Use unchecked exceptions (RuntimeException) for programming errors, precondition violations, or conditions where recovery is impossible or unlikely (NullPointerException, IllegalStateException). Custom exceptions should extend Exception for business errors requiring explicit handling, or RuntimeException for API contract violations. Overuse of checked exceptions burdens APIs with unnecessary handling code, while underuse risks missing critical error conditions."
                        },
                        "code": {
                            "title": "Exception Selection Guidelines",
                            "language": "java",
                            "content": "// Checked: Recoverable external condition\npublic class PaymentProcessingException extends Exception {\n    public PaymentProcessingException(String msg, Throwable cause) {\n        super(msg, cause);\n    }\n}\n\n// Unchecked: Programming error\npublic class InvalidCurrencyException extends RuntimeException {\n    public InvalidCurrencyException(String currency) {\n        super(\"Unsupported currency: \" + currency);\n    }\n}\n\n// Usage\npublic void processPayment(PaymentRequest request) \n    throws PaymentProcessingException { // Checked: network might fail\n    \n    if (!isValidCurrency(request.getCurrency())) {\n        throw new InvalidCurrencyException(request.getCurrency()); \n        // Unchecked: caller should validate before calling\n    }\n    // ...\n}"
                        },
                        "codeExplanations": {
                            "english": "PaymentProcessingException is checked because network/DB failures are external and possibly recoverable (retry, alternate payment). InvalidCurrencyException is unchecked because callers should validate currency before calling; passing invalid currency is a programming error (precondition violation). This distinction helps API users understand which failures to expect and handle."
                        },
                        "keyPoints": [
                            "Checked: Recoverable conditions, external resources, expect handling",
                            "Unchecked: Programming errors, precondition violations, unrecoverable",
                            "Extend Exception for checked, RuntimeException for unchecked custom types",
                            "Avoid checked exceptions for programming logic errors"
                        ],
                        "extras": {
                            "flowDiagram": "External Resource Failure (IO, DB, Network) → Checked Exception\nInvalid Argument/State (null, range, format) → Unchecked Exception",
                            "comparisonTable": "Scenario|Type|Example\nFile not found|Checked|IOException\nNetwork timeout|Checked|SocketTimeoutException\nNull argument|Unchecked|IllegalArgumentException\nArray index wrong|Unchecked|IndexOutOfBoundsException\nBusiness rule violation|Checked/Design choice|InsufficientFundsException",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-3-1",
                        "title": "Multiple Catch Blocks",
                        "explanations": {
                            "english": "Java allows multiple catch blocks to handle different exception types with specific recovery strategies for each failure mode. Blocks are evaluated in order, and the first matching catch handles the exception, so specific exception types must precede more general ones to avoid unreachable code compilation errors. Java 7 introduced multi-catch syntax (catch (Exception1 | Exception2 e)) allowing shared handling for unrelated exception types with the same recovery logic, reducing code duplication. Each catch block represents an isolated scope; variables declared in one are not visible to others. Proper ordering follows the hierarchy from most specific (FileNotFoundException) to most general (IOException)."
                        },
                        "code": {
                            "title": "Multiple Catch Patterns",
                            "language": "java",
                            "content": "try {\n    processFile();\n} catch (FileNotFoundException e) {\n    // Specific: create default file\n    createDefaultFile();\n} catch (IOException e) {\n    // General: log and retry\n    logger.error(\"IO error\", e);\n    retryOperation();\n} catch (Exception e) {\n    // Catch-all for unexpected\n    logger.fatal(\"Unexpected error\", e);\n    throw e;\n}\n\n// Java 7+ Multi-catch\ntry {\n    processData();\n} catch (SQLException | IOException e) {\n    // Common handling for different exception types\n    logger.error(\"Data access failed\", e);\n    throw new DataAccessException(e);\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows ordered catches: FileNotFoundException (specific) before IOException (general). Reversing them would make FileNotFoundException unreachable. The multi-catch example handles SQLException and IOException identically without code duplication, assigning the common supertype (Exception/Throwable) to variable 'e' implicitly."
                        },
                        "keyPoints": [
                            "Order catch blocks from most specific to most general",
                            "Unreachable catch blocks cause compilation errors",
                            "Multi-catch (Java 7+) handles multiple unrelated exceptions with same logic",
                            "Each catch block has its own scope; local variables not shared"
                        ],
                        "extras": {
                            "flowDiagram": "Exception Thrown → Match FileNotFoundException? → Yes → Execute Block 1\n                ↓ No\n         Match IOException? → Yes → Execute Block 2\n                ↓ No\n         Match Exception? → Yes → Execute Block 3",
                            "comparisonTable": "Approach|Syntax|Use Case\nSequential catch|catch(A) catch(B)|Different handling per type\nMulti-catch|catch(A | B)|Same handling for multiple types",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-3-2",
                        "title": "Exception Propagation",
                        "explanations": {
                            "english": "Exception propagation is the process where an exception moves up the method call stack when not caught in the current method. When a method encounters an exception it doesn't handle, execution immediately stops and the exception is passed to the calling method. This continues up the stack until either a method catches the exception with an appropriate catch block or it reaches the top-level (main thread or ThreadGroup), resulting in thread termination and stack trace printing. Methods declare propagated checked exceptions using the throws clause, documenting which exceptions might escape. Propagation allows errors to be handled at appropriate levels (e.g., UI layer handling user errors, service layer handling business logic errors) rather than at every intermediate level."
                        },
                        "code": {
                            "title": "Stack Unwinding",
                            "language": "java",
                            "content": "// Method 3: Originates exception\nprivate void method3() throws IOException {\n    throw new IOException(\"Disk full\");\n}\n\n// Method 2: Passes through\nprivate void method2() throws IOException {\n    method3(); // Propagates up\n}\n\n// Method 1: Handles\nprivate void method1() {\n    try {\n        method2();\n    } catch (IOException e) {\n        // Caught here after propagating through method2\n        handleError(e);\n    }\n}\n\n// Stack trace shows:\n// java.io.IOException: Disk full\n// at method3(...)\n// at method2(...)\n// at method1(...)"
                        },
                        "codeExplanations": {
                            "english": "method3 throws IOException without catching it. method2 also doesn't catch it, so it propagates further (must declare throws IOException). method1 catches it, stopping the propagation. The stack trace preserves the origin (method3) and the call chain, enabling debugging of where the exception originated."
                        },
                        "keyPoints": [
                            "Uncaught exceptions propagate up the call stack automatically",
                            "Methods declare propagated checked exceptions with throws clause",
                            "Execution stops in current method; control passes to handler up stack",
                            "Stack trace preserves origin and call chain information"
                        ],
                        "extras": {
                            "flowDiagram": "method1() calls → method2() calls → method3() throws IOException\n        ↑                       ↑\n        ↓                       ↓\n    Catch here ← Propagates ← Throw\n    (Stack unwinds)",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-3-3",
                        "title": "Suppressed Exceptions",
                        "explanations": {
                            "english": "Suppressed exceptions are secondary exceptions that occur during resource cleanup in try-finally or try-with-resources blocks, but are masked by the primary exception. Before Java 7, if an exception occurred in both the try block and the finally block, the finally exception would overwrite the original, losing the root cause. Java 7 introduced addSuppressed() to attach additional exceptions to the primary exception, preserving all error information. Try-with-resources automatically handles suppression; if both the try block and resource close() throw exceptions, the close exception is added as suppressed to the try block exception. When analyzing logs, suppressed exceptions provide complete context about failures during cleanup operations."
                        },
                        "code": {
                            "title": "Handling Suppressed Exceptions",
                            "language": "java",
                            "content": "try (Resource res = new Resource()) {\n    res.doWork(); // Throws WorkException\n} catch (WorkException e) {\n    // Primary exception\n    System.out.println(\"Primary: \" + e.getMessage());\n    \n    // Check for suppressed (close failures)\n    for (Throwable suppressed : e.getSuppressed()) {\n        System.out.println(\"Suppressed: \" + suppressed.getMessage());\n    }\n}\n\n// Manual suppression (before try-with-resources)\npublic void manualClose() {\n    Exception primary = null;\n    Resource res = null;\n    try {\n        res = new Resource();\n        res.doWork();\n    } catch (Exception e) {\n        primary = e;\n        throw e;\n    } finally {\n        try {\n            res.close();\n        } catch (Exception closeEx) {\n            if (primary != null) {\n                primary.addSuppressed(closeEx);\n            }\n        }\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The try-with-resources example shows that if doWork() and close() both throw, the close exception is added as suppressed to the work exception. The catch block accesses both via getSuppressed(). The manual example shows how to implement suppression logic manually using addSuppressed(), preserving all error information."
                        },
                        "keyPoints": [
                            "Secondary exceptions occurring during cleanup attached to primary exception",
                            "Prevent loss of original exception when cleanup also fails",
                            "Try-with-resources automatically manages suppression",
                            "Access via Throwable.getSuppressed() and Throwable.addSuppressed()"
                        ],
                        "extras": {
                            "flowDiagram": "Try block: throws Exception A\n    ↓\nFinally/Close: throws Exception B\n    ↓\nResult: Exception A with Exception B as suppressed (not lost)",
                            "comparisonTable": "Java Version|Behavior\nPre-Java 7|Finally exception overwrites try exception (lost)\nJava 7+|Suppressed exceptions preserve both",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-3-4",
                        "title": "finally Block Behavior",
                        "explanations": {
                            "english": "The finally block executes regardless of whether the try block completes normally, throws an exception, or uses a return, break, or continue statement. It is designed for essential cleanup operations like closing resources, releasing locks, or returning connections to pools. Even if an exception is thrown and caught, or if the method returns in the try block, finally runs before control leaves the method. However, if the JVM exits (System.exit()) or the thread is interrupted/killed abruptly, finally may not execute. Care must be taken because an exception thrown in finally will mask any exception from the try block. Finally blocks should avoid throwing exceptions or should handle them internally to preserve original error context."
                        },
                        "code": {
                            "title": "Finally Execution Guarantees",
                            "language": "java",
                            "content": "public int testFinally() {\n    try {\n        return 1; // Finally runs before return\n    } finally {\n        System.out.println(\"Finally executes\");\n        // If this threw exception, it would mask the return\n    }\n}\n\n// Resource cleanup pattern\nConnection conn = null;\ntry {\n    conn = getConnection();\n    processData(conn);\n} catch (SQLException e) {\n    handleError(e);\n} finally {\n    // Always executes, even if return/break/continue/exception\n    if (conn != null) {\n        try {\n            conn.close();\n        } catch (SQLException e) {\n            // Log but don't throw to preserve original exception\n            logger.error(\"Close failed\", e);\n        }\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows finally executes even when try returns 1. In the second example, the connection close in finally happens regardless of whether processData succeeded, threw SQLException, or returned early. The close exception is logged rather than thrown to avoid masking the original SQL exception that might have occurred in processData."
                        },
                        "keyPoints": [
                            "Always executes (unless JVM exits abruptly)",
                            "Runs after try completes, return executes, or catch handles exception",
                            "Use for cleanup that must occur: close files, release locks, return resources",
                            "Avoid throwing exceptions in finally; will mask original exceptions"
                        ],
                        "extras": {
                            "flowDiagram": "Try Block:\n    Normal completion → Finally → Continue\n    Exception thrown → Catch (if exists) → Finally → Propagate if uncaught\n    Return statement → Finally → Return",
                            "comparisonTable": "Scenario|Finally Executes?\nTry completes|Yes\nException caught|Yes\nException uncaught|Yes\nReturn in try|Yes\nSystem.exit()|No\nThread killed|No",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-4-1",
                        "title": "Explicit Exception Throwing",
                        "explanations": {
                            "english": "The throw statement explicitly raises an exception object, immediately transferring control to the nearest enclosing catch block or propagating up the call stack. Any Throwable object can be thrown, though typically Error or Exception subclasses are used. When throwing, the exception object captures the current stack trace at the throw point, enabling debugging. Throwing is used both for signaling exceptional conditions detected by program logic (like invalid arguments) and for re-throwing caught exceptions after partial handling or wrapping. Thrown exceptions terminate the current method execution immediately, making throw useful for guard clauses that exit early when preconditions are violated."
                        },
                        "code": {
                            "title": "Throw Statement Usage",
                            "language": "java",
                            "content": "public void withdraw(double amount) {\n    // Guard clause with explicit throw\n    if (amount <= 0) {\n        throw new IllegalArgumentException(\"Amount must be positive: \" + amount);\n    }\n    if (amount > balance) {\n        throw new InsufficientFundsException(\"Balance: \" + balance + \", Requested: \" + amount);\n    }\n    \n    balance -= amount;\n}\n\n// Re-throwing exceptions\ntry {\n    process();\n} catch (ServiceException e) {\n    // Wrap and throw with context\n    throw new BusinessException(\"Processing failed for order \" + orderId, e);\n}"
                        },
                        "codeExplanations": {
                            "english": "The withdraw method uses throw for precondition validation, exiting immediately with descriptive messages when conditions fail. The first throw uses standard IllegalArgumentException for API violations; the second uses custom InsufficientFundsException for domain errors. The second example shows catching and wrapping (chaining) to add context before re-throwing."
                        },
                        "keyPoints": [
                            "throw statement transfers control immediately to handler",
                            "Creates stack trace at point of throw; terminates current method execution",
                            "Used for guard clauses, validation failures, and re-throwing wrapped exceptions",
                            "Can throw any Throwable, typically Exception or RuntimeException subclasses"
                        ],
                        "extras": {
                            "flowDiagram": "Check Condition → If invalid → throw NewException → Control to Catch Block\n                ↓ Valid\n        Continue Processing",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-4-2",
                        "title": "Declaring Exceptions",
                        "explanations": {
                            "english": "The throws clause in a method declaration specifies which checked exceptions the method may throw, alerting callers that they must handle these exceptions or declare them in their own signatures. It documents the failure modes of the method contract, forming part of the API that must be maintained for backward compatibility. Methods can declare multiple exception types separated by commas, and subclasses overriding methods can declare the same or more specific (subclass) exceptions, but not broader ones. Declaring unchecked exceptions (RuntimeException subclasses) is allowed but discouraged as unnecessary since they're unchecked. Interface methods that declare checked exceptions force implementations to handle or declare them, ensuring consistent error handling contracts across polymorphic types."
                        },
                        "code": {
                            "title": "Throws Clause Usage",
                            "language": "java",
                            "content": "// Declare multiple checked exceptions\npublic void parseFile(String path) \n    throws FileNotFoundException, ParseException, IOException {\n    \n    FileReader reader = new FileReader(path); // FNFException\n    Parser p = new Parser(reader);\n    p.parse(); // ParseException\n}\n\n// Overriding: can declare same or subclass (covariant)\n@Override\npublic void parseFile(String path) throws FileNotFoundException {\n    // OK: IOException and ParseException are omitted (not broader)\n}\n\n// Cannot declare broader exception in override\n// @Override\n// public void parseFile(String path) throws Exception { // Compile error!"
                        },
                        "codeExplanations": {
                            "english": "parseFile declares three checked exceptions it might throw. Callers must catch or declare these. When overriding, the method can declare a subset (FileNotFoundException only) because it's more specific than the parent's declared exceptions. Declaring Exception (superclass of declared exceptions) would be broader and illegal in overrides."
                        },
                        "keyPoints": [
                            "Documents checked exceptions method may throw",
                            "Caller must catch or declare checked exceptions listed",
                            "Override can declare same or subset/subclass of parent's exceptions\n            Not broader",
                            "Part of method contract; changing declaration breaks API compatibility"
                        ],
                        "extras": {
                            "flowDiagram": "Method Declaration: throws ExceptionA, ExceptionB\n    ↓\nCaller must:\n    - Catch in try-catch, OR\n    - Declare in own throws clause",
                            "comparisonTable": "Declares|Checked Exceptions|Unchecked Exceptions\nRequired|Yes|Optional (discouraged)\nOverride rule|Same or subset|No restriction\nAPI Impact|Breaking change|Non-breaking",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-4-3",
                        "title": "Chained Exceptions",
                        "explanations": {
                            "english": "Exception chaining preserves the original exception when wrapping it in a higher-level exception, maintaining the complete error context across abstraction boundaries. The low-level cause (like SQLException) is passed to the high-level exception constructor (like RepositoryException), which stores it via initCause(). Chaining prevents loss of root cause information when translating exceptions between architectural layers (persistence to service to UI). The complete causal chain can be accessed via getCause() and appears in stack traces with 'Caused by'. This is crucial for debugging multi-layer applications where the original error occurs deep in infrastructure code but needs to be reported through several abstraction layers."
                        },
                        "code": {
                            "title": "Exception Chaining Pattern",
                            "language": "java",
                            "content": "try {\n    executeQuery();\n} catch (SQLException e) {\n    // Wrap low-level exception with context\n    throw new DataAccessException(\"Failed to fetch user \" + userId, e);\n}\n\n// Custom exception supporting chaining\npublic class DataAccessException extends RuntimeException {\n    public DataAccessException(String message, Throwable cause) {\n        super(message, cause); // Chains cause\n    }\n}\n\n// Accessing the chain\ntry {\n    process();\n} catch (DataAccessException e) {\n    System.out.println(\"Message: \" + e.getMessage());\n    \n    Throwable cause = e.getCause();\n    while (cause != null) {\n        System.out.println(\"Caused by: \" + cause.getClass().getName());\n        cause = cause.getCause();\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "SQLException is caught and wrapped in DataAccessException with added context (userId). The original exception is passed as the cause parameter. Custom exception constructors should accept Throwable cause and pass to superclass. When printing or logging, the stack trace shows the full causal chain, enabling debugging to trace from the high-level error back to the original database failure."
                        },
                        "keyPoints": [
                            "Preserves original exception when wrapping in higher-level exception",
                            "Pass original exception as constructor parameter (cause)",
                            "Access via getCause() and displayed as 'Caused by' in stack traces",
                            "Essential for debugging across architectural layers"
                        ],
                        "extras": {
                            "flowDiagram": "BusinessException: \"Payment failed\"\n    ↑ getCause()\nServiceException: \"Transaction rolled back\"\n    ↑ getCause()\nSQLException: \"Connection timeout\" ← Root cause",
                            "comparisonTable": "Without Chaining|With Chaining\nMessage only|Full stack trace preserved\nRoot cause lost|getCause() traces origin\nHard to debug|Complete context",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-5-1",
                        "title": "Creating Custom Exceptions",
                        "explanations": {
                            "english": "Custom exceptions provide domain-specific error types that communicate precise failure information in application-specific vocabulary, improving code clarity compared to generic exceptions like Exception or RuntimeException. They extend Exception for checked business rule violations that callers must handle, or RuntimeException for programming errors. Well-designed custom exceptions include multiple constructors matching Throwable: no-arg, message only, cause only, and message+cause. They should include fields for context data (like account numbers, error codes) and descriptive messages explaining what went wrong and potentially how to fix it. Naming follows the convention ending in 'Exception' (e.g., InsufficientFundsException) and clearly communicates the error condition."
                        },
                        "code": {
                            "title": "Custom Exception Implementation",
                            "language": "java",
                            "content": "// Checked exception for business rules\npublic class InsufficientFundsException extends Exception {\n    private final String accountId;\n    private final double requested;\n    private final double available;\n    \n    // Standard constructors\n    public InsufficientFundsException(String accountId, double requested, double available) {\n        super(String.format(\"Account %s: requested %.2f, available %.2f\", \n              accountId, requested, available));\n        this.accountId = accountId;\n        this.requested = requested;\n        this.available = available;\n    }\n    \n    public InsufficientFundsException(String message, Throwable cause) {\n        super(message, cause);\n        this.accountId = null;\n        this.requested = 0;\n        this.available = 0;\n    }\n    \n    // Context getters\n    public String getAccountId() { return accountId; }\n    public double getRequested() { return requested; }\n    public double getAvailable() { return available; }\n}\n\n// Usage\nthrow new InsufficientFundsException(\"ACC-123\", 1000.0, 500.0);"
                        },
                        "codeExplanations": {
                            "english": "InsufficientFundsException extends Exception (checked) indicating this is a condition the caller should expect and handle. It stores context (accountId, amounts) as fields for programmatic access while providing a formatted message for human readability. The multiple constructor pattern supports different creation scenarios: with context data or with wrapping/chaining."
                        },
                        "keyPoints": [
                            "Extend Exception (checked) or RuntimeException (unchecked)",
                            "Provide four standard constructors: (), (msg), (cause), (msg, cause)",
                            "Include domain-specific data fields for context",
                            "Follow naming convention: [Condition]Exception"
                        ],
                        "extras": {
                            "flowDiagram": "CustomException extends Exception\n    ├── Fields (context data)\n    ├── Constructors (4 standard forms)\n    ├── Getters for context\n    └── Descriptive message formatting",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-5-2",
                        "title": "Context-aware Exceptions",
                        "explanations": {
                            "english": "Context-aware exceptions embed relevant application state within the exception object, enabling sophisticated error handling and logging without requiring the catch block to have access to the full scope where the error occurred. This includes identifiers (userId, orderId, transaction references), attempted values (invalid input), system states (current queue depth), and environmental information (server node, timestamp). By encapsulating context, exceptions support automated monitoring and alerting systems that can parse error details, while allowing human operators to diagnose issues from logs without reproducing the scenario. Context fields should be final, set via constructors, and exposed through getter methods for immutable data transfer."
                        },
                        "code": {
                            "title": "Rich Context Exception",
                            "language": "java",
                            "content": "public class PaymentProcessingException extends RuntimeException {\n    private final String transactionId;\n    private final String merchantId;\n    private final BigDecimal amount;\n    private final PaymentMethod method;\n    private final Instant timestamp;\n    \n    public PaymentProcessingException(String txId, String merchantId, \n                                     BigDecimal amount, PaymentMethod method,\n                                     String message, Throwable cause) {\n        super(String.format(\"%s [TX:%s, Merchant:%s]\", message, txId, merchantId), cause);\n        this.transactionId = txId;\n        this.merchantId = merchantId;\n        this.amount = amount;\n        this.method = method;\n        this.timestamp = Instant.now();\n    }\n    \n    // Structured logging support\n    public Map<String, String> toContextMap() {\n        Map<String, String> ctx = new HashMap<>();\n        ctx.put(\"transactionId\", transactionId);\n        ctx.put(\"merchantId\", merchantId);\n        ctx.put(\"amount\", amount.toString());\n        ctx.put(\"method\", method.name());\n        ctx.put(\"timestamp\", timestamp.toString());\n        return ctx;\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "This exception captures rich context including identifiers, financial amounts, payment method, and automatic timestamping. The toContextMap() method facilitates structured logging integration (e.g., SLF4J MDC or ELK stack) allowing monitoring systems to index and query error context without parsing string messages."
                        },
                        "keyPoints": [
                            "Embed identifiers, values, and state relevant to the error",
                            "Support both human-readable messages and programmatic data access",
                            "Include timestamps and environmental details automatically",
                            "Provide structured export methods (toMap, toJSON) for logging systems"
                        ],
                        "extras": {
                            "flowDiagram": "Error occurs in context:\nTransactionID: TX123\nUserID: U456\nAmount: $500\n    ↓\nException captures all fields\n    ↓\nHandler logs structured data:\n{txId: TX123, userId: U456, amount: 500}",
                            "comparisonTable": "Context Type|Examples|Usage\nIdentifiers|OrderID, UserID, SessionID|Trace specific entity\nValues|Input amount, requested size|See attempted operation\nEnvironment|Server, Region, Version|Infrastructure debugging\nTemporal|Timestamp, Duration|Timing analysis",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-5-3",
                        "title": "Internationalization-ready Messages",
                        "explanations": {
                            "english": "Internationalization-ready exception messages separate error codes from display text, enabling localization of error messages for different languages and locales. Rather than hardcoding English messages, exceptions carry message keys (e.g., 'error.insufficient.funds') and placeholder parameters that map to localized ResourceBundle properties files. This allows the presentation layer (UI or API response) to convert technical exceptions into user-friendly, culturally appropriate messages using MessageFormat. The exception should store the message key and parameters as fields, providing a getLocalizedMessage(Locale) method or relying on the global exception handler to perform the lookup. This approach supports multi-language applications while keeping exception classes independent of presentation concerns."
                        },
                        "code": {
                            "title": "I18n Exception Pattern",
                            "language": "java",
                            "content": "public class LocalizedException extends RuntimeException {\n    private final String messageKey;\n    private final Object[] params;\n    \n    public LocalizedException(String key, Object... params) {\n        super(key); // Store key as message for default\n        this.messageKey = key;\n        this.params = params;\n    }\n    \n    public String getLocalizedMessage(Locale locale) {\n        ResourceBundle bundle = ResourceBundle.getBundle(\"errors\", locale);\n        String pattern = bundle.getString(messageKey);\n        return MessageFormat.format(pattern, params);\n    }\n}\n\n// Usage\nthrow new LocalizedException(\"error.insufficient.funds\", accountId, requested);\n\n// ResourceBundle: errors_en.properties\n// error.insufficient.funds=Account {0} has insufficient funds for amount {1}\n\n// ResourceBundle: errors_fr.properties  \n// error.insufficient.funds=Compte {0} : fonds insuffisants pour {1}"
                        },
                        "codeExplanations": {
                            "english": "LocalizedException stores a message key and parameters rather than a hardcoded string. The getLocalizedMessage method looks up the key in a ResourceBundle specific to the requested Locale, then formats the message with the stored parameters. This allows exceptions to be thrown deep in business logic while the UI layer localizes them for the user's language."
                        },
                        "keyPoints": [
                            "Store message keys and parameters, not hardcoded text",
                            "Use ResourceBundle for locale-specific message templates",
                            "Presentation layer performs localization, not exception throwing code",
                            "Supports multiple languages without changing exception throwing code"
                        ],
                        "extras": {
                            "flowDiagram": "Exception Thrown (key: \"error.funds\", params: [123, 500])\n    ↓\nGlobal Handler catches\n    ↓\nLookup in ResourceBundle (locale: fr_FR)\n    ↓\nFormat: \"Compte 123 : fonds insuffisants pour 500\"\n    ↓\nReturn localized response",
                            "comparisonTable": "Approach|Pros|Cons\nHardcoded English|Simple|Not localizable\nLocalized in exception|Tight coupling|Poor separation\nKey + ResourceBundle|Clean separation|Requires lookup step",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-6-1",
                        "title": "AutoCloseable Interface",
                        "explanations": {
                            "english": "The AutoCloseable interface enables resources to be closed automatically when exiting a try-with-resources block, eliminating the verbose and error-prone finally block boilerplate for resource management. Classes implement close() method to release resources (files, connections, locks) and declare any checked exceptions (typically IOException or generic Exception) they might throw during cleanup. Closeable extends AutoCloseable specifically for IO resources, restricting exceptions to IOException. Resources are declared in the try statement, initialized immediately, and closed in reverse order of opening (LIFO) when the block exits. This pattern ensures resources are closed even if exceptions occur, preventing resource leaks with minimal code."
                        },
                        "code": {
                            "title": "Implementing AutoCloseable",
                            "language": "java",
                            "content": "public class DatabaseConnection implements AutoCloseable {\n    private boolean closed = false;\n    \n    public void query(String sql) {\n        if (closed) throw new IllegalStateException(\"Connection closed\");\n        // Execute query\n    }\n    \n    @Override\n    public void close() throws SQLException {\n        if (!closed) {\n            System.out.println(\"Closing connection\");\n            closed = true;\n            // Actual cleanup\n        }\n    }\n}\n\n// Usage with try-with-resources\ntry (DatabaseConnection conn = new DatabaseConnection()) {\n    conn.query(\"SELECT * FROM users\");\n} // close() called automatically here"
                        },
                        "codeExplanations": {
                            "english": "DatabaseConnection implements AutoCloseable with a close() method that performs cleanup and tracks state to prevent double-close. The try-with-resources block automatically calls close() when exiting, even if query() throws an exception. This eliminates the need for manual finally blocks while guaranteeing resources are released."
                        },
                        "keyPoints": [
                            "Implement close() method for cleanup logic",
                            "Declare throws Exception (or specific) to allow checked exceptions during close",
                            "Closeable subinterface for IO resources (throws IOException only)",
                            "Resources closed automatically in reverse order of opening"
                        ],
                        "extras": {
                            "flowDiagram": "try (Resource1; Resource2) {\n    // Use resources\n} \nExit → Close Resource2 → Close Resource1 (reverse order)",
                            "comparisonTable": "",
                            "examples": [
                                "DatabaseConnection",
                                "FileLock",
                                "ManagedContext"
                            ]
                        }
                    },
                    {
                        "id": "s4-6-2",
                        "title": "Resource Management",
                        "explanations": {
                            "english": "Try-with-resources, introduced in Java 7, manages resource lifecycles by automatically closing resources declared in the try statement when the block exits. Multiple resources can be declared separated by semicolons, and they are closed in reverse order of opening. Resources must implement AutoCloseable. Variables are effectively final within the try block (cannot be reassigned). This construct eliminates the boilerplate and error-prone nature of manual try-catch-finally blocks, particularly ensuring resources are closed even if exceptions occur during initialization or use. If both the try block and close() throw exceptions, the close exception is added as suppressed to the try block exception, preserving all error information."
                        },
                        "code": {
                            "title": "Try-with-resources Patterns",
                            "language": "java",
                            "content": "// Single resource\ntry (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) {\n    return br.readLine();\n}\n\n// Multiple resources (closed in reverse order: writer before reader)\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"in.txt\"));\n     BufferedWriter writer = new BufferedWriter(new FileWriter(\"out.txt\"))) {\n    writer.write(reader.readLine());\n}\n\n// With catch and finally (optional)\ntry (Connection conn = dataSource.getConnection();\n     PreparedStatement ps = conn.prepareStatement(sql)) {\n    ps.executeUpdate();\n} catch (SQLException e) {\n    logger.error(\"Update failed\", e);\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows the basic pattern: resource declared in try parentheses is auto-closed. The second shows multiple resources separated by semicolons; writer closes before reader (reverse order). The third shows that catch and finally blocks can still be used with try-with-resources for error handling and additional cleanup not covered by AutoCloseable."
                        },
                        "keyPoints": [
                            "Resource declared in try parentheses: try (Resource r = ...)",
                            "Resource closed automatically when block exits (success or exception)",
                            "Multiple resources separated by semicolons, closed reverse order",
                            "Variables effectively final; cannot reassign in try block"
                        ],
                        "extras": {
                            "flowDiagram": "try (Resource r = new Resource()) {\n    r.use()\n} catch (Exception e) {\n    // Exception handling\n}\n\nExecution flow:\nCreate Resource → Try Block → If OK: Close Resource\n                    ↓ Exception\n              Catch Block → Close Resource (before catch executes)",
                            "comparisonTable": "Approach|Lines|Error Handling|Resource Guarantee\nManual try-finally|15+|Complex|Risk of leak\nTry-with-resources|5|Clean|Guaranteed close",
                            "examples": []
                        }
                    },
                    {
                        "id": "s4-6-3",
                        "title": "Best Practices",
                        "explanations": {
                            "english": "Best practices for exception handling include using try-with-resources for all AutoCloseable resources to ensure reliable cleanup without boilerplate. Specific exceptions should be caught before general ones to avoid unreachable code. Exceptions should not be used for control flow; use conditional statements instead. Always preserve the original exception when wrapping (chaining) to maintain debugging information. Avoid empty catch blocks that swallow errors; at minimum, log the exception. For checked exceptions, consider whether the caller can realistically recover; if not, use unchecked exceptions. Document exceptions with @throws in Javadoc. Validation should prevent exceptions where possible (guard clauses). Finally blocks should not throw exceptions to avoid masking primary errors."
                        },
                        "code": {
                            "title": "Exception Best Practices",
                            "language": "java",
                            "content": "// DO: Use try-with-resources\ntry (InputStream is = new FileInputStream(file)) {\n    process(is);\n}\n\n// DON'T: Empty catch\n} catch (IOException e) {\n    // Silent failure!\n}\n\n// DO: At least log\n} catch (IOException e) {\n    logger.error(\"Failed to process file\", e);\n    throw new ProcessingException(e);\n}\n\n// DON'T: Use exceptions for control flow\ntry {\n    return stack.pop();\n} catch (EmptyStackException e) {\n    return null; // Bad!\n}\n\n// DO: Check condition\nif (stack.isEmpty()) return null;\nreturn stack.pop();"
                        },
                        "codeExplanations": {
                            "english": "The first pair shows proper resource handling with try-with-resources versus empty catch that hides failures. The second pair demonstrates anti-pattern: using EmptyStackException for flow control versus proper isEmpty() checking. Exceptions should be exceptional, not expected control paths."
                        },
                        "keyPoints": [
                            "Always use try-with-resources for AutoCloseable resources",
                            "Catch specific exceptions before general; never swallow exceptions",
                            "Don't use exceptions for control flow; validate instead",
                            "Preserve causes when wrapping; document with @throws"
                        ],
                        "extras": {
                            "flowDiagram": "Check Preconditions → Throw IllegalArgumentException if invalid\n    ↓ Valid\nTry Operation → Catch Specific Exceptions → Log and Wrap if needed\n    ↓ Success\nReturn Result",
                            "comparisonTable": "Bad Practice|Good Practice\nEmpty catch|Log and rethrow\nCatch Exception|Catch specific types\nUse for flow control|Use conditionals\nThrow generic Exception|Throw specific business exception\nLose stack trace|Chain with cause|examples"
                        }
                    }
                ]
            },
            {
                "id": "section-5",
                "title": "Multithreading & Java I/O",
                "topics": [
                    {
                        "id": "s5-1-1",
                        "title": "Thread Creation Approaches",
                        "explanations": {
                            "english": "Java provides two primary approaches for creating threads: extending the Thread class or implementing the Runnable interface. Extending Thread requires overriding the run() method, but limits flexibility since Java doesn't support multiple inheritance. Implementing Runnable is preferred as it allows the class to extend other classes while still being executable by a Thread. A third approach uses anonymous classes or lambdas (Java 8+) to provide concise inline implementations of Runnable. The Thread class itself implements Runnable, and when constructed with a Runnable target, it executes the target's run() method instead of its own. Understanding these approaches is fundamental to concurrent programming."
                        },
                        "code": {
                            "title": "Thread Creation Patterns",
                            "language": "java",
                            "content": "// Approach 1: Extend Thread class\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Running in extended thread: \" + getName());\n    }\n}\n\n// Approach 2: Implement Runnable (preferred)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Running in runnable: \" + Thread.currentThread().getName());\n    }\n}\n\n// Usage\nThread t1 = new MyThread();\nThread t2 = new Thread(new MyRunnable());\n\n// Approach 3: Lambda expression (Java 8+)\nThread t3 = new Thread(() -> {\n    System.out.println(\"Running in lambda thread\");\n});\n\n// Approach 4: Anonymous class\nThread t4 = new Thread(new Runnable() {\n    public void run() {\n        System.out.println(\"Anonymous runnable\");\n    }\n});\n\nt1.start();\nt2.start();"
                        },
                        "codeExplanations": {
                            "english": "The examples show four ways to define thread logic. MyThread extends Thread directly but cannot extend other classes. MyRunnable implements the interface, allowing it to extend other classes if needed. The lambda approach provides the most concise syntax for simple thread bodies. Anonymous classes offer a middle ground between verbosity and flexibility. All approaches result in Thread objects that must call start() (not run()) to begin concurrent execution."
                        },
                        "keyPoints": [
                            "Extend Thread: Simple but limits inheritance; override run()",
                            "Implement Runnable: Flexible, preferred approach; allows class to extend other classes",
                            "Lambda expressions provide concise syntax for Runnable implementations",
                            "Call start() to begin execution; calling run() executes synchronously"
                        ],
                        "extras": {
                            "flowDiagram": "main() → new Thread() → thread.start() → Thread Scheduler → run() executes in new thread",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-1-2",
                        "title": "Extending Thread vs Implementing Runnable",
                        "explanations": {
                            "english": "Choosing between extending Thread and implementing Runnable depends on architectural requirements. Extending Thread couples the task logic with thread management, violating the separation of concerns principle. Since Java allows only single inheritance, extending Thread prevents the class from extending any other class. Implementing Runnable separates the task from the execution mechanism, allowing the same Runnable to be submitted to different thread pools or executors. It also enables composition over inheritance, where a class can both implement Runnable and extend a domain-specific superclass. Runnable represents a task that can be executed; Thread represents the execution mechanism. Modern concurrent programming favors Runnable/Callable with ExecutorServices over direct Thread management."
                        },
                        "code": {
                            "title": "Architectural Comparison",
                            "language": "java",
                            "content": "// Problem with extending Thread: Cannot extend other classes\nclass ReportGenerator extends Thread { // Stuck here\n    public void run() { /* ... */ }\n}\n\n// Solution with Runnable: Can extend business class\nclass ReportTask extends BusinessTask implements Runnable {\n    private final String reportId;\n    \n    public ReportTask(String id) {\n        this.reportId = id;\n    }\n    \n    @Override\n    public void run() {\n        generateReport(reportId);\n    }\n    \n    private void generateReport(String id) {\n        // Business logic\n    }\n}\n\n// Reusability with Executors\nExecutorService executor = Executors.newFixedThreadPool(4);\nexecutor.submit(new ReportTask(\"RPT-001\"));\nexecutor.submit(new ReportTask(\"RPT-002\"));"
                        },
                        "codeExplanations": {
                            "english": "ReportGenerator extending Thread cannot also extend BusinessTask. ReportTask implements Runnable while extending BusinessTask, demonstrating composition. The same Runnable implementation can be submitted multiple times to a thread pool, showing how Runnable separates task definition from execution management, enabling reuse across different execution contexts."
                        },
                        "keyPoints": [
                            "Runnable allows inheritance from other classes; Thread does not",
                            "Runnable separates task logic from thread management",
                            "Same Runnable instance can be reused across multiple threads",
                            "Executor framework works with Runnable, not Thread subclasses"
                        ],
                        "extras": {
                            "flowDiagram": "Runnable (Task Logic) → Thread/Executor (Execution Mechanism)",
                            "comparisonTable": "Aspect|Extend Thread|Implement Runnable\nInheritance|Blocked|Available\nSeparation|Task + Thread coupled|Task separate from execution\nReuse|One Thread per task|Submit to multiple executors\nTesting|Requires thread|Can test run() directly",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-1-3",
                        "title": "Daemon Threads",
                        "explanations": {
                            "english": "Daemon threads are background threads that provide supporting services to user threads and do not prevent the JVM from exiting when all user threads finish. When only daemon threads remain, the JVM terminates immediately, regardless of daemon thread state. Daemon threads are typically used for housekeeping tasks: garbage collection (GC is a daemon thread), memory monitoring, logging, or status monitoring. To create a daemon thread, call setDaemon(true) before starting the thread; attempting to set daemon status after start throws IllegalThreadStateException. Daemon threads should not perform I/O operations or hold critical resources, as they may be terminated abruptly when the JVM exits. They run at the same priority as user threads but without the guarantee of completion."
                        },
                        "code": {
                            "title": "Daemon Thread Usage",
                            "language": "java",
                            "content": "public class DaemonExample {\n    public static void main(String[] args) {\n        Thread daemon = new Thread(() -> {\n            while (true) {\n                System.out.println(\"Daemon monitoring...\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n        });\n        \n        // Must set before start\n        daemon.setDaemon(true);\n        daemon.start();\n        \n        // Main thread (user thread) ends immediately\n        System.out.println(\"Main thread ending\");\n        // JVM exits here even though daemon is still running\n    }\n}\n\n// Common pattern: Monitoring thread\nThread monitor = new Thread(() -> {\n    while (!Thread.currentThread().isInterrupted()) {\n        logMemoryUsage();\n        sleep(5000);\n    }\n});\nmonitor.setDaemon(true);\nmonitor.start();"
                        },
                        "codeExplanations": {
                            "english": "The daemon thread runs an infinite loop printing messages. Once the main thread (a user thread) completes, the JVM terminates even though the daemon thread is still running and would continue indefinitely. This demonstrates that daemon threads do not block JVM shutdown. The monitoring pattern shows common usage for background tasks that should not prevent application exit."
                        },
                        "keyPoints": [
                            "Daemon threads do not prevent JVM exit when user threads complete",
                            "Set setDaemon(true) before calling start()",
                            "Used for background tasks: monitoring, logging, scheduling",
                            "JVM terminates abruptly when only daemons remain; do not use for critical cleanup"
                        ],
                        "extras": {
                            "flowDiagram": "User Thread 1 (Main) ────┐\nUser Thread 2 ───────────┼── All user threads finish → JVM exits immediately\nDaemon Thread 1 (GC) ────┤    (killing daemon threads)\nDaemon Thread 2 (Log) ───┘",
                            "comparisonTable": "Property|User Thread|Daemon Thread\nJVM Exit|Blocks|Does not block\nTypical Use|Core application work|Background services\nPriority|Same|Same (by default)\nCleanup|Graceful|May be abrupt",
                            "examples": [
                                "Garbage Collector",
                                "Finalizer thread",
                                "Monitoring threads"
                            ]
                        }
                    },
                    {
                        "id": "s5-2-1",
                        "title": "Thread Lifecycle States",
                        "explanations": {
                            "english": "The Java Thread lifecycle consists of six states defined in Thread.State enum: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, and TERMINATED. A thread begins in NEW state after creation but before start() is called. Calling start() moves it to RUNNABLE, where it may be executing or waiting for CPU time from the scheduler. BLOCKED occurs when a thread attempts to acquire a monitor lock currently held by another thread (synchronized blocks). WAITING occurs when a thread waits indefinitely for another thread to perform an action (Object.wait(), Thread.join() without timeout). TIMED_WAITING is similar but with a timeout (sleep, wait with timeout, join with timeout). TERMINATED means the thread has completed execution or exited abnormally."
                        },
                        "code": {
                            "title": "State Transitions",
                            "language": "java",
                            "content": "Thread t = new Thread(() -> {\n    try {\n        Thread.sleep(1000); // TIMED_WAITING\n        synchronized (lock) {\n            // BLOCKED if lock held, then RUNNABLE\n            lock.wait(); // WAITING\n        }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    }\n});\n\nSystem.out.println(t.getState()); // NEW\nt.start();\nSystem.out.println(t.getState()); // RUNNABLE (or TIMED_WAITING immediately)\n\n// Check blocked state\nThread blocker = new Thread(() -> {\n    synchronized (lock) {\n        sleep(5000); // Hold lock for 5 seconds\n    }\n});\nblocker.start();\nt.join(100); // Give t time to try to acquire lock\nSystem.out.println(t.getState()); // Likely BLOCKED"
                        },
                        "codeExplanations": {
                            "english": "The code demonstrates state transitions: NEW before start(), RUNNABLE when executing, TIMED_WAITING during sleep(), BLOCKED when waiting to enter synchronized block held by another thread, and WAITING when calling object.wait(). The getState() method inspects current state for debugging. Understanding these states is crucial for diagnosing thread contention and deadlocks."
                        },
                        "keyPoints": [
                            "NEW: Created, not yet started",
                            "RUNNABLE: Executing or ready to execute (waiting for CPU)",
                            "BLOCKED: Waiting to acquire monitor lock",
                            "WAITING: Waiting indefinitely for notification or other thread",
                            "TIMED_WAITING: Waiting with specified timeout",
                            "TERMINATED: Execution completed"
                        ],
                        "extras": {
                            "flowDiagram": "NEW → start() → RUNNABLE ←→ BLOCKED (waiting for lock)\n                ↓\n          TIMED_WAITING (sleep, timed wait)\n                ↓\n            TERMINATED (run completes)",
                            "comparisonTable": "State|Trigger|Exit Condition\nNEW|Thread created|start() called\nRUNNABLE|start() called|Waiting for lock, I/O, or termination\nBLOCKED|Enter synchronized|Lock acquired\nWAITING|wait(), join()|notify(), interrupt(), target completes\nTIMED_WAITING|sleep(t), wait(t)|Time expires or notification\nTERMINATED|Run completes|N/A",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-3-1",
                        "title": "Synchronized Keyword",
                        "explanations": {
                            "english": "The synchronized keyword provides Java's built-in intrinsic locking mechanism for thread-safe access to shared mutable state. It can be applied to methods (instance or static) or as a block on a specific object. For instance methods, it locks on the object instance (this); for static methods, it locks on the Class object. Synchronized blocks allow finer-grained locking on arbitrary objects, reducing lock scope compared to entire methods. Only one thread at a time can execute code protected by a given monitor lock, ensuring mutual exclusion. Synchronized also guarantees visibility: changes made by one thread before releasing a lock are visible to the next thread acquiring that lock, establishing happens-before relationships."
                        },
                        "code": {
                            "title": "Synchronization Patterns",
                            "language": "java",
                            "content": "public class Counter {\n    private int count = 0;\n    private final Object lock = new Object();\n    \n    // Synchronized instance method (locks on 'this')\n    public synchronized void increment() {\n        count++;\n    }\n    \n    // Equivalent synchronized block\n    public void incrementBlock() {\n        synchronized (this) {\n            count++;\n        }\n    }\n    \n    // Different lock object for finer control\n    public void add(int value) {\n        synchronized (lock) {\n            count += value;\n        }\n    }\n    \n    // Static synchronized (locks on Counter.class)\n    public static synchronized void staticMethod() {\n        // Class-level lock\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The Counter class demonstrates three synchronization approaches: synchronized method locks the instance, synchronized block explicitly locks this or another object, and using a private final lock object allows excluding some methods from locking while protecting others. The static synchronized method locks the Class object, separate from instance locks."
                        },
                        "keyPoints": [
                            "Instance methods lock on 'this'; static methods lock on Class object",
                            "Synchronized blocks allow locking on any object with finer granularity",
                            "Only one thread can hold the lock at a time; others block",
                            "Guarantees both mutual exclusion and visibility of changes"
                        ],
                        "extras": {
                            "flowDiagram": "Thread A → acquire lock → execute synchronized code → release lock\nThread B → request lock (blocked) → acquire after A → execute",
                            "comparisonTable": "Approach|Scope|Flexibility\nsynchronized method|Entire method|Simple, coarse\nsynchronized(this)|Same as method|Explicit\nsynchronized(obj)|Specific block|Fine-grained, flexible",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-3-2",
                        "title": "Intrinsic Locks",
                        "explanations": {
                            "english": "Intrinsic locks (monitor locks or mutexes) are built into every Java object, providing the foundation for synchronized blocks and methods. Each object has an associated monitor that threads can acquire and release; the lock is acquired when entering a synchronized block and automatically released when exiting (including via exceptions). Intrinsic locks are reentrant: a thread holding the lock can acquire it again without blocking, with each acquisition requiring a matching release. They are exclusive (mutual exclusion) - only one thread can hold the lock at a time. While convenient, intrinsic locks have limitations: they cannot be interrupted, cannot timeout, and do not support multiple wait/notify condition variables per lock, limitations addressed by the java.util.concurrent.locks package."
                        },
                        "code": {
                            "title": "Monitor Lock Behavior",
                            "language": "java",
                            "content": "public class IntrinsicLockDemo {\n    public synchronized void methodA() {\n        System.out.println(\"In method A\");\n        methodB(); // Reentrant: same thread can acquire again\n    }\n    \n    public synchronized void methodB() {\n        System.out.println(\"In method B\");\n        // Lock held count: 2 (A + B)\n    }\n    // Exit B: count 1, Exit A: count 0, lock released\n    \n    // Every object has intrinsic lock\n    private final Object monitor = new Object();\n    \n    public void manualLocking() {\n        synchronized (monitor) {\n            // Lock acquired\n            try {\n                doWork();\n            } finally {\n                // Lock released automatically even if exception\n            }\n        }\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "methodA calling methodB demonstrates reentrancy: the same thread can enter synchronized methodB while already holding the lock from synchronized methodA. The JVM maintains a hold count, releasing the lock only when the outermost synchronized block exits. The manualLocking example shows that even private objects have intrinsic locks usable for synchronization."
                        },
                        "keyPoints": [
                            "Every Java object has an intrinsic lock (monitor)",
                            "Lock acquired on synchronized entry, released on exit (including exceptions)",
                            "Reentrant: same thread can acquire lock multiple times",
                            "Exclusive: only one thread holds lock at a time"
                        ],
                        "extras": {
                            "flowDiagram": "Object Monitor:\n[Unlocked] ←── Thread A acquires ──→ [Locked by A]\n   ↑                                     │\n   └────── Thread B blocks ──────────────┘\n        (enters wait set)",
                            "comparisonTable": "Feature|Intrinsic Lock|ReentrantLock\nAcquisition|synchronized keyword|lock() method\nRelease|Automatic|Manual (finally)\nInterruptible|No|Yes (lockInterruptibly)\nTimeout|No|Yes (tryLock(timeout))\nCondition Variables|One per object|Multiple",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-3-3",
                        "title": "Reentrancy",
                        "explanations": {
                            "english": "Reentrancy is the property of locks that allows a thread to acquire the same lock multiple times without deadlocking itself. If a thread holds a lock and attempts to acquire it again (through recursive method calls or calling other synchronized methods), the request succeeds and the lock hold count increments. The thread must release the lock the same number of times it acquired it before the lock becomes available to other threads. Without reentrancy, synchronized methods calling other synchronized methods on the same object would deadlock immediately. Reentrancy is implemented by associating an owner thread and hold count with each lock; acquisition checks identity, just count if same thread, blocks if different."
                        },
                        "code": {
                            "title": "Reentrant Locking",
                            "language": "java",
                            "content": "public class ReentrantExample {\n    public synchronized void outer() {\n        System.out.println(\"Outer acquired lock\");\n        inner(); // Would deadlock if not reentrant\n        System.out.println(\"Outer releasing\");\n    }\n    \n    public synchronized void inner() {\n        System.out.println(\"Inner acquired lock (again)\");\n        deepest();\n    }\n    \n    public synchronized void deepest() {\n        System.out.println(\"Deepest level - hold count: 3\");\n    }\n    // Lock released 3 times as stack unwinds\n    \n    public static void main(String[] args) {\n        new ReentrantExample().outer();\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "outer(), inner(), and deepest() are all synchronized. When outer() calls inner(), the thread already holds the lock; because Java locks are reentrant, inner() succeeds and increments the hold count to 2. deepest() makes it 3. As methods return, the count decrements. Finally at 0, the lock is released. Without reentrancy, the call to inner() would block forever waiting for the lock already held by outer()."
                        },
                        "keyPoints": [
                            "Thread can acquire same lock multiple times without blocking",
                            "Hold count tracks acquisition depth",
                            "Lock fully released only when hold count reaches zero",
                            "Essential for synchronized methods calling other synchronized methods"
                        ],
                        "extras": {
                            "flowDiagram": "Thread A acquires lock (count: 1)\n    ↓\nEnter synchronized method (count: 2)\n    ↓\nEnter synchronized block (count: 3)\n    ↓\nExit block (count: 2)\n    ↓\nExit method (count: 1)\n    ↓\nExit outer (count: 0) → Lock released",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-3-4",
                        "title": "Happens-before Relationship",
                        "explanations": {
                            "english": "The happens-before relationship is a fundamental guarantee of the Java Memory Model defining when memory writes by one thread are guaranteed to be visible to another thread. Actions within a single thread happen in program order. Between threads, synchronization establishes happens-before: unlocking a monitor (exiting synchronized) happens-before any subsequent lock of the same monitor (entering synchronized) by another thread. Similarly, volatile writes happen-before subsequent volatile reads of the same variable. This ensures that memory writes made before releasing a lock or writing a volatile variable are visible to threads acquiring that lock or reading that variable. Without happens-before guarantees, threads might see stale cached values due to compiler optimizations and CPU caching."
                        },
                        "code": {
                            "title": "Happens-before Guarantees",
                            "language": "java",
                            "content": "// Visibility through synchronization\nclass SynchronizedVisibility {\n    private int sharedValue = 0;\n    \n    public synchronized void writer() {\n        sharedValue = 42; // Write happens-before unlock\n    }\n    \n    public synchronized int reader() {\n        // Lock acquire happens-after previous unlock\n        return sharedValue; // Guaranteed to see 42 if writer completed\n    }\n}\n\n// Visibility through volatile\nclass VolatileVisibility {\n    private volatile int flag = 0;\n    private int data = 0;\n    \n    public void writer() {\n        data = 42;          // (1)\n        flag = 1;           // (2) volatile write happens-before\n    }\n    \n    public void reader() {\n        if (flag == 1) {    // (3) volatile read happens-after (2)\n            // Guaranteed to see data == 42 (1 happens-before 2, 2 happens-before 3)\n            System.out.println(data);\n        }\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The first example shows that writes in synchronized writer() are visible to reader() because unlocking in writer happens-before locking in reader. The volatile example demonstrates that the write to data (1) happens-before the volatile write to flag (2), and the volatile read of flag (3) happens-after (2), so the reader is guaranteed to see the updated data value."
                        },
                        "keyPoints": [
                            "Defines visibility guarantees across threads in Java Memory Model",
                            "Synchronized unlock happens-before subsequent lock on same monitor",
                            "Volatile write happens-before subsequent volatile read",
                            "Without happens-before, threads may see stale cached values"
                        ],
                        "extras": {
                            "flowDiagram": "Thread A:\nWrite to x → Release Lock → Volatile Write\n                ↓ happens-before\nThread B:\n           Acquire Lock → Volatile Read → Read x (sees write from A)",
                            "comparisonTable": "Mechanism|Happens-before Rule\nsynchronized|Unlock → subsequent Lock\nvolatile|Write → subsequent Read\nThread.start()|start() → run() begin\nThread.join()|Thread termination → join() return",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-4-1",
                        "title": "ReentrantLock",
                        "explanations": {
                            "english": "ReentrantLock is an explicit lock providing more flexible locking mechanisms than intrinsic synchronized locks. It offers lockInterruptibly() for responsive cancellation, tryLock() with timeout to avoid indefinite blocking, and fairness policies (fair vs non-fair) to favor longest-waiting threads. Unlike synchronized blocks, ReentrantLock requires explicit unlock() calls in finally blocks to ensure release. It also supports multiple Condition objects per lock for sophisticated wait/notify patterns. ReentrantLock provides the same reentrancy semantics as intrinsic locks (same thread can acquire multiple times) but with greater control and visibility into lock state (isLocked(), getHoldCount(), isHeldByCurrentThread())."
                        },
                        "code": {
                            "title": "ReentrantLock Usage",
                            "language": "java",
                            "content": "import java.util.concurrent.locks.ReentrantLock;\n\npublic class LockExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    private int count = 0;\n    \n    public void safeIncrement() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Must unlock in finally\n        }\n    }\n    \n    public boolean tryIncrement(long timeout) throws InterruptedException {\n        if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {\n            try {\n                count++;\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false; // Could not acquire lock in time\n    }\n    \n    public void interruptibleOperation() throws InterruptedException {\n        lock.lockInterruptibly();\n        try {\n            // Can be interrupted while waiting for lock\n            doWork();\n        } finally {\n            lock.unlock();\n        }\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "The lock is acquired with lock() and absolutely must be released in a finally block to prevent deadlocks if exceptions occur. tryLock() with timeout allows the method to give up if the lock isn't available within a time limit, preventing indefinite blocking. lockInterruptibly() allows the thread to respond to interruption while waiting to acquire the lock, unlike intrinsic locks which ignore interruption during acquisition."
                        },
                        "keyPoints": [
                            "Explicit lock/unlock calls required (unlock in finally)",
                            "tryLock() supports timeouts; lockInterruptibly() supports cancellation",
                            "Fairness policy available (fair queue vs barging allowed)",
                            "Multiple Condition objects per lock for complex wait/notify"
                        ],
                        "extras": {
                            "flowDiagram": "lock.lockInterruptibly()\n    ↓\n[Waiting for lock] ←── InterruptedException\n    ↓\n[Lock Acquired]\n    ↓\ntry { work } finally { lock.unlock() }",
                            "comparisonTable": "Feature|synchronized|ReentrantLock\nSyntax|Keyword|Explicit API\nInterruptible|No|Yes (lockInterruptibly)\nTimeout|No|Yes (tryLock)\nFairness|No|Configurable\nCondition Variables|One|Multiple\nPerformance|Similar|Similar (modern JVM)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-4-2",
                        "title": "Thread Pools",
                        "explanations": {
                            "english": "Thread pools manage a collection of reusable worker threads that execute submitted tasks, eliminating the overhead of thread creation and destruction for short-lived tasks. The java.util.concurrent package provides factory methods in Executors for common pool types: fixed thread pools (fixed size, unbounded queue), cached thread pools (dynamic sizing, no queue), single thread executors (sequential execution), and scheduled pools (timed/delayed execution). Proper sizing is crucial: pools too small create bottlenecks, too large waste resources. Thread pools should be shut down gracefully with shutdown() (waits for completion) or shutdownNow() (attempts immediate cancellation) to allow running tasks to complete and reject new submissions."
                        },
                        "code": {
                            "title": "Thread Pool Configuration",
                            "language": "java",
                            "content": "// Fixed size pool\nExecutorService fixed = Executors.newFixedThreadPool(4);\n\n// Cached pool (creates threads as needed, reuses idle ones)\nExecutorService cached = Executors.newCachedThreadPool();\n\n// Single threaded (sequential execution)\nExecutorService single = Executors.newSingleThreadExecutor();\n\n// Scheduled tasks\nScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);\nscheduled.schedule(() -> task(), 10, TimeUnit.SECONDS);\nscheduled.scheduleAtFixedRate(() -> recurring(), 0, 5, TimeUnit.SECONDS);\n\n// Proper shutdown\nfixed.shutdown(); // No new tasks, complete existing\nfixed.awaitTermination(60, TimeUnit.SECONDS);\nfixed.shutdownNow(); // Attempt to interrupt running"
                        },
                        "codeExplanations": {
                            "english": "Different pool types serve different needs: fixed for CPU-bound work with controlled concurrency, cached for many short-lived tasks, single for guaranteed ordering without synchronization. Scheduled pools handle timer-based tasks. Shutdown sequence ensures graceful degradation: first stop accepting new work, wait for completion with timeout, then force shutdown if necessary."
                        },
                        "keyPoints": [
                            "Reuse threads to avoid creation overhead",
                            "Fixed: bounded concurrency; Cached: unbounded growth; Single: sequential",
                            "Always shut down pools to prevent memory leaks",
                            "Handle RejectedExecutionException when pool saturated"
                        ],
                        "extras": {
                            "flowDiagram": "Task Submitted → Work Queue → Worker Thread (reusable)\n                ↓ Rejected (if saturated)\n         RejectedExecutionException",
                            "comparisonTable": "Pool Type|Characteristics|Use Case\nnewFixedThreadPool(n)|Fixed threads, unbounded queue|CPU-intensive work\nnewCachedThreadPool|Elastic, 60s keep-alive|Many short async tasks\nnewSingleThreadExecutor|One thread, queue|Sequential processing\nnewScheduledThreadPool(n)|Delayed/periodic execution|Timers, recurring jobs",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-4-3",
                        "title": "Executor Framework",
                        "explanations": {
                            "english": "The Executor framework decouples task submission from execution, providing a standard interface for running tasks asynchronously. The Executor interface has a single method execute(Runnable), while ExecutorService extends it with submit() returning Futures, batch execution (invokeAll/invokeAny), and lifecycle management. The framework separates task creation (what to do) from execution policy (when, where, how many threads), allowing flexible scheduling without changing task code. ThreadPoolExecutor, the standard implementation, offers core and maximum pool sizes, keep-alive times, and various work queues. The framework is the foundation for high-level concurrency utilities and is recommended over manual Thread creation for all but trivial scenarios."
                        },
                        "code": {
                            "title": "Executor Patterns",
                            "language": "java",
                            "content": "// Simple execution (fire and forget)\nExecutor executor = Executors.newSingleThreadExecutor();\nexecutor.execute(() -> System.out.println(\"Async task\"));\n\n// ExecutorService with results\nExecutorService service = Executors.newFixedThreadPool(4);\nFuture<Integer> future = service.submit(() -> calculate());\nInteger result = future.get(); // Blocks until result available\n\n// Batch processing\nList<Callable<String>> tasks = Arrays.asList(\n    () -> \"Task 1\",\n    () -> \"Task 2\"\n);\nList<Future<String>> results = service.invokeAll(tasks);\n\n// One successful result (fastest)\nString fastest = service.invokeAny(tasks);"
                        },
                        "codeExplanations": {
                            "english": "execute() is fire-and-forget with no result tracking. submit() returns a Future allowing result retrieval or cancellation. invokeAll() executes all tasks and returns when all complete; invokeAny() returns as soon as one completes successfully. This decouples task logic from concurrency management, allowing the same tasks to run on different executor configurations."
                        },
                        "keyPoints": [
                            "Separates task submission from execution mechanism",
                            "ExecutorService adds lifecycle management and result retrieval (Future)",
                            "Submit Callables for results, Runnables for fire-and-forget",
                            "Use executors instead of creating Thread objects directly"
                        ],
                        "extras": {
                            "flowDiagram": "Client → submit(Task) → Executor\n                          ↓\n                    Work Queue → Worker Threads\n                          ↓\n                    Future ← Result",
                            "comparisonTable": "Interface|Method|Returns\nExecutor|execute(Runnable)|void\nExecutorService|submit(Callable)|Future<T>\nExecutorService|invokeAll(List)|List<Future>\nExecutorService|invokeAny(List)|T (first success)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-4-4",
                        "title": "Best Practices",
                        "explanations": {
                            "english": "Concurrent programming best practices emphasize using high-level concurrency utilities over low-level synchronization. Prefer java.util.concurrent package utilities (ConcurrentHashMap, BlockingQueue, ExecutorService) over manual synchronization. Use immutable objects where possible to eliminate synchronization needs. Always access shared mutable state from synchronized blocks or atomic variables; avoid holding locks during lengthy I/O or computations to reduce contention. Document thread-safety guarantees (thread-safe, conditionally thread-safe, or thread-hostile). Use thread factories to set meaningful names for debugging. Never rely on thread priorities for correctness. Be cautious with lazy initialization; use static initializers or double-checked locking with volatile. Avoid calling alien methods (methods you don't control) while holding locks to prevent unknown locking order and deadlocks."
                        },
                        "code": {
                            "title": "Concurrency Best Practices",
                            "language": "java",
                            "content": "// Good: Use concurrent collections\nConcurrentHashMap<String, Data> cache = new ConcurrentHashMap<>();\n\n// Bad: Synchronized collections (coarse locking)\nMap<String, Data> badCache = Collections.synchronizedMap(new HashMap<>());\n\n// Good: Immutable state (no synchronization needed)\npublic class Config {\n    private final Map<String, String> settings;\n    public Config(Map<String, String> s) {\n        this.settings = Map.copyOf(s); // Defensive copy\n    }\n}\n\n// Good: Don't call alien methods while locked\npublic void notifyListeners() {\n    List<Listener> snapshot;\n    synchronized (lock) {\n        snapshot = new ArrayList<>(listeners); // Copy while locked\n    }\n    for (Listener l : snapshot) {\n        l.update(); // Call outside lock\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "ConcurrentHashMap provides better concurrency than synchronizedMap by using lock striping. Immutable Config objects require no synchronization after creation. The listener pattern demonstrates copying the list while synchronized to prevent ConcurrentModificationException, then iterating outside the lock to avoid calling unknown code (which might cause deadlocks or lengthy delays) while holding the lock."
                        },
                        "keyPoints": [
                            "Use java.util.concurrent utilities over manual synchronization",
                            "Prefer immutable objects to avoid synchronization entirely",
                            "n",
                            "Keep lock hold times short; avoid I/O while locked",
                            "Document thread-safety; use proper thread naming"
                        ],
                        "extras": {
                            "flowDiagram": "Locked Section:\n    Copy data (fast)\n    Release lock immediately\n    Process data outside lock (slow/safe)",
                            "comparisonTable": "Good Practice|Bad Practice\nConcurrentHashMap|SynchronizedHashMap\nImmutable objects|Mutable shared state\nShort critical sections|Long synchronized blocks\nCopy-then-iterate|Iterate shared collection directly",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-5-1",
                        "title": "Callable",
                        "explanations": {
                            "english": "Callable is a functional interface similar to Runnable but capable of returning a result and throwing checked exceptions. Unlike Runnable's void run() method, Callable<V> has a V call() method that returns a value and permits exceptions to propagate to the caller. It is designed for tasks that compute results or may fail with exceptions that the caller should handle. When submitted to an ExecutorService, a Callable returns a Future representing the pending result. The interface supports generics, allowing type-safe result retrieval. Callable is essential for asynchronous computation patterns where the caller needs the result of background processing or must handle exceptional completion distinctly from successful completion."
                        },
                        "code": {
                            "title": "Callable Implementation",
                            "language": "java",
                            "content": "// Callable that returns result or throws checked exception\nCallable<Integer> task = () -> {\n    Thread.sleep(1000);\n    if (System.currentTimeMillis() % 2 == 0) {\n        throw new IOException(\"Random failure\");\n    }\n    return 42;\n};\n\n// Submit to executor\nExecutorService executor = Executors.newSingleThreadExecutor();\nFuture<Integer> future = executor.submit(task);\n\ntry {\n    Integer result = future.get(); // Blocks until done\n    System.out.println(\"Result: \" + result);\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n} catch (ExecutionException e) {\n    // Wraps the exception thrown by Callable\n    Throwable cause = e.getCause();\n    System.out.println(\"Task failed: \" + cause.getMessage());\n}"
                        },
                        "codeExplanations": {
                            "english": "The lambda implements Callable<Integer>, returning an Integer or throwing IOException. When submitting to ExecutorService, the returned Future allows retrieving the result with get(), which blocks until completion. ExecutionException wraps any exception thrown during call() execution; use getCause() to retrieve the original exception. This allows checked exceptions to propagate from background threads to the main thread."
                        },
                        "keyPoints": [
                            "Similar to Runnable but returns result and throws checked exceptions",
                            "n",
                            "V call() returns generic type V",
                            "Submitted to ExecutorService to obtain Future",
                            "Exceptions wrapped in ExecutionException when retrieved via Future.get()"
                        ],
                        "extras": {
                            "flowDiagram": "Submit Callable → ExecutorService → Runs asynchronously\n    ↓ Returns Future\nFuture.get() → Blocks → Returns result OR throws ExecutionException",
                            "comparisonTable": "Interface|Method|Return|Exceptions\nRunnable|run()|void|Unchecked only\nCallable|call()|V (generic)|Checked and unchecked",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-5-2",
                        "title": "Future",
                        "explanations": {
                            "english": "Future represents the result of an asynchronous computation, providing methods to check if the computation is complete, wait for its completion, and retrieve the result. Future<V> is returned when submitting Callables to ExecutorService. Its get() method blocks until the task completes, returning the result or throwing ExecutionException if the task threw an exception. get(timeout, TimeUnit) allows limiting the wait time. isDone() checks completion status without blocking; isCancelled() indicates if cancelled. cancel(boolean mayInterruptIfRunning) attempts to abort the task, succeeding only if the task hasn't started or is interruptible. Future enables separation of task submission from result consumption, allowing parallel execution patterns where results are gathered after submitting multiple tasks."
                        },
                        "code": {
                            "title": "Future API Usage",
                            "language": "java",
                            "content": "Future<String> future = executor.submit(() -> {\n    Thread.sleep(5000);\n    return \"Complete\";\n});\n\n// Non-blocking check\nif (!future.isDone()) {\n    System.out.println(\"Still processing...\");\n}\n\n// Blocking with timeout\ntry {\n    String result = future.get(3, TimeUnit.SECONDS);\n} catch (TimeoutException e) {\n    System.out.println(\"Took too long\");\n    future.cancel(true); // Interrupt if running\n}\n\n// Blocking indefinitely\nString result = future.get(); // May throw ExecutionException"
                        },
                        "codeExplanations": {
                            "english": "The example shows checking completion status with isDone(), using timed get() to avoid indefinite blocking, and cancelling tasks that exceed time limits. cancel(true) interrupts the running thread. The untimed get() blocks until completion but may throw ExecutionException wrapping any exception from the computation, requiring handling of both the future mechanics and the underlying errors."
                        },
                        "keyPoints": [
                            "Represents pending result of asynchronous computation",
                            "get() blocks until completion; get(timeout) limits wait",
                            "isDone() checks status without blocking",
                            "cancel() attempts to abort execution"
                        ],
                        "extras": {
                            "flowDiagram": "Submit → Future object created\n    ↓\nisDone() → false → wait\n    ↓\nTask completes → isDone() true → get() returns result",
                            "comparisonTable": "Method|Behavior\nget()|Block indefinitely, return result/get exception\nget(timeout)|Block max timeout, throw TimeoutException if not done\ncancel(true)|Interrupt running task\ncancel(false)|Cancel if not started\nisDone()|Check completion (success, exception, or cancelled)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-5-3",
                        "title": "CompletableFuture",
                        "explanations": {
                            "english": "CompletableFuture, introduced in Java 8, implements Future and CompletionStage to support asynchronous, non-blocking programming with functional composition. It allows chaining operations (thenApply, thenAccept, thenCompose) that execute upon completion without blocking threads. It supports combining multiple futures (thenCombine, allOf, anyOf), exception handling (exceptionally, handle), and async execution with custom executors. Unlike Future which only blocks on get(), CompletableFuture enables reactive programming where callbacks execute automatically upon completion. It supports both synchronous (thenApply) and asynchronous (thenApplyAsync) continuation methods, allowing fine control over threading. This modern approach reduces thread blocking and resource consumption compared to traditional Future.get() blocking patterns."
                        },
                        "code": {
                            "title": "CompletableFuture Chaining",
                            "language": "java",
                            "content": "// Async pipeline\nCompletableFuture.supplyAsync(() -> fetchUser(id))\n    .thenApply(user -> user.getOrders())    // Transform\n    .thenAccept(orders -> process(orders))  // Consume\n    .exceptionally(ex -> {                  // Error handling\n        log.error(\"Failed\", ex);\n        return null;\n    });\n\n// Combining futures\nCompletableFuture<String> user = fetchUserAsync(id);\nCompletableFuture<Integer> credit = checkCreditAsync(id);\n\nuser.thenCombine(credit, (u, c) -> {\n    if (c > 1000) return u + \" (VIP)\";\n    return u;\n}).thenAccept(System.out::println);\n\n// All complete\nCompletableFuture<Void> all = CompletableFuture.allOf(future1, future2, future3);"
                        },
                        "codeExplanations": {
                            "english": "The pipeline starts with supplyAsync() for async execution, chains transformations with thenApply(), and ends with side effects via thenAccept(). exceptionally() provides error handling without breaking the chain. thenCombine() merges two independent futures once both complete. allOf() creates a future that completes when all provided futures complete, enabling coordination of parallel tasks."
                        },
                        "keyPoints": [
                            "Non-blocking async programming with functional composition",
                            "Chain operations: thenApply (transform), thenAccept (consume), thenCompose (flatten)",
                            "Combine futures: thenCombine, allOf, anyOf",
                            "Error handling via exceptionally() and handle()"
                        ],
                        "extras": {
                            "flowDiagram": "supplyAsync() → thenApply() → thenAccept()\n     ↓               ↓            ↓\n  Async          Async/Current  Async/Current\n     ↓               ↓            ↓\n  Step 1         Transform      Consume result",
                            "comparisonTable": "Method|Function\nsupplyAsync|Create from Supplier\n.thenApply|Transform result (Function)\n.thenAccept|Consume result (Consumer)\n.thenCompose|Chain async operations (flatten)\n.exceptionally|Handle error (recovery)\n.handle|Map result or error (bi-function)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-5-4",
                        "title": "Async Programming Patterns",
                        "explanations": {
                            "english": "Asynchronous programming patterns enable non-blocking concurrent execution, improving scalability by freeing threads to handle other work while waiting for I/O or computation. Common patterns include fire-and-forget (execute without waiting for result), async/await (syntactic sugar over Futures), and reactive streams (pub/sub backpressure). The callback pattern registers handlers executed upon completion, avoiding polling. The pipeline pattern chains dependent operations where each stage consumes the previous stage's output. Fan-out/fan-in distributes work across multiple threads then aggregates results. Care must be taken with exception handling in async chains and avoiding blocking operations within async callbacks. Proper use of executors and thread pools prevents resource exhaustion under load."
                        },
                        "code": {
                            "title": "Async Patterns Implementation",
                            "language": "java",
                            "content": "// Fan-out/fan-in: Parallel processing\nList<CompletableFuture<String>> futures = urls.stream()\n    .map(url -> CompletableFuture.supplyAsync(() -> download(url)))\n    .collect(Collectors.toList());\n\n// Wait for all to complete\nList<String> results = futures.stream()\n    .map(CompletableFuture::join)\n    .collect(Collectors.toList());\n\n// Retry pattern with backoff\nCompletableFuture<String> retry = attemptAsync()\n    .thenCompose(result -> {\n        if (result == null) {\n            return CompletableFuture.supplyAsync(\n                () -> attemptAsync(), \n                CompletableFuture.delayedExecutor(1, TimeUnit.SECONDS)\n            );\n        }\n        return CompletableFuture.completedFuture(result);\n    });\n\n// Timeout pattern\nCompletableFuture<String> withTimeout = future.orTimeout(5, TimeUnit.SECONDS);"
                        },
                        "codeExplanations": {
                            "english": "The fan-out/fan-in pattern creates futures for all URLs concurrently, then joins them to collect results. The retry pattern uses thenCompose to chain another attempt if the first fails, with delay. orTimeout() (Java 9+) adds automatic timeout to any future, completing exceptionally if not done in time. These patterns prevent thread blocking while managing complex async workflows."
                        },
                        "keyPoints": [
                            "Fan-out/fan-in: Parallel execution with result aggregation",
                            "Retry with backoff: Chain new attempts on failure with delays",
                            "Timeouts: Prevent indefinite waits on async operations",
                            "Avoid blocking calls (Thread.sleep, blocking I/O) in async pipelines"
                        ],
                        "extras": {
                            "flowDiagram": "Fan-out:\nInput List → [Task1] → Future1\n         → [Task2] → Future2\n         → [Task3] → Future3\n                  ↓\nFan-in: allOf() → Aggregate results",
                            "comparisonTable": "Pattern|Description|Use Case\nFire-and-forget|Execute without result|Logging, notifications\nPipeline|Chain dependent ops|Data processing\nFan-out/in|Parallel then aggregate|Batch processing\nRetry|Reattempt on failure|Network calls",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-6-1",
                        "title": "Memory Visibility",
                        "explanations": {
                            "english": "Memory visibility problems occur when one thread modifies shared data that other threads do not see promptly due to CPU caching and compiler optimizations. Without synchronization, a thread may read stale values from its local cache rather than the main memory. The volatile keyword addresses this by ensuring writes are flushed to main memory and reads bypass cache, providing visibility but not atomicity. Synchronization provides both visibility (unlock flushes cache, lock refreshes) and atomicity. Happens-before relationships guarantee that memory writes before a volatile write or unlock are visible to threads performing subsequent volatile reads or lock acquires. Understanding visibility is crucial for correct concurrent programming without data races."
                        },
                        "code": {
                            "title": "Visibility Issues and Solutions",
                            "language": "java",
                            "content": "// Problem: Visibility issue\npublic class VisibilityProblem {\n    private boolean running = true; // Not volatile\n    \n    public void stop() {\n        running = false; // May not be seen by other thread\n    }\n    \n    public void run() {\n        while (running) { // May run forever seeing cached value\n            doWork();\n        }\n    }\n}\n\n// Solution 1: volatile\nprivate volatile boolean running = true;\n\n// Solution 2: synchronized\npublic synchronized void stop() {\n    running = false;\n}\n\npublic void run() {\n    while (true) {\n        synchronized (this) {\n            if (!running) break;\n        }\n        doWork();\n    }\n}"
                        },
                        "codeExplanations": {
                            "english": "Without volatile, the running variable change in stop() might never be visible to the thread executing run() due to CPU caching, causing an infinite loop. Making it volatile ensures the write is visible immediately. Alternatively, synchronized blocks ensure visibility by flushing memory barriers on lock release/acquire."
                        },
                        "keyPoints": [
                            "Threads may cache variables locally, missing updates from others",
                            "volatile ensures visibility (flush to main memory) but not atomicity",
                            "Synchronization ensures both visibility and atomicity",
                            "Happens-before rules define when writes become visible"
                        ],
                        "extras": {
                            "flowDiagram": "Thread A: Write to sharedVar → Cached (invisible to others)\nThread B: Read sharedVar → Sees stale cached value\n\nWith volatile:\nThread A: Write → Flushes to Main Memory\nThread B: Read ← Reads from Main Memory (sees update)",
                            "comparisonTable": "Modifier|Visibility|Atomicity\nNone|No|No\nvolatile|Yes|No\nsynchronized|Yes|Yes\nAtomicInteger|Yes|Yes (single operations)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-6-2",
                        "title": "Atomicity",
                        "explanations": {
                            "english": "Atomicity ensures that operations execute as indivisible units where either all effects are visible or none are, preventing race conditions from interleaved thread execution. In Java, reads and writes to primitive variables (except long/double) are atomic, but compound operations like increment (read-modify-write) are not. Without synchronization, two threads incrementing a counter simultaneously can result in lost updates. The java.util.concurrent.atomic package provides lock-free atomic classes (AtomicInteger, AtomicLong, AtomicReference) that use Compare-And-Swap (CAS) hardware instructions for atomic updates. Synchronized blocks and ReentrantLocks also enforce atomicity by mutual exclusion. Atomicity is essential for counters, sequences, and state flags accessed by multiple threads."
                        },
                        "code": {
                            "title": "Atomic Operations",
                            "language": "java",
                            "content": "// Non-atomic compound action\npublic void unsafeIncrement() {\n    count++; // Read, modify, write - not atomic!\n}\n\n// Atomic solution 1: Synchronization\npublic synchronized void safeIncrement() {\n    count++;\n}\n\n// Atomic solution 2: Atomic classes\nprivate AtomicInteger atomicCount = new AtomicInteger(0);\n\npublic void atomicIncrement() {\n    atomicCount.incrementAndGet(); // Atomic increment\n}\n\n// CAS pattern\npublic boolean compareAndSet(int expected, int newValue) {\n    return atomicCount.compareAndSet(expected, newValue);\n}"
                        },
                        "codeExplanations": {
                            "english": "count++ is actually three operations: read current value, add one, write back. If two threads do this simultaneously, they may read the same value, increment separately, and write back the same result, losing one increment. synchronized makes the entire sequence atomic. AtomicInteger uses hardware CAS operations to achieve atomicity without locking, offering better performance under contention."
                        },
                        "keyPoints": [
                            "Compound operations (read-modify-write) are not atomic by default",
                            "Race conditions occur when threads interleave non-atomic operations",
                            "Atomic classes provide lock-free atomic operations using CAS",
                            "Synchronization enforces atomicity through mutual exclusion"
                        ],
                        "extras": {
                            "flowDiagram": "Race Condition:\nT1: Read(5)   T2: Read(5)\nT1: Add(6)    T2: Add(6)\nT1: Write(6)  T2: Write(6) ← Lost update!\n\nAtomic:\nT1: CAS(5→6) success\n      T2: CAS(5→6) fails, retries with new value(6)",
                            "comparisonTable": "Approach|Mechanism|Performance Blocking\nSynchronized|Lock|Yes\nAtomicInteger|CAS (hardware)|No (retry loop)\nvolatile|Memory barrier|N/A (not compound)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-6-3",
                        "title": "Compare-And-Swap (CAS)",
                        "explanations": {
                            "english": "Compare-And-Swap (CAS) is a hardware-level atomic instruction used by the JVM to implement lock-free algorithms and atomic classes. CAS takes three arguments: a memory location, an expected value, and a new value. It atomically checks if the location contains the expected value; if yes, updates it to the new value and returns true. If not (another thread changed it), no update occurs and it returns false. The calling code typically retries in a loop (spin) until successful. CAS is non-blocking - if the operation fails, the thread retries rather than blocking. While efficient under low contention, high contention causes many failed retries (CAS spin), potentially wasting CPU cycles. Modern CPUs optimize this with pause instructions."
                        },
                        "code": {
                            "title": "CAS Implementation Pattern",
                            "language": "java",
                            "content": "// Simulated CAS logic (AtomicInteger does this natively)\npublic class SimulatedCAS {\n    private volatile int value;\n    \n    public synchronized int compareAndSwap(int expected, int newValue) {\n        int oldValue = value;\n        if (oldValue == expected) {\n            value = newValue;\n        }\n        return oldValue;\n    }\n    \n    // Usage pattern\n    public void increment() {\n        int current;\n        do {\n            current = value; // Get expected value\n        } while (current != compareAndSwap(current, current + 1));\n        // Loop until CAS succeeds (no other thread changed value)\n    }\n}\n\n// Actual AtomicInteger usage\nAtomicInteger counter = new AtomicInteger(0);\ncounter.compareAndSet(0, 1); // If 0, set to 1"
                        },
                        "codeExplanations": {
                            "english": "The simulated CAS shows the logic: check expected, swap if match, return old value for verification. The increment method loops, reading current value, attempting CAS, and retrying if the value changed between read and CAS (indicating another thread modified it). This is lock-free but may spin. AtomicInteger wraps this hardware instruction efficiently."
                        },
                        "keyPoints": [
                            "Hardware instruction: atomically compare and update if expected value matches",
                            "Non-blocking: thread retries rather than blocks on conflict",
                            "ABA problem: value changes from A→B→A, CAS succeeds incorrectly (solved by AtomicStampedReference)",
                            "Used by atomic classes for lock-free operations"
                        ],
                        "extras": {
                            "flowDiagram": "Thread 1: Read(5) → CAS(5→6) → Success!\nThread 2: Read(5) → CAS(5→6) → Fail (now 6) → Retry with 6",
                            "comparisonTable": "Aspect|CAS|Lock\nBlocking|No|Yes\nContention|Spin/retry|Block/wait\nOverhead|Low (single instruction)|Higher (OS scheduling)\nABA Problem|Yes|No",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-6-4",
                        "title": "Atomic Classes",
                        "explanations": {
                            "english": "The java.util.concurrent.atomic package provides lock-free, thread-safe atomic variables using hardware CAS instructions. AtomicInteger, AtomicLong, and AtomicBoolean provide atomic arithmetic and logical operations (compareAndSet, getAndIncrement, addAndGet). AtomicReference provides atomic object reference updates. These classes avoid synchronization overhead while ensuring thread safety for single variable operations. They support compound operations like getAndUpdate and accumulateAndGet (Java 8+) for functional updates. For ABA problem protection (when value cycles from A→B→A), AtomicStampedReference and AtomicMarkableReference pair values with version stamps or boolean marks. These classes are foundational for high-performance concurrent algorithms and data structures."
                        },
                        "code": {
                            "title": "Atomic Class Usage",
                            "language": "java",
                            "content": "// Atomic counters\nAtomicInteger counter = new AtomicInteger(0);\nint newValue = counter.incrementAndGet(); // ++i\nint oldValue = counter.getAndIncrement(); // i++\nint sum = counter.addAndGet(5); // i += 5\n\n// Atomic reference updates\nAtomicReference<String> ref = new AtomicReference<>(\"initial\");\nref.updateAndGet(s -> s.toUpperCase());\n\n// ABA protection\nAtomicStampedReference<String> stamped = \n    new AtomicStampedReference<>(\"A\", 0); // value, stamp\n\nstamped.compareAndSet(\"A\", \"B\", 0, 1); // stamp 0 → 1\nstamped.compareAndSet(\"B\", \"A\", 1, 2); // stamp 1 → 2\n// Now CAS with old stamp 0 would fail even though value is \"A\"\n\n// LongAdder (Java 8) - better for high contention\nLongAdder adder = new LongAdder();\nadder.increment();\nlong total = adder.sum();"
                        },
                        "codeExplanations": {
                            "english": "AtomicInteger provides various atomic operations with different return semantics (pre vs post increment). updateAndGet accepts a lambda for functional updates. AtomicStampedReference prevents ABA by requiring both value and stamp to match. LongAdder (not strictly atomic but thread-safe) uses striping to reduce contention read/write overhead at the cost of higher memory usage, summing at the end."
                        },
                        "keyPoints": [
                            "Lock-free thread-safe operations on single variables",
                            "AtomicInteger/AtomicLong for arithmetic; AtomicReference for objects",
                            "AtomicStampedReference prevents ABA problem",
                            "LongAdder/LongAccumulator for high-contention counters"
                        ],
                        "extras": {
                            "flowDiagram": "Multiple Threads → AtomicInteger\n    ↓ CAS operations\nSingle atomic update, no locking",
                            "comparisonTable": "Class|Use Case\nAtomicInteger|Counters, sequences\nAtomicLong|Large counters\nAtomicReference|Object references\nAtomicStampedReference|ABA-sensitive updates\nLongAdder|High-contention counters (read occasionally)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-7-1",
                        "title": "Path & Files",
                        "explanations": {
                            "english": "Java NIO.2 (Java 7+) introduced the Path interface as a modern replacement for File, providing better representation of filesystem paths with support for symbolic links and complex operations. Path is immutable and works with the Files utility class offering comprehensive static methods for file operations (create, delete, copy, move, read, write). Paths.get() (or Path.of() in Java 11+) creates Path objects. The API supports complex path manipulations: resolve (join paths), relativize (get relative path), normalize (remove redundancies), and getParent/getFileName. Files.walk() and Files.find() provide Stream-based directory traversal. This API resolves many limitations of the legacy java.io.File class, particularly around error handling and cross-platform path separators."
                        },
                        "code": {
                            "title": "NIO.2 Path Operations",
                            "language": "java",
                            "content": "// Creating paths\nPath path = Paths.get(\"/home/user/docs\");\nPath path2 = Path.of(\"data\", \"file.txt\"); // Java 11+\n\n// Path manipulation\nPath absolute = path.toAbsolutePath();\nPath normalized = path.normalize(); // Remove . and ..\nPath resolved = path.resolve(\"subdir/file.txt\"); // Join\nPath relative = path.relativize(Paths.get(\"/home/user/other\"));\n\n// Files utility\nif (Files.exists(path)) {\n    long size = Files.size(path);\n    byte[] bytes = Files.readAllBytes(path);\n    List<String> lines = Files.readAllLines(path);\n}\n\n// Stream operations\nFiles.walk(path) // Recursive directory stream\n    .filter(p -> p.toString().endsWith(\".java\"))\n    .forEach(System.out::println);"
                        },
                        "codeExplanations": {
                            "english": "Paths.get() creates path objects using varargs to handle path components. resolve() joins paths intelligently (if argument is absolute, returns argument). relativize() computes relative path between two paths. Files utility methods provide one-liners for common operations while walk() creates a lazy stream for recursive traversal, filtering, and processing without loading entire directory trees into memory."
                        },
                        "keyPoints": [
                            "Path replaces File with immutable, robust path representation",
                            "Paths.get() or Path.of() (Java 11) for creation",
                            "Files utility class provides static methods for all file operations",
                            "Stream-based directory traversal with Files.walk() and Files.find()"
                        ],
                        "extras": {
                            "flowDiagram": "Path Creation → Path Manipulation (resolve, relativize) → Files Operations (read/write/check)",
                            "comparisonTable": "Operation|Old (java.io.File)|New (NIO.2)\nCreate path|new File(String)|Paths.get(String)\nRead lines|BufferedReader|Files.readAllLines()\nCopy file|FileInput/OutputStream|Files.copy()\nWalk directory|Recursive method|Files.walk() Stream",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-7-2",
                        "title": "File Operations",
                        "explanations": {
                            "english": "The Files class provides comprehensive static methods for file and directory operations with atomic and symbolic link support. Basic operations include createFile, createDirectory, createDirectories (creates intermediate dirs), delete, deleteIfExists, copy, and move with CopyOption flags (REPLACE_EXISTING, COPY_ATTRIBUTES, ATOMIC_MOVE). The API handles symbolic links separately with LinkOption.NOFOLLOW_LINKS. Files also provides attribute access (size, lastModifiedTime, isRegularFile, isDirectory, isSymbolicLink) and file type probing (probeContentType). For temporary files, createTempFile and createTempDirectory are available. The API throws IOException with clear error messages rather than returning boolean false like the old File class, enabling better error handling."
                        },
                        "code": {
                            "title": "Comprehensive File Operations",
                            "language": "java",
                            "content": "// Creation\nPath file = Files.createFile(path);\nPath dir = Files.createDirectories(Paths.get(\"a/b/c\"));\n\n// Copy with options\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n// Move atomically (avoids partial files on crash)\nFiles.move(source, target, \n    StandardCopyOption.ATOMIC_MOVE,\n    StandardCopyOption.REPLACE_EXISTING);\n\n// Attributes\nboolean isDir = Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);\nlong size = Files.size(path);\nFileTime time = Files.getLastModifiedTime(path);\n\n// Temporary files\nPath temp = Files.createTempFile(\"prefix\", \".tmp\");\nPath tempDir = Files.createTempDirectory(\"myApp\");"
                        },
                        "codeExplanations": {
                            "english": "createDirectories creates the full path including parents, unlike createDirectory. Copy and move accept varargs of CopyOptions to control behavior; ATOMIC_MOVE ensures the operation completes fully or not at all, preventing corrupted files during system crashes. NOFOLLOW_LINKS option prevents traversing symbolic links when checking attributes, important for security."
                        },
                        "keyPoints": [
                            "Atomic file operations with CopyOption flags",
                            "ATOMIC_MOVE prevents partial file states during crashes",
                            "createDirectories creates parent directories as needed",
                            "Better error handling with exceptions vs boolean returns"
                        ],
                        "extras": {
                            "flowDiagram": "Source File → Files.copy() → Target File\n                ↓ Options\n         REPLACE_EXISTING: Overwrite if exists\n         COPY_ATTRIBUTES: Preserve metadata\n         ATOMIC_MOVE: All-or-nothing",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-7-3",
                        "title": "WatchService",
                        "explanations": {
                            "english": "WatchService provides a mechanism for monitoring directories for changes (create, delete, modify events) without polling. Registered with a Path, it queues WatchKeys representing batches of events. The service watches for ENTRY_CREATE, ENTRY_DELETE, and ENTRY_MODIFY events. Subdirectories are not watched recursively unless explicitly registered. The API requires polling the WatchService with take() (blocking) or poll() (non-blocking) to receive WatchKeys, then polling the key for events and resetting it to receive further events. This is useful for hot-reloading configuration files, monitoring upload directories, or triggering builds when source changes. The service must be closed when monitoring ends to release native resources."
                        },
                        "code": {
                            "title": "Directory Watching",
                            "language": "java",
                            "content": "Path dir = Paths.get(\"/watch/dir\");\nWatchService watcher = FileSystems.getDefault().newWatchService();\n\n// Register for events\ndir.register(watcher, \n    StandardWatchEventKinds.ENTRY_CREATE,\n    StandardWatchEventKinds.ENTRY_DELETE,\n    StandardWatchEventKinds.ENTRY_MODIFY);\n\n// Monitor loop\nwhile (true) {\n    WatchKey key = watcher.take(); // Blocks until event\n    \n    for (WatchEvent<?> event : key.pollEvents()) {\n        WatchEvent.Kind<?> kind = event.kind();\n        Path filename = (Path) event.context();\n        System.out.println(kind + \": \" + filename);\n    }\n    \n    boolean valid = key.reset(); // Ready for more events\n    if (!valid) break; // Directory no longer accessible\n}\n\nwatcher.close();"
                        },
                        "codeExplanations": {
                            "english": "The directory is registered with the WatchService for specific event types. The infinite loop blocks on take() until events occur. pollEvents() retrieves all events accumulated since last check. The key must be reset() to continue receiving events; if reset returns false, the watch key is no longer valid (directory deleted). The watcher must be closed to release native file system monitoring resources."
                        },
                        "keyPoints": [
                            "Monitor directories for create/delete/modify events without polling",
                            "n",
                            "Register Path with WatchService for specific event kinds",
                            "Poll WatchKeys and reset them to continue receiving events",
                            "Not recursive; must register subdirectories individually",
                            "Close service to release native resources"
                        ],
                        "extras": {
                            "flowDiagram": "Register Path → WatchService\n    ↓\nFile Created → WatchKey queued\n    ↓\nwatcher.take() returns key\n    ↓\nkey.pollEvents() → Process → key.reset() → Continue",
                            "comparisonTable": "Method|Behavior\ntake()|Block until events available\npoll()|Return immediately (null if none)\npoll(timeout)|Wait max time",
                            "examples": [
                                "Configuration hot-reloading",
                                "File upload monitoring",
                                "Auto-compilation on source change"
                            ]
                        }
                    },
                    {
                        "id": "s5-7-4",
                        "title": "Blocking vs Non-blocking I/O",
                        "explanations": {
                            "english": "Blocking I/O (traditional java.io) suspends the executing thread until the operation completes, tying up thread resources during waits for disk or network. Non-blocking I/O (NIO) allows a single thread to manage multiple channels (files or sockets) using selectors that notify when channels are ready for reading/writing. NIO uses buffers and channels rather than streams. Asynchronous I/O (NIO.2 AsynchronousFileChannel, AsynchronousSocketChannel) uses callbacks or Futures where the OS notifies completion via completion ports, requiring no thread waiting during the operation. Blocking I/O is simpler and suitable for simple applications; NIO scales better for high-concurrency servers handling thousands of connections with few threads, while async I/O provides the highest throughput for I/O-bound workloads."
                        },
                        "code": {
                            "title": "I/O Model Comparison",
                            "language": "java",
                            "content": "// Blocking I/O (traditional)\ntry (BufferedReader reader = Files.newBufferedReader(path)) {\n    String line = reader.readLine(); // Thread blocked until data available\n    // Process...\n}\n\n// Non-blocking NIO (Channels)\nPath path = Paths.get(\"file.txt\");\ntry (FileChannel channel = FileChannel.open(path, StandardOpenOption.READ)) {\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n    int bytesRead = channel.read(buffer); // May return 0 if nothing available\n    // Non-blocking channel.configureBlocking(false) required\n}\n\n// Asynchronous I/O (NIO.2)\nAsynchronousFileChannel channel = AsynchronousFileChannel.open(path);\nByteBuffer buffer = ByteBuffer.allocate(1024);\n\nchannel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {\n    public void completed(Integer result, ByteBuffer attachment) {\n        // Called when read completes, no thread blocked\n    }\n    public void failed(Throwable exc, ByteBuffer attachment) {\n        // Error handling\n    }\n});"
                        },
                        "codeExplanations": {
                            "english": "Blocking I/O ties up a thread for the duration of the read. NIO with channels and buffers can operate in non-blocking mode where read returns immediately with available data or 0. Asynchronous I/O uses callbacks that the system invokes when I/O completes, requiring zero threads during the wait period - ideal for high-scale servers where thread-per-connection is impractical."
                        },
                        "keyPoints": [
                            "Blocking: Thread waits until I/O completes; simple but resource-intensive",
                            "Non-blocking (NIO): Thread polls or uses selector; multiplex channels",
                            "Asynchronous (NIO.2): OS notifies completion via callbacks/Futures",
                            "NIO better for high concurrency with few threads; blocking simpler for low concurrency"
                        ],
                        "extras": {
                            "flowDiagram": "Blocking: Thread → Read Request → [Blocked] → Data Ready → Continue\n\nNon-blocking: Thread → Read → Return immediately (0 or data) → Check again/Selector\n\nAsync: Thread → Read Request → Immediate return\n         ↓\n      Kernel handles I/O\n         ↓\n      Callback executes (any thread)",
                            "comparisonTable": "Model|Threads|Throughput|Complexity\nBlocking|Many (per connection)|Low|Low\nNIO Selector|Few (multiplex)|High|Medium\nAsync/AIO|Few|Very High|High",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-8-1",
                        "title": "Byte Streams",
                        "explanations": {
                            "english": "Byte streams (InputStream/OutputStream) handle raw binary data as sequences of 8-bit bytes, suitable for images, audio, executable files, and network protocols where character encoding is not relevant. InputStream is the abstract superclass for reading bytes (read(), read(byte[])), while OutputStream handles writing (write(), write(byte[])). FileInputStream and FileOutputStream provide file access; BufferedInputStream/BufferedOutputStream add buffering for performance; DataInputStream/DataOutputStream support primitive type serialization. Byte streams are low-level and versatile but require manual handling of byte arrays. Unlike character streams, they do not involve encoding/decoding, preserving exact byte values. Always close streams in finally or use try-with-resources to prevent resource leaks."
                        },
                        "code": {
                            "title": "Byte Stream Operations",
                            "language": "java",
                            "content": "// Basic file copy with buffering\ntry (InputStream in = new FileInputStream(\"source.jpg\");\n     BufferedInputStream bin = new BufferedInputStream(in);\n     OutputStream out = new FileOutputStream(\"dest.jpg\");\n     BufferedOutputStream bout = new BufferedOutputStream(out)) {\n    \n    byte[] buffer = new byte[8192];\n    int bytesRead;\n    while ((bytesRead = bin.read(buffer)) != -1) {\n        bout.write(buffer, 0, bytesRead);\n    }\n    bout.flush(); // Ensure all data written\n}\n\n// Data streams for primitives\ntry (DataOutputStream dos = new DataOutputStream(\n        new FileOutputStream(\"data.bin\"))) {\n    dos.writeInt(42);\n    dos.writeDouble(3.14);\n    dos.writeUTF(\"Hello\");\n}\n\ntry (DataInputStream dis = new DataInputStream(\n        new FileInputStream(\"data.bin\"))) {\n    int i = dis.readInt();\n    double d = dis.readDouble();\n    String s = dis.readUTF();\n}"
                        },
                        "codeExplanations": {
                            "english": "The buffered copy uses an 8KB buffer to reduce system calls; read(byte[]) returns -1 at end-of-file. Data streams write primitives in binary format (platform independent for DataInput/DataOutput interfaces). UTF strings are length-prefixed. Flushing the buffered output ensures data is physically written to disk before close; with try-with-resources, close is automatic and flushes implicitly."
                        },
                        "keyPoints": [
                            "InputStream/OutputStream for raw binary data (8-bit bytes)",
                            "Buffered streams improve performance by reducing system calls",
                            "Data streams handle primitives (int, double) in binary format",
                            "Always close streams; use try-with-resources for automatic cleanup"
                        ],
                        "extras": {
                            "flowDiagram": "File → FileInputStream → BufferedInputStream → Application\nApplication → BufferedOutputStream → FileOutputStream → File",
                            "comparisonTable": "Stream Class|Purpose\nFileInputStream|Raw file bytes\nBufferedInputStream|Buffered file access\nDataInputStream|Primitive types\nObjectInputStream|Object serialization",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-8-2",
                        "title": "Character Streams",
                        "explanations": {
                            "english": "Character streams (Reader/Writer) handle 16-bit Unicode characters, automatically handling character encoding/decoding between internal UTF-16 and external byte encodings (UTF-8, ISO-8859-1, etc.). FileReader/FileWriter provide convenience constructors using default platform encoding (risky), while InputStreamReader/OutputStreamWriter allow explicit encoding specification for portability. BufferedReader adds readLine() for text line processing; PrintWriter offers formatted output (printf, println). CharArrayReader/Writer and StringReader/Writer allow in-memory character processing. When dealing with text files, always specify the encoding explicitly to avoid platform-dependent behavior and character corruption, especially for international characters outside ASCII range."
                        },
                        "code": {
                            "title": "Character Stream Usage",
                            "language": "java",
                            "content": "// Always specify encoding!\ntry (Reader reader = new InputStreamReader(\n        new FileInputStream(\"text.txt\"), StandardCharsets.UTF_8);\n     BufferedReader br = new BufferedReader(reader)) {\n    \n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n\n// Writing with explicit encoding\ntry (Writer writer = new OutputStreamWriter(\n        new FileOutputStream(\"out.txt\"), StandardCharsets.UTF_8);\n     PrintWriter pw = new PrintWriter(writer)) {\n    \n    pw.println(\"Line with Unicode: 日本語\");\n    pw.printf(\"Formatted: %d, %s%n\", 42, \"test\");\n}\n\n// Java 7+ Files convenience (handles encoding)\nList<String> lines = Files.readAllLines(\n    Paths.get(\"file.txt\"), \n    StandardCharsets.UTF_8\n);"
                        },
                        "codeExplanations": {
                            "english": "InputStreamReader bridges byte streams to character streams with specified encoding (UTF-8). BufferedReader provides efficient line-by-line reading. PrintWriter offers convenient formatting methods. The Files utility (Java 7) simplifies reading entire files into lists of strings with proper encoding handling. Explicit encoding prevents 'mojibake' (character corruption) when platform default differs from file encoding."
                        },
                        "keyPoints": [
                            "Reader/Writer for text (Unicode characters) vs bytes",
                            "Always specify Charset (UTF-8) for portability; don't rely on platform default",
                            "BufferedReader provides readLine() for line-oriented text",
                            "PrintWriter provides printf/println convenience methods"
                        ],
                        "extras": {
                            "flowDiagram": "File (bytes) → InputStream → InputStreamReader (decode UTF-8→chars) → BufferedReader → Application",
                            "comparisonTable": "Byte Stream|Character Stream|Use Case\nInputStream|Reader|Binary vs Text\nFileInputStream|FileReader (avoid)|File access\nBufferedInputStream|BufferedReader|Buffering\nDataInputStream|BufferedReader|Data vs Text",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-8-3",
                        "title": "Bridge Streams",
                        "explanations": {
                            "english": "Bridge streams convert between byte and character streams, handling the encoding/decoding transition. InputStreamReader converts an InputStream (bytes) to a Reader (characters) by decoding bytes using a specified Charset. Conversely, OutputStreamWriter converts a Writer (characters) to an OutputStream (bytes) by encoding characters to bytes. These are essential when legacy APIs provide byte streams but you need character handling, or when writing characters to byte-oriented destinations like network sockets or System.out. They handle charset encoding/decoding internally and support buffering when wrapped in BufferedReader/Writer. Without these bridges, programmers would manually manage byte-to-character conversion using CharsetEncoder/Decoder."
                        },
                        "code": {
                            "title": "Bridging Bytes to Characters",
                            "language": "java",
                            "content": "// System.in is byte stream, convert to character reader\nBufferedReader console = new BufferedReader(\n    new InputStreamReader(System.in, StandardCharsets.UTF_8)\n);\nString input = console.readLine();\n\n// Network socket (byte) to character communication\nSocket socket = new Socket(\"host\", 80);\nBufferedReader reader = new BufferedReader(\n    new InputStreamReader(socket.getInputStream(), \"ISO-8859-1\")\n);\nPrintWriter writer = new PrintWriter(\n    new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\")\n);\n\n// Writing to byte stream destination\nByteArrayOutputStream baos = new ByteArrayOutputStream();\ntry (Writer writer = new OutputStreamWriter(baos, StandardCharsets.UTF_8)) {\n    writer.write(\"Unicode text: émojis 🎉\");\n}\nbyte[] bytes = baos.toByteArray(); // UTF-8 encoded bytes"
                        },
                        "codeExplanations": {
                            "english": "InputStreamReader wraps System.in (byte stream) to provide character reading from console. Network communication often requires specific encodings (ISO-8859-1 for legacy HTTP, UTF-8 for modern). OutputStreamWriter converts character writes to the socket's byte output stream with proper encoding. The ByteArrayOutputStream example shows in-memory conversion of characters to specific byte encoding."
                        },
                        "keyPoints": [
                            "InputStreamReader: Bytes → Characters (decoding)",
                            "OutputStreamWriter: Characters → Bytes (encoding)",
                            "Essential for network I/O and System streams",
                            "Always specify charset to avoid platform dependencies"
                        ],
                        "extras": {
                            "flowDiagram": "Byte Stream (bytes) ← InputStreamReader → Character Stream (chars)\n                 (decode)\n\nCharacter Stream (chars) → OutputStreamWriter → Byte Stream (bytes)\n                     (encode)",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-8-4",
                        "title": "Encoding Basics",
                        "explanations": {
                            "english": "Character encoding specifies how characters are represented as bytes. ASCII (7-bit) covers English; ISO-8859-1 (Latin-1) extends to Western European languages; UTF-8 (variable 1-4 bytes) is the modern standard supporting all Unicode characters while maintaining ASCII compatibility; UTF-16 (2 or 4 bytes) is Java's internal representation. Mismatched encoding causes corruption (mojibake) when reading files. The StandardCharsets class provides constants for guaranteed-supported encodings. When reading/writing text, always specify the encoding explicitly rather than relying on platform defaults which vary by OS (Windows: Cp1252, Linux: UTF-8). Beware of the 'platform default' charset in FileReader/FileWriter constructors which causes portability bugs; use InputStreamReader/Writer with explicit charset instead."
                        },
                        "code": {
                            "title": "Encoding Handling",
                            "language": "java",
                            "content": "// StandardCharsets constants (Java 7+)\nCharset utf8 = StandardCharsets.UTF_8;\nCharset ascii = StandardCharsets.US_ASCII;\n\n// Encoding string to bytes\nString text = \"日本語\";\nbyte[] utf8Bytes = text.getBytes(utf8); // Valid UTF-8\nbyte[] asciiBytes = text.getBytes(ascii); // Replacement characters (garbage)\n\n// Decoding bytes to string\nString decoded = new String(utf8Bytes, utf8); // Correct\n\n// Detect encoding (not 100% reliable)\nInputStream in = new FileInputStream(\"file.txt\");\nbyte[] BOM = new byte[3];\nin.read(BOM);\nCharset encoding = StandardCharsets.UTF_8;\nif (BOM[0] == (byte)0xEF && BOM[1] == (byte)0xBB && BOM[2] == (byte)0xBF) {\n    encoding = StandardCharsets.UTF_8; // UTF-8 BOM detected\n}"
                        },
                        "codeExplanations": {
                            "english": "StandardCharsets provides charset constants avoiding UnsupportedEncodingException. getBytes(Charset) encodes the string; new String(bytes, Charset) decodes. Attempting to encode Japanese characters to ASCII produces replacement characters (?). BOM (Byte Order Mark) detection at file start can indicate UTF-8 encoding, though UTF-8 without BOM is more common."
                        },
                        "keyPoints": [
                            "UTF-8: Universal, recommended default encoding",
                            "Always specify encoding; avoid FileReader/FileWriter (use platform default)",
                            "StandardCharsets provides safe constants (UTF_8, ISO_8859_1)",
                            "Mismatched encoding causes data corruption"
                        ],
                        "extras": {
                            "flowDiagram": "Unicode String (Java memory: UTF-16)\n    ↓ getBytes(UTF_8)\nByte Array (UTF-8 encoded)\n    ↓ new String(bytes, UTF_8)\nUnicode String (correct)\n\nWrong:\n    ↓ new String(bytes, WINDOWS-1252)\nUnicode String (mojibake/corruption)",
                            "comparisonTable": "Charset|Bytes per char|Unicode Support|Usage\nASCII|1|Basic English|Legacy protocols\nISO-8859-1|1|Western Europe|Legacy Western systems\nUTF-8|1-4|Full Unicode|Web, modern standard\nUTF-16|2 or 4|Full Unicode|Java internal",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-9-1",
                        "title": "Performance Optimization",
                        "explanations": {
                            "english": "Buffered streams dramatically improve I/O performance by reducing the number of native system calls. Unbuffered streams make a system call for each byte or small array read/write, causing significant overhead due to context switches between Java and the OS kernel. Buffered streams internalize an in-memory buffer (typically 8KB) for batch reading/writing, filling or flushing the buffer only when full or explicitly flushed. This amortizes the cost of expensive I/O operations across many bytes. For file I/O, buffered variants can improve performance by orders of magnitude (10x-100x) for small operations. The optimal buffer size depends on the underlying device and typical data size; 8KB is a good default, but larger buffers (64KB-1MB) may improve sequential access on modern disks."
                        },
                        "code": {
                            "title": "Buffering Impact",
                            "language": "java",
                            "content": "// Without buffering - very slow for small reads\nFileInputStream slow = new FileInputStream(\"large.bin\");\nint data;\nwhile ((data = slow.read()) != -1) { // System call per byte!\n    process(data);\n}\n\n// With buffering - much faster\nBufferedInputStream fast = new BufferedInputStream(\n    new FileInputStream(\"large.bin\"), // Default 8KB buffer\n    65536 // Or specify 64KB custom buffer\n);\nwhile ((data = fast.read()) != -1) { // Reads from memory buffer\n    process(data);\n}"
                        },
                        "codeExplanations": {
                            "english": "The unbuffered example calls the OS read() system call for every single byte, consuming thousands of CPU cycles in context switches per byte. The buffered version reads 64KB into memory with one system call, then serves individual bytes from the array, reducing system calls by 99.9% for this workload."
                        },
                        "keyPoints": [
                            "Unbuffered I/O makes expensive system calls per operation",
                            "Buffered streams batch operations using internal memory buffers",
                            "Can improve performance 10x-100x for small read/write operations",
                            "Flush or close to ensure data reaches destination"
                        ],
                        "extras": {
                            "flowDiagram": "Unbuffered: App → read() → Kernel → Disk (per byte!)\nBuffered: App → Buffer (memory) → read() → Kernel → Disk (when buffer empty)",
                            "comparisonTable": "Approach|System Calls|Speed\nUnbuffered|Per byte|Very Slow (1x)\nBufferedInputStream|Per 8KB|Fast (50-100x)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-9-2",
                        "title": "Buffer Sizes",
                        "explanations": {
                            "english": "Buffer size selection balances memory usage against I/O efficiency. The default 8KB (8192 bytes) in Buffered streams suits many scenarios, but different workloads benefit from tuning. Small buffers (1-4KB) reduce memory for many concurrent streams but increase system calls. Large buffers (64KB-1MB) maximize throughput for sequential file access or high-latency networks (reducing round trips) but consume more memory and may reduce latency for small operations. For disk I/O, matching the OS page size (often 4KB or 8KB) or disk block size helps. For network I/O, the TCP window size or typical packet size (1460 bytes for Ethernet MTU) are relevant. Custom buffer sizes can be specified in Buffered stream constructors."
                        },
                        "code": {
                            "title": "Custom Buffer Sizing",
                            "language": "java",
                            "content": "// Default buffer (8KB)\nBufferedInputStream defaultBuf = new BufferedInputStream(in);\n\n// Large buffer for sequential file processing\nBufferedInputStream largeBuf = new BufferedInputStream(in, 1024 * 1024); // 1MB\n\n// Small buffer for constrained memory\nBufferedInputStream smallBuf = new BufferedInputStream(in, 1024); // 1KB\n\n// Matching buffer to array read size for efficiency\nbyte[] buffer = new byte[8192];\nBufferedInputStream bis = new BufferedInputStream(in, buffer.length);\nint len;\nwhile ((len = bis.read(buffer)) != -1) {\n    // Buffer size matches read array size for optimal performance\n}"
                        },
                        "codeExplanations": {
                            "english": "The default 8KB is suitable for general use. 1MB buffer suits sequential reading of large files where memory usage is acceptable. Matching the BufferedInputStream buffer size to the byte[] read size prevents unnecessary array copying in the stream implementation, as the buffer can be directly copied to the destination array."
                        },
                        "keyPoints": [
                            "Default 8KB suitable for general use",
                            "Large buffers (1MB+) for high-throughput sequential access",
                            "Match buffer size to typical read/write sizes to minimize copying",
                            "Consider memory constraints with many concurrent streams"
                        ],
                        "extras": {
                            "flowDiagram": "Small buffer (1KB): Freemptive system calls, low latency, less memory\nLarge buffer (1MB): Fewer system calls, high throughput, more memory",
                            "comparisonTable": "Buffer Size|Best For|Trade-off\n1-4KB|Many concurrent streams|Higher syscall overhead\n8KB (default)|General purpose|Balanced\n64KB-1MB|Sequential large files|Higher memory use",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-9-3",
                        "title": "When to Use Buffered Streams",
                        "explanations": {
                            "english": "Buffered streams should be used when performing frequent small read/write operations or when wrapping unbuffered byte streams (FileInputStream, SocketInputStream). They are unnecessary and add slight overhead when wrapping already buffered sources (ByteArrayInputStream, BufferedReader) or when performing large array operations where you're already buffering manually (reading 1MB at a time into your own byte[]). Always use buffering for file I/O and network communication unless profiling indicates it's unnecessary. For character streams, BufferedReader/Writer add line-oriented methods (readLine, newLine) in addition to buffering benefits. In Java NIO, buffering is handled differently through ByteBuffer.allocate(), but the same principles apply for reducing system calls."
                        },
                        "code": {
                            "title": "Appropriate Buffering",
                            "language": "java",
                            "content": "// DO: Buffer file or network streams\nBufferedInputStream bis = new BufferedInputStream(\n    new FileInputStream(\"file.txt\") // Unbuffered source\n);\n\n// DON'T: Buffer already buffered stream (redundant)\nBufferedInputStream redundant = new BufferedInputStream(\n    new ByteArrayInputStream(bytes) // Already in memory\n);\n\n// DON'T: Buffer when doing large manual reads\nFileInputStream fis = new FileInputStream(\"file.txt\");\nbyte[] largeBuffer = new byte[1024 * 1024];\nwhile (fis.read(largeBuffer) != -1) { } // No BufferedInputStream needed\n\n// DO: Use BufferedReader for line-oriented text\nBufferedReader br = new BufferedReader(\n    new FileReader(\"text.txt\") // Buffering + readLine()\n);\nString line = br.readLine();"
                        },
                        "codeExplanations": {
                            "english": "Buffering FileInputStream provides significant benefit. Buffering ByteArrayInputStream is redundant since data is already in memory. When manually reading into a 1MB array, the application handles buffering, so BufferedInputStream adds overhead. BufferedReader is essential for line-by-line text processing, providing both buffering and the readLine() convenience method."
                        },
                        "keyPoints": [
                            "Use for file I/O and network streams",
                            "Avoid for in-memory streams (ByteArrayInputStream)",
                            "Unnecessary if manually buffering with large arrays (>8KB)",
                            "Essential for character readLine() operations"
                        ],
                        "extras": {
                            "flowDiagram": "Use BufferedInputStream:\nFileInputStream ✓\nSocketInputStream ✓\nByteArrayInputStream ✗ (memory already)\nAlready buffered stream ✗",
                            "comparisonTable": "Scenario|Buffered?|Reason\nFile read/write|Yes|Reduce system calls\nSocket communication|Yes|Reduce network round trips\nByte arrays in memory|No|Already in RAM\nLarge manual buffers (1MB+)|No|Application handles buffering",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-10-1",
                        "title": "Object Serialization",
                        "explanations": {
                            "english": "Java Object Serialization converts object instances to byte streams for storage or transmission, and deserialization reconstructs objects from those bytes. Classes implement java.io.Serializable (marker interface) to indicate serializability. The ObjectOutputStream writeObject() method serializes objects, handling entire object graphs (following references), while ObjectInputStream readObject() reconstructs them. Transient fields are excluded; static fields are not serialized as they belong to class, not instance. Serialization preserves object identity within a stream (multiple references to same object become same object when deserialized). It is used for RMI, session persistence, and caching but has significant security implications and performance overhead compared to modern formats like JSON or Protocol Buffers."
                        },
                        "code": {
                            "title": "Basic Serialization",
                            "language": "java",
                            "content": "public class User implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String name;\n    private transient String password; // Not serialized\n    private int age;\n    \n    // Getters/setters omitted\n}\n\n// Serialize\nUser user = new User(\"Alice\", \"secret\", 30);\ntry (ObjectOutputStream oos = new ObjectOutputStream(\n        new FileOutputStream(\"user.ser\"))) {\n    oos.writeObject(user);\n}\n\n// Deserialize\nUser restored;\ntry (ObjectInputStream ois = new ObjectInputStream(\n        new FileInputStream(\"user.ser\"))) {\n    restored = (User) ois.readObject();\n}\n// restored.getPassword() returns null (transient)"
                        },
                        "codeExplanations": {
                            "english": "User implements Serializable with serialVersionUID for version control. The password field is marked transient, so it serializes as null (or default for primitives). The writeObject call serializes the object graph; readObject reconstructs it with correct type casting. The stream handles object references automatically."
                        },
                        "keyPoints": [
                            "Implement Serializable marker interface to enable serialization",
                            "ObjectOutputStream/ObjectInputStream handle conversion",
                            "n",
                            "Transient fields are excluded from serialization",
                            "Preserves object identities and graphs (circular references handled)"
                        ],
                        "extras": {
                            "flowDiagram": "Object Graph → ObjectOutputStream → Byte Stream (file/network)\nByte Stream → ObjectInputStream → Object Graph (restored)",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-10-2",
                        "title": "serialVersionUID",
                        "explanations": {
                            "english": "serialVersionUID is a unique version identifier for Serializable classes, stored in the serial stream to verify compatibility during deserialization. If the class definition changes (fields added/removed) and the UID differs from the stream, deserialization throws InvalidClassException. Explicitly declaring serialVersionUID (private static final long) prevents automatic generation that changes when class structure changes, allowing controlled versioning. Default UID computation is sensitive to class details including fields, methods, and interfaces. When evolving classes, maintain backward compatibility by keeping the same UID and handling missing fields in readObject. Adding serialVersionUID is strongly recommended to avoid unexpected incompatibility during minor class changes."
                        },
                        "code": {
                            "title": "Version Control",
                            "language": "java",
                            "content": "public class VersionedClass implements Serializable {\n    // Explicit UID prevents auto-generation\n    private static final long serialVersionUID = 20240101L;\n    \n    private String field1;\n    // Add new field in version 2\n    private String field2; // Deserializing old data: field2 = null\n    \n    // Custom deserialization for compatibility\n    private void readObject(ObjectInputStream in) \n        throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // Initialize new fields if missing from old stream\n        if (field2 == null) {\n            field2 = \"default\";\n        }\n    }\n}\n\n// Eclipse/IntelliJ can generate UID:\n// private static final long serialVersionUID = -6849794470754667701L;"
                        },
                        "codeExplanations": {
                            "english": "Declaring explicit serialVersionUID allows adding fields without breaking deserialization of old objects. Without it, changing the class changes the auto-generated UID, causing InvalidClassException. The custom readObject method handles backward compatibility by initializing new fields when deserializing old streams where those fields didn't exist."
                        },
                        "keyPoints": [
                            "Unique identifier for class versioning",
                            "Explicit declaration recommended to control compatibility",
                            "Mismatch causes InvalidClassException",
                            "Use custom readObject/writeObject for complex versioning logic"
                        ],
                        "extras": {
                            "flowDiagram": "Serialize (Class v1, UID=100) → Bytes with UID=100\nDeserialize with Class v2: UID=100 (match) → Success\nDeserialize with UID=200 (changed) → InvalidClassException",
                            "comparisonTable": "Scenario|Explicit UID|Implicit UID\nAdd method|Compatible|Compatible\nAdd field|Compatible (null/default)|Incompatible (UID changes)\nRemove field|Compatible|Incompatible",
                            "examples": []
                        }
                    },
                    {
                        "id": "s5-10-3",
                        "title": "Security Risks",
                        "explanations": {
                            "english": "Java deserialization is a significant security vulnerability because the readObject method can execute arbitrary code during reconstruction. Malicious byte streams can craft objects that execute harmful logic in their constructors, finalizers, or readObject methods upon deserialization (gadget chains). This has led to numerous critical vulnerabilities (e.g., Apache Commons Collections gadget chain). To mitigate, avoid deserializing untrusted data entirely. If necessary, use look-ahead deserialization with ObjectInputFilter (Java 9+) to whitelist allowable classes, validate object graph depth and size, and reject proxy classes. Consider safer alternatives like JSON or Protocol Buffers that don't execute code during parsing. Never serialize sensitive data without encryption, and mark sensitive fields transient."
                        },
                        "code": {
                            "title": "Deserialization Security",
                            "language": "java",
                            "content": "// NEVER deserialize untrusted data without filtering\nObjectInputStream ois = new ObjectInputStream(untrustedStream);\nObject obj = ois.readObject(); // Dangerous if stream is malicious!\n\n// Java 9+ ObjectInputFilter for whitelisting\nObjectInputFilter filter = ObjectInputFilter.Config.createFilter(\n    \"maxdepth=5;java.base/*;!com.example.dangerous.**\"\n);\nois.setObjectInputFilter(filter);\nObject safe = ois.readObject(); // Filter checks before instantiation\n\n// Alternative: JSON (Jackson) - no code execution\nString json = untrustedString;\nUser user = objectMapper.readValue(json, User.class); // Safe"
                        },
                        "codeExplanations": {
                            "english": "Raw deserialization of untrusted streams allows 'gadget chain' attacks where specially crafted serialized objects trigger code execution in library classes. ObjectInputFilter whitelists allowed packages and limits depth to prevent these attacks. JSON parsing doesn't instantiate arbitrary objects or execute methods, making it safer for untrusted data."
                        },
                        "keyPoints": [
                            "Deserialization of untrusted data can execute arbitrary code",
                            "Gadget chains exploit classes with dangerous readObject methods",
                            "Mitigation: ObjectInputFilter (whitelisting), avoid serialization for external data",
                            "Use JSON, XML, or Protocol Buffers instead for safer data interchange"
                        ],
                        "extras": {
                            "flowDiagram": "Malicious Bytes → ObjectInputStream.readObject() → Instantiate Gadget Classes → Execute System.exit() or worse\n\nSafe JSON → Parser → Plain Data → Manual Object Construction",
                            "comparisonTable": "Format|Code Execution Risk|Use for\nJava Serialization|High (gadget chains)|Internal persistence only\nJSON|Very Low|External APIs, config\nXML|Medium (XXE, entity expansion)|Document data\nProtocol Buffers|Very Low|Internal RPC",
                            "examples": [
                                "Apache Commons Collections gadgets",
                                "ysoserial exploit tool"
                            ]
                        }
                    },
                    {
                        "id": "s5-10-4",
                        "title": "Alternatives to Serialization",
                        "explanations": {
                            "english": "Modern alternatives to Java Serialization offer better security, performance, and cross-language compatibility. JSON (Jackson, Gson) is human-readable and widely supported but larger and slower for binary data. Protocol Buffers (protobuf) and Apache Avro provide compact binary formats with schema evolution, strong typing, and high performance, ideal for microservices communication. Kryo offers fast binary serialization for Java but requires careful version handling. FlatBuffers and Cap'n Proto enable zero-copy deserialization (access without parsing). XML (JAXB) is verbose but enterprise-standard. For persistence, database serialization (JPA, JDBC) or columnar formats (Parquet, ORC) are preferred. These alternatives avoid the security risks and serialization-specific bugs of native Java serialization while often providing better performance."
                        },
                        "code": {
                            "title": "Alternative Approaches",
                            "language": "java",
                            "content": "// JSON with Jackson\nObjectMapper mapper = new ObjectMapper();\nString json = mapper.writeValueAsString(user);\nUser restored = mapper.readValue(json, User.class);\n\n// Protocol Buffers (contract defined in .proto file)\nUserProto.User protoUser = UserProto.User.newBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\nbyte[] bytes = protoUser.toByteArray();\nUserProto.User parsed = UserProto.User.parseFrom(bytes);\n\n// Kryo (high performance Java binary)\nKryo kryo = new Kryo();\n kryo.register(User.class);\nOutput output = new Output(new FileOutputStream(\"file.bin\"));\nkryo.writeObject(output, user);\noutput.close();\n\nInput input = new Input(new FileInputStream(\"file.bin\"));\nUser user = kryo.readObject(input, User.class);\ninput.close();"
                        },
                        "codeExplanations": {
                            "english": "Jackson provides human-readable JSON with annotations for customization. Protocol Buffers requires schema definition but generates efficient, type-safe code for multiple languages. Kryo is a fast binary alternative for Java-only use cases, though it requires explicit class registration for security and efficiency in production."
                        },
                        "keyPoints": [
                            "JSON: Human-readable, language-neutral, verbose",
                            "Protocol Buffers/Avro: Compact binary, schema evolution, multi-language",
                            "Kryo: Fast Java-specific binary serialization",
                            "Prefer these over Java Serialization for new projects"
                        ],
                        "extras": {
                            "flowDiagram": "Java Object → Jackson → JSON Text → Any Language\nJava Object → Protobuf → Binary → Java/C++/Python/Go\nJava Object → Kryo → Binary → Java only",
                            "comparisonTable": "Format|Readable|Size|Speed|Security|Schema\nJava Serial|No|Large|Slow|Poor|Implicit\nJSON|Yes|Large|Medium|Good|External (JSON Schema)\nProtobuf|No|Small|Fast|Excellent|Required (.proto)\nKryo|No|Small|Very Fast|Fair|Implicit",
                            "examples": []
                        }
                    }
                ]
            },
            {
                "id": "section-6",
                "title": "Modern Java (Java 8+)",
                "topics": [
                    {
                        "id": "s6-1-1",
                        "title": "Lambda Expressions Syntax",
                        "explanations": {
                            "english": "Lambda expressions provide a concise way to represent anonymous functions (single method interfaces) using the syntax (parameters) -> body. They eliminate boilerplate for anonymous classes, requiring only the parameter list and implementation. Parentheses around parameters are optional for single parameters, and curly braces are optional for single-line bodies. Explicit parameter types can be inferred by the compiler (target typing) from the functional interface context. The arrow operator (->) separates parameters from body. Lambdas must match the signature of the abstract method in the functional interface they implement. This syntax enables functional programming patterns while maintaining type safety through compile-time inference."
                        },
                        "code": {
                            "title": "Lambda Syntax Variations",
                            "language": "java",
                            "content": "// Full syntax with types\nRunnable r1 = () -> {\n    System.out.println(\"Hello\");\n};\n\n// Single parameter, inferred type\nConsumer<String> c1 = (String s) -> System.out.println(s);\nConsumer<String> c2 = s -> System.out.println(s); // Types inferred\n\n// Multiple parameters\nComparator<Integer> comp = (a, b) -> a.compareTo(b);\n\n// Multi-line body with return\nFunction<Integer, Integer> f = (Integer x) -> {\n    int result = x * 2;\n    return result;\n};\n\n// Expression body (implicit return)\nFunction<Integer, Integer> square = x -> x * x;\n\n// Method reference equivalent\nConsumer<String> c3 = System.out::println;"
                        },
                        "codeExplanations": {
                            "english": "The examples show lambda syntax evolution from verbose to concise. Single parameters don't need parentheses; single expressions don't need braces or explicit return. The compiler infers types from the target functional interface (Consumer<String> tells the compiler the parameter is String). Method references (::) provide even shorter syntax when the lambda just calls an existing method."
                        },
                        "keyPoints": [
                            "Syntax: (parameters) -> { body } or (parameters) -> expression",
                            "Parameter types can usually be inferred (target typing)",
                            "Single parameter: parentheses optional; Single expression: braces/return optional",
                            "Must match the single abstract method of a functional interface"
                        ],
                        "extras": {
                            "flowDiagram": "Lambda Expression → Compiler infers target type → Matches Functional Interface → Generates byte code",
                            "comparisonTable": "",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-1-2",
                        "title": "Functional Programming Basics",
                        "explanations": {
                            "english": "Functional programming in Java treats computation as the evaluation of mathematical functions, emphasizing immutability, first-class functions (lambdas), and avoiding side effects. Key concepts include pure functions (same output for same input, no side effects), higher-order functions (functions that take or return functions), and immutability (data doesn't change after creation). Java supports functional programming through lambda expressions, method references, and the Stream API while remaining object-oriented. Functional approaches prefer declarative code (what to do) over imperative (how to do it), using operations like map, filter, and reduce. This style reduces bugs by minimizing shared mutable state and makes code more testable and parallelizable."
                        },
                        "code": {
                            "title": "Functional vs Imperative",
                            "language": "java",
                            "content": "// Imperative style (how to do it)\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList<String> upper = new ArrayList<>();\nfor (String name : names) {\n    if (name.length() > 3) {\n        upper.add(name.toUpperCase());\n    }\n}\n\n// Functional style (what to do)\nList<String> upperFunctional = names.stream()\n    .filter(name -> name.length() > 3)    // Predicate\n    .map(String::toUpperCase)             // Function\n    .collect(Collectors.toList());        // Collector\n\n// Pure function (no side effects)\nFunction<Integer, Integer> pure = x -> x * 2;\n\n// Higher-order function (returns function)\npublic static Function<Integer, Integer> multiplier(int factor) {\n    return x -> x * factor; // Returns a function\n}\n\nFunction<Integer, Integer> triple = multiplier(3);\nint result = triple.apply(5); // 15"
                        },
                        "codeExplanations": {
                            "english": "The imperative example manually iterates and collects, modifying external state. The functional example uses stream operations: filter applies a predicate to keep elements > 3 characters, map transforms each element, and collect gathers results. pure is a pure function with no side effects. multiplier is a higher-order function returning a function that captures the factor variable (closure)."
                        },
                        "keyPoints": [
                            "Declarative programming: describe what, not how",
                            "Pure functions: deterministic, no side effects, easier to test",
                            "Higher-order functions: functions as parameters or return values",
                            "Immutability preferred; avoid modifying external state in lambdas"
                        ],
                        "extras": {
                            "flowDiagram": "Data → Filter → Map → Collect → Result\n(Declarative pipeline vs step-by-step imperative)",
                            "comparisonTable": "Aspect|Imperative|Functional\nStyle|Step-by-step|Declarative\nState|Mutable variables|Immutable data\nSide Effects|Common|Avoided\nParallel|Hard|Easy (Streams)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-1-3",
                        "title": "Effectively Final Variables",
                        "explanations": {
                            "english": "Effectively final variables are local variables that are not declared final but whose values never change after initialization. Lambdas and local classes can capture (close over) these variables, but only if they are effectively final. Attempting to modify such a variable after its declaration results in a compilation error when referenced from a lambda. This restriction exists because lambdas may execute asynchronously (e.g., in streams or threads) after the method returns, and allowing modification would create race conditions and visibility issues. Instance and static fields can be modified within lambdas; the restriction applies only to local variables and parameters. This ensures thread safety and prevents confusing side effects in functional code."
                        },
                        "code": {
                            "title": "Variable Capture Rules",
                            "language": "java",
                            "content": "public void lambdaCapture() {\n    int count = 0; // Effectively final (never modified)\n    \n    Runnable r = () -> {\n        System.out.println(count); // OK: reading effectively final\n        // count++; // Compile error: must be final or effectively final\n    };\n    \n    // count = 1; // Would make count not effectively final\n    \n    // Workaround using array or AtomicInteger\n    int[] counter = new int[1];\n    Runnable r2 = () -> {\n        counter[0]++; // OK: array reference is final, contents mutable\n    };\n    \n    // Better: use atomic types\n    AtomicInteger atomicCount = new AtomicInteger(0);\n    Runnable r3 = () -> {\n        atomicCount.incrementAndGet(); // OK: modifying object state, not reference\n    };\n}\n\n// Instance fields are always accessible\nprivate int instanceVar = 0;\npublic void fieldAccess() {\n    Runnable r = () -> {\n        instanceVar++; // OK: instance fields can be modified\n    };\n}"
                        },
                        "codeExplanations": {
                            "english": "count is effectively final (not modified), so it can be read inside the lambda. Modifying it after or within the lambda is prohibited. The array workaround works because the variable (reference) is final, even though the array contents can change. AtomicInteger is the proper solution for counters in lambdas. Instance fields have no restrictions because they exist on the heap and are accessible to any code with a reference to the object."
                        },
                        "keyPoints": [
                            "Local variables referenced from lambdas must be final or effectively final",
                            "Effectively final: assigned once, never modified after",
                            "Restriction prevents race conditions in asynchronous execution",
                            "Instance fields and array elements can be modified (reference stays final)"
                        ],
                        "extras": {
                            "flowDiagram": "Lambda Creation → Captures value of effectively final variable\nMethod returns → Lambda executes later with captured copy\n(Original variable may be gone, so modification would be unsafe)",
                            "comparisonTable": "Variable Type|Can Read|Can Modify\nEffectively final local|Yes|No\nNon-final local|No|No\nInstance field|Yes|Yes\nStatic field|Yes|Yes\nArray elements|Yes|Yes (reference is final)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-2-1",
                        "title": "Predicate",
                        "explanations": {
                            "english": "Predicate<T> is a functional interface representing a boolean-valued function of one argument, used for testing conditions or filtering. Its single abstract method is boolean test(T t). Predicates are fundamental to the Stream API's filter operation and can be composed using and(), or(), and negate() default methods. Common uses include validation (is valid email), filtering collections (is active user), and conditional logic. The interface provides static methods isEqual() for equality testing and default methods for logical combination. Predicates enable declarative filtering logic without verbose anonymous classes, making code more readable and composable."
                        },
                        "code": {
                            "title": "Predicate Usage and Composition",
                            "language": "java",
                            "content": "// Basic predicate\nPredicate<String> isLong = s -> s.length() > 5;\nboolean result = isLong.test(\"Hello World\"); // true\n\n// Usage in Stream filtering\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nList<String> longNames = names.stream()\n    .filter(isLong)\n    .collect(Collectors.toList());\n\n// Negation\nPredicate<String> isShort = isLong.negate();\n\n// Composition with AND/OR\nPredicate<String> startsWithA = s -> s.startsWith(\"A\");\nPredicate<String> longAndStartsWithA = isLong.and(startsWithA);\n\n// Method reference\nPredicate<Object> isNull = Objects::isNull;\nPredicate<Object> nonNull = Objects::nonNull;\n\n// BiPredicate for two arguments\nBiPredicate<String, Integer> isLength = (s, len) -> s.length() == len;"
                        },
                        "codeExplanations": {
                            "english": "isLong tests string length; filter applies it to stream elements. Negate creates the opposite condition. and() combines two predicates with short-circuit evaluation (if first is false, second not evaluated). BiPredicate accepts two arguments for comparisons requiring both values, like checking if a string matches a specific length parameter."
                        },
                        "keyPoints": [
                            "Represents boolean condition: T -> boolean",
                            "Primary method: test(T t)",
                            "Composable: and(), or(), negate() for combining conditions",
                            "Heavily used in Stream.filter()"
                        ],
                        "extras": {
                            "flowDiagram": "Stream Elements → Predicate.test() → true: keep, false: filter out",
                            "comparisonTable": "Operation|Method|Description\nLogical AND|p1.and(p2)|Both must be true\nLogical OR|p1.or(p2)|At least one true\nNegation|p.negate()|Opposite boolean\nEquality|Predicate.isEqual(obj)|Compares to specific object",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-2-2",
                        "title": "Consumer",
                        "explanations": {
                            "english": "Consumer<T> represents an operation that accepts a single argument and returns no result (void), used for side effects like printing, logging, or modifying external state. Its method is void accept(T t). Consumers are used in Stream's forEach() method to process each element. The andThen() default method allows chaining consumers where the output of the first becomes input to the second (sequenced execution). BiConsumer<T,U> handles two arguments, useful for Map.forEach() entry processing. Unlike functions, consumers don't return values, making them suitable for terminal operations in pipelines where the action itself is the goal rather than transformation."
                        },
                        "code": {
                            "title": "Consumer Patterns",
                            "language": "java",
                            "content": "// Basic consumer\nConsumer<String> printer = System.out::println;\nprinter.accept(\"Hello\"); // Prints Hello\n\n// ForEach usage\nList<Integer> numbers = Arrays.asList(1, 2, 3);\nnumbers.forEach(n -> System.out.println(n * 2));\n\n// Chaining consumers\nConsumer<String> printUpper = s -> System.out.println(s.toUpperCase());\nConsumer<String> printLength = s -> System.out.println(s.length());\nConsumer<String> combined = printUpper.andThen(printLength);\ncombined.accept(\"hello\"); // Prints HELLO then 5\n\n// BiConsumer (two arguments)\nMap<String, Integer> scores = new HashMap<>();\nscores.put(\"Alice\", 90);\nscores.forEach((name, score) -> \n    System.out.println(name + \": \" + score)\n);\n\n// Custom consumer with logic\nConsumer<List<Integer>> clearAndLog = list -> {\n    System.out.println(\"Clearing list of size \" + list.size());\n    list.clear();\n};"
                        },
                        "codeExplanations": {
                            "english": "System.out::println is a method reference fitting Consumer<String>. forEach applies the consumer to each stream element. andThen sequences consumers; combined first prints uppercase, then prints length. BiConsumer accepts both map key and value in forEach. Custom consumers can encapsulate complex side-effect logic while maintaining functional interface compatibility."
                        },
                        "keyPoints": [
                            "Represents operation: T -> void (side effects)",
                            "Method: accept(T t)",
                            "andThen() chains sequential operations",
                            "BiConsumer<T,U> for two-argument operations (e.g., Map entries)"
                        ],
                        "extras": {
                            "flowDiagram": "Element → Consumer.accept() → Side Effect (print, log, modify external state)",
                            "comparisonTable": "Interface|Arguments|Returns|Use Case\nConsumer<T>|1|void|ForEach operations\nBiConsumer<T,U>|2|void|Map iteration\nSupplier<T>|0|T|Provide values\nFunction<T,R>|1|R|Transform data",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-2-3",
                        "title": "Supplier",
                        "explanations": {
                            "english": "Supplier<T> represents a supplier of results that takes no arguments and returns a value, acting as a factory or deferred execution mechanism. Its method is T get(). Suppliers are used for lazy evaluation, generating values only when needed (e.g., Optional.orElseGet() to avoid expensive default value computation). They enable dependency injection of value creation logic and are essential for factory patterns in functional style. Common uses include creating random values, reading configuration, or generating timestamps. Unlike functions, Suppliers have no input, making them suitable for providing values on demand without external dependencies. The DoubleSupplier, IntSupplier, and LongSupplier variants avoid boxing for primitives."
                        },
                        "code": {
                            "title": "Supplier Patterns",
                            "language": "java",
                            "content": "// Basic supplier\nSupplier<String> greeting = () -> \"Hello World\";\nString message = greeting.get(); // Lazily provides value\n\n// Lazy evaluation with Optional\nOptional<String> optional = Optional.empty();\nString value = optional.orElseGet(() -> {\n    // Only executes if optional is empty\n    System.out.println(\"Computing expensive default...\");\n    return expensiveOperation();\n});\n\n// Factory pattern\nSupplier<List<String>> listFactory = ArrayList::new;\nList<String> list1 = listFactory.get();\nList<String> list2 = listFactory.get();\n\n// Random generation\nSupplier<Integer> randomInt = () -> (int) (Math.random() * 100);\nint number = randomInt.get();\n\n// Primitive suppliers (avoid boxing)\nIntSupplier intSupplier = () -> 42;\nint primitive = intSupplier.getAsInt(); // Returns int, not Integer"
                        },
                        "codeExplanations": {
                            "english": "orElseGet demonstrates lazy evaluation: the expensive lambda only executes if the Optional is empty, unlike orElse which always executes. listFactory is a Supplier creating new ArrayLists, useful for Stream.collect(). Primitive suppliers (IntSupplier, etc.) return primitives directly to avoid Integer object overhead, offering better performance in tight loops."
                        },
                        "keyPoints": [
                            "Represents supplier: () -> T (no input, produces output)",
                            "Method: get()",
                            "Used for lazy evaluation and factory patterns",
                            "Primitive variants: IntSupplier, LongSupplier, DoubleSupplier"
                        ],
                        "extras": {
                            "flowDiagram": "Call Supplier.get() → Executes logic → Returns value\n(Deferred until called)",
                            "comparisonTable": "Method|Eager|Lazy\norElse(value)|Always computes|N/A (already computed)\norElseGet(Supplier)|N/A|Computes only if needed",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-2-4",
                        "title": "Function",
                        "explanations": {
                            "english": "Function<T,R> represents a function that accepts one argument and produces a result, serving as the primary transformation type in functional programming. Its method is R apply(T t). Functions are used in Stream.map() for element transformation (e.g., String to Integer). The compose() method applies a function before the current one (f.compose(g) means f(g(x))), while andThen() applies after (f.andThen(g) means g(f(x))). identity() returns a function that always returns its input argument. UnaryOperator<T> extends Function where input and output are the same type. Functions enable method chaining and composition, allowing complex transformations to be built from simple, reusable components."
                        },
                        "code": {
                            "title": "Function Composition",
                            "language": "java",
                            "content": "// Basic function\nFunction<String, Integer> length = String::length;\nint len = length.apply(\"hello\"); // 5\n\n// Chaining with andThen\nFunction<String, String> trim = String::trim;\nFunction<String, String> toUpper = String::toUpperCase;\nFunction<String, String> trimThenUpper = trim.andThen(toUpper);\nString result = trimThenUpper.apply(\"  hello  \"); // \"HELLO\"\n\n// Composition with compose (reverse order)\nFunction<String, String> composeResult = toUpper.compose(trim); // Same as above\n\n// Stream transformation\nList<String> names = Arrays.asList(\"Alice\", \"Bob\");\nList<Integer> lengths = names.stream()\n    .map(length)\n    .collect(Collectors.toList());\n\n// UnaryOperator (input type = output type)\nUnaryOperator<String> addExclamation = s -> s + \"!\";\n\n// Identity function\nFunction<String, String> identity = Function.identity(); // Returns input unchanged"
                        },
                        "codeExplanations": {
                            "english": "andThen chains functions left-to-right: first trim is applied, then toUpper. compose chains right-to-left: the argument function (trim) executes first, then the caller (toUpper). identity is useful as a default function or when a function is required but no transformation is needed. UnaryOperator is a convenience type when you want to indicate the transformation preserves the type (e.g., String to String)."
                        },
                        "keyPoints": [
                            "Represents transformation: T -> R",
                            "Method: apply(T t)",
                            "andThen(): sequential composition; compose(): nested composition",
                            "UnaryOperator<T> is Function<T, T> (same type)"
                        ],
                        "extras": {
                            "flowDiagram": "Input → Function1.apply() → Result1 → Function2.apply() → Result2\n(andThen chaining)",
                            "comparisonTable": "Method|Order|Syntax\nf.andThen(g)|f then g|g(f(x))\nf.compose(g)|g then f|f(g(x))\nidentity|N/A|x -> x",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-2-5",
                        "title": "Custom Functional Interfaces",
                        "explanations": {
                            "english": "Custom functional interfaces define domain-specific contracts for lambdas when standard interfaces (Predicate, Function, Consumer) don't match the required signature. They are annotated with @FunctionalInterface to indicate they are intended for lambdas and enable compiler checking (ensures exactly one abstract method). Custom interfaces improve code readability by using domain-relevant names (e.g., Validator, Transformer) and can specify checked exceptions in their abstract method signatures. They may include default and static methods without breaking the functional interface contract. When designing custom functional interfaces, prefer using existing standard interfaces if possible to leverage utility methods and ensure familiarity for other developers."
                        },
                        "code": {
                            "title": "Custom Interface Definition",
                            "language": "java",
                            "content": "package com.example.validation;\n\n@FunctionalInterface\npublic interface Validator<T> {\n    // Single abstract method\n    boolean validate(T value) throws ValidationException;\n    \n    // Default method (doesn't affect functional interface status)\n    default Validator<T> and(Validator<T> other) {\n        return value -> this.validate(value) && other.validate(value);\n    }\n    \n    // Static utility\n    static <T> Validator<T> alwaysTrue() {\n        return value -> true;\n    }\n}\n\n// Usage\nValidator<String> notNull = s -> s != null;\nValidator<String> notEmpty = s -> !s.isEmpty();\nValidator<String> combined = notNull.and(notEmpty);\n\ntry {\n    boolean valid = combined.validate(\"hello\");\n} catch (ValidationException e) {\n    // Handle checked exception\n}\n\n// Generic transformer with exception\n@FunctionalInterface\npublic interface ThrowingFunction<T, R, E extends Exception> {\n    R apply(T t) throws E;\n}"
                        },
                        "codeExplanations": {
                            "english": "Validator is a custom functional interface with a check for single abstract method and allowed checked exception. The default method 'and' provides composition capability similar to Predicate. ThrowingFunction demonstrates a generic pattern for functional interfaces that need to declare checked exceptions, commonly used in frameworks that bridge functional and checked exception worlds."
                        },
                        "keyPoints": [
                            "Use @FunctionalInterface annotation for compiler verification",
                            "Exactly one abstract method (SAM); other methods must be default/static",
                            "n",
                            "Can declare checked exceptions unlike standard functional interfaces",
                            "Prefer standard interfaces (Function, Predicate) when possible"
                        ],
                        "extras": {
                            "flowDiagram": "@FunctionalInterface\n    ↓\nCompiler checks: exactly 1 abstract method\n    ↓\nCan use with lambda syntax",
                            "comparisonTable": "Feature|Standard|Custom\nReadability|Generic (Function)|Domain-specific (Validator)\nChecked Exceptions|No (Runtime)|Can declare\nUtility methods|Many (andThen, etc.)|Must implement own",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-3-1",
                        "title": "Static Method References",
                        "explanations": {
                            "english": "Static method references use the syntax ClassName::methodName to refer to static methods as functional interfaces. They are shorthand for lambdas that call static methods (args -> ClassName.method(args)). The method signature must match the functional interface's abstract method signature. Static method references provide cleaner, more readable code when the lambda only calls a static method without additional logic. They are commonly used for utility methods like Integer::parseInt, String::valueOf, or Collections::sort. The compiler handles type inference to match the method signature to the functional interface, checking parameter types and return type compatibility. Static references avoid the overhead of lambda generation when the method already exists."
                        },
                        "code": {
                            "title": "Static Reference Usage",
                            "language": "java",
                            "content": "// Lambda equivalent: s -> Integer.parseInt(s)\nFunction<String, Integer> parser = Integer::parseInt;\nint num = parser.apply(\"42\"); // 42\n\n// Converting list to strings\nList<Integer> numbers = Arrays.asList(1, 2, 3);\nList<String> strings = numbers.stream()\n    .map(String::valueOf) // Static method reference\n    .collect(Collectors.toList());\n\n// Sorting with Comparator\nList<String> names = Arrays.asList(\"Alice\", \"bob\", \"Charlie\");\nnames.sort(String::compareToIgnoreCase);\n\n// Thread factory\nSupplier<Thread> threadFactory = Thread::new; // Reference to constructor\nThread t = threadFactory.get();\n\n// Utility class methods\nFunction<Double, Double> abs = Math::abs;\nBiFunction<Integer, Integer, Integer> max = Math::max;"
                        },
                        "codeExplanations": {
                            "english": "Integer::parseInt converts a String to Integer, matching Function<String, Integer>. String::valueOf converts objects to strings. String::compareToIgnoreCase matches Comparator<String>. Math::abs and Math::max show static references with different arities (unary and binary). These references produce the same bytecode as equivalent lambdas but are more concise."
                        },
                        "keyPoints": [
                            "Syntax: ClassName::staticMethodName",
                            "Shorthand for lambda calling static method",
                            "Method signature must match functional interface method",
                            "Cleaner than equivalent lambda when no additional logic needed"
                        ],
                        "extras": {
                            "flowDiagram": "Lambda: x -> Class.method(x)\n         ↓ equivalent\nReference: Class::method",
                            "comparisonTable": "Lambda|Method Reference|Use When\nx -> Math.abs(x)|Math::abs|Just calling static method\nx -> x.trim()|String::trim|Just calling instance method\n() -> new ArrayList()|ArrayList::new|Object creation",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-3-2",
                        "title": "Instance Method References",
                        "explanations": {
                            "english": "Instance method references refer to methods of a specific object instance using the syntax instance::methodName. They are used when calling a method on a particular object known at the time the reference is created, unlike arbitrary instance references (ClassName::methodName) which operate on the lambda argument. Common uses include event handlers referencing a listener's method, callbacks to specific object state, or wrapping existing object methods as functions. The instance is captured (bound) when the reference is created, not when it's invoked. This is useful for dependency injection scenarios where a service method should be invoked as a callback. The instance method must match the functional interface signature excluding the first parameter (which is the instance itself)."
                        },
                        "code": {
                            "title": "Bound Instance References",
                            "language": "java",
                            "content": "// Specific instance method reference\nString prefix = \"Hello, \";\nFunction<String, String> greeter = prefix::concat; // s -> prefix.concat(s)\nString result = greeter.apply(\"World\"); // \"Hello, World\"\n\n// Using existing object methods\nList<String> list = new ArrayList<>();\nConsumer<String> addToList = list::add; // s -> list.add(s)\naddToList.accept(\"Item\"); // Adds to specific list instance\n\n// arbitrary instance reference (different syntax)\nFunction<String, String> toUpper = String::toUpperCase; // s -> s.toUpperCase()\n\n// Comparator with instance field\nLocalDate today = LocalDate.now();\nComparator<Event> byDaysUntil = Comparator.comparing(\n    event -> ChronoUnit.DAYS.between(today, event.getDate())\n);"
                        },
                        "codeExplanations": {
                            "english": "prefix::concat binds the specific String object 'prefix' so when the function is called with \"World\", it invokes prefix.concat(\"World\"). list::add binds to the specific ArrayList instance, useful for callbacks that should modify that specific collection. List<String>::add would be an unbound reference requiring both the list and element as arguments (BiConsumer)."
                        },
                        "keyPoints": [
                            "Syntax: objectInstance::methodName",
                            "n",
                            "Captures specific instance at reference creation time",
                            "Different from ClassName::method (arbitrary instance)",
                            "Useful for callbacks to specific objects"
                        ],
                        "extras": {
                            "flowDiagram": "Specific Object → Method Reference Captured → Lambda Invocation Calls Object's Method",
                            "comparisonTable": "Type|Syntax|Parameters\nStatic|Class::method|Regular parameters\nBound Instance|obj::method|Regular parameters (obj captured)\nUnbound Instance|Class::method|First param becomes 'this', rest are params",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-3-3",
                        "title": "Constructor References",
                        "explanations": {
                            "english": "Constructor references use the syntax ClassName::new to refer to class constructors as functional interfaces, equivalent to lambda expressions that instantiate objects. They work with Supplier (no-arg constructor), Function (one-arg constructor), BiFunction (two-arg constructor), and custom functional interfaces matching constructor signatures. The compiler selects the appropriate constructor based on the target functional interface's parameters. Constructor references are cleaner than explicit lambdas for object factories and are heavily used in Stream collection operations (Collectors.toCollection(ArrayList::new)). They enable dependency injection patterns where object creation is deferred to a function reference. Generic type inference determines the exact class being instantiated."
                        },
                        "code": {
                            "title": "Constructor Reference Patterns",
                            "language": "java",
                            "content": "// No-arg constructor (Supplier)\nSupplier<ArrayList<String>> listFactory = ArrayList::new;\nArrayList<String> list = listFactory.get();\n\n// One-arg constructor (Function)\nFunction<String, File> fileCreator = File::new;\nFile file = fileCreator.apply(\"/path/to/file\");\n\n// Two-arg constructor (BiFunction)\nBiFunction<String, Integer, Person> personFactory = Person::new;\nPerson person = personFactory.apply(\"Alice\", 30);\n\n// Array constructor\nIntFunction<int[]> arrayCreator = int[]::new;\nint[] array = arrayCreator.apply(10); // size 10\n\n// Generic collection creation\nList<String> names = Stream.of(\"Alice\", \"Bob\")\n    .collect(Collectors.toCollection(ArrayList::new));"
                        },
                        "codeExplanations": {
                            "english": "ArrayList::new matches Supplier for default constructor. File::new matches Function<String, File> for the String path constructor. Person::new with two arguments matches BiFunction. int[]::new creates arrays (special array constructor reference syntax). Collectors.toCollection accepts a Supplier of a Collection, so ArrayList::new provides the factory for creating the result list."
                        },
                        "keyPoints": [
                            "Syntax: ClassName::new or obj.getClass()::new",
                            "Matches constructor arguments to functional interface parameters",
                            "Used with Supplier (0-args), Function (1-arg), BiFunction (2-args)",
                            "Array creation: Type[]::new (e.g., int[]::new)"
                        ],
                        "extras": {
                            "flowDiagram": "Functional Interface Requires Object → Constructor Reference Class::new → Invokes new Class(params)",
                            "comparisonTable": "Constructor|Matches Interface\nnew()|Supplier<T>\nnew(T)|Function<T, R>\nnew(T,U)|BiFunction<T, U, R>\nnew int[size]|IntFunction<int[]>",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-4-1",
                        "title": "Stream Creation",
                        "explanations": {
                            "english": "Streams in Java 8 represent sequences of elements supporting sequential and parallel aggregate operations. They can be created from collections (stream(), parallelStream()), arrays (Arrays.stream()), static factory methods (Stream.of, Stream.empty, Stream.iterate, Stream.generate), I/O channels (Files.lines), and primitives (IntStream, LongStream, DoubleStream). Streams are lazy; computation occurs only when a terminal operation is invoked. Unlike collections, streams don't store data; they carry values from a source through a pipeline of operations. Primitive streams avoid boxing overhead and provide numeric methods (sum, average, range). Infinite streams can be created with iterate (seeded) or generate (supplier-based), but require limit() to terminate for collection."
                        },
                        "code": {
                            "title": "Stream Sources",
                            "language": "java",
                            "content": "// From Collection\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream1 = list.stream();\nStream<String> parallelStream = list.parallelStream();\n\n// From Array\nString[] array = {\"a\", \"b\", \"c\"};\nStream<String> stream2 = Arrays.stream(array);\n\n// Static factory methods\nStream<String> stream3 = Stream.of(\"a\", \"b\", \"c\");\nStream<String> empty = Stream.empty();\nStream<String> nullable = Stream.ofNullable(getString()); // Java 9+\n\n// Infinite streams\nStream<Integer> infinite = Stream.iterate(0, n -> n + 2); // 0, 2, 4...\nStream<Integer> limited = Stream.iterate(0, n -> n < 10, n -> n + 1); // Java 9+\nStream<Double> random = Stream.generate(Math::random);\n\n// From I/O\ntry (Stream<String> lines = Files.lines(Paths.get(\"file.txt\"))) {\n    lines.forEach(System.out::println);\n}\n\n// Primitive streams (avoid boxing)\nIntStream intStream = IntStream.range(1, 100); // 1-99\nLongStream longStream = LongStream.rangeClosed(1, 100); // 1-100\nDoubleStream doubleStream = DoubleStream.of(1.0, 2.0, 3.0);"
                        },
                        "codeExplanations": {
                            "english": "Collection.stream() is the most common source. Stream.of creates a stream from values. Stream.iterate creates a stream by applying a function repeatedly to a seed; the two-arg version is infinite, requiring limit(). The three-arg version (Java 9) adds a hasNext predicate. Stream.generate creates infinite streams from a Supplier. Files.lines creates a stream lazily from file lines and should be in try-with-resources. Primitive streams like IntStream provide numeric operations without boxing Integer objects."
                        },
                        "keyPoints": [
                            "Collections: collection.stream()",
                            "Arrays: Arrays.stream(array)",
                            "Static: Stream.of(), Stream.iterate(), Stream.generate()",
                            "I/O: Files.lines(), BufferedReader.lines()",
                            "Primitives: IntStream, LongStream, DoubleStream"
                        ],
                        "extras": {
                            "flowDiagram": "Source (Collection, Array, I/O, Generator) → Stream Pipeline → Terminal Operation",
                            "comparisonTable": "Method|Stream Type|Description\nstream()|Stream<T>|Sequential collection stream\nparallelStream()|Stream<T>|Parallel collection stream\nStream.of()|Stream<T>|From elements\nStream.iterate()|Stream<T>|Infinite seeded generation\nStream.generate()|Stream<T>|Infinite supplier generation\nFiles.lines()|Stream<String>|File line stream (lazy)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-4-2",
                        "title": "Intermediate Operations",
                        "explanations": {
                            "english": "Intermediate operations transform a stream into another stream and are lazy—they don't execute until a terminal operation is invoked. They can be stateless (independent of other elements: filter, map, flatMap) or stateful (requiring full stream knowledge: distinct, sorted, limit, skip). Intermediate operations support short-circuiting where some elements may not need processing (limit, findFirst). Multiple intermediate operations chain together to form a pipeline, each operating on the output of the previous. Because streams are lazy and can be consumed only once, intermediate operations return new streams rather than modifying the source. Common operations include filter (predicate-based removal), map (element transformation), flatMap (stream flattening), distinct (duplication removal), and sorted (ordering)."
                        },
                        "code": {
                            "title": "Intermediate Operations",
                            "language": "java",
                            "content": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\nList<Integer> result = numbers.stream()\n    .filter(n -> n > 5)           // Keep only > 5: [6, 7, 8, 9, 10]\n    .map(n -> n * n)              // Transform: [36, 49, 64, 81, 100]\n    .limit(3)                     // Keep first 3: [36, 49, 64]\n    .sorted(Comparator.reverseOrder()) // Sort desc: [64, 49, 36]\n    .collect(Collectors.toList());\n\n// FlatMap: flatten nested structures\nList<List<Integer>> nested = Arrays.asList(\n    Arrays.asList(1, 2), \n    Arrays.asList(3, 4)\n);\nList<Integer> flat = nested.stream()\n    .flatMap(List::stream)        // Stream<Integer> instead of Stream<List<Integer>>\n    .collect(Collectors.toList()); // [1, 2, 3, 4]\n\n// Distinct and skip\nList<Integer> distinct = Stream.of(1, 2, 2, 3, 3, 3)\n    .distinct()                   // [1, 2, 3]\n    .collect(Collectors.toList());"
                        },
                        "codeExplanations": {
                            "english": "The pipeline shows filtering (removing elements <= 5), mapping (squaring), limiting (taking first 3), and sorting (descending). flatMap flattens Stream<List<Integer>> to Stream<Integer> by mapping each list to its stream and concatenating them. Distinct uses equals() to remove duplicates. These are all lazy—no computation happens until collect() is called."
                        },
                        "keyPoints": [
                            "Transform stream to stream; lazy evaluation",
                            "Stateless: filter, map, flatMap (element independent)",
                            "Stateful: distinct, sorted, limit, skip (need stream knowledge)",
                            "Return new streams; source not modified"
                        ],
                        "extras": {
                            "flowDiagram": "Source Stream → filter() → map() → sorted() → limit() → Terminal Operation\n(Lazy: nothing executes until terminal)",
                            "comparisonTable": "Operation|Type|Result\nfilter|Stateless|Elements matching predicate\nmap|Stateless|Transformed elements\nflatMap|Stateless|Flattened streams\ndistinct|Stateful|Unique elements\nsorted|Stateful|Ordered elements\nlimit|Stateful|First n elements",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-4-3",
                        "title": "Terminal Operations",
                        "explanations": {
                            "english": "Terminal operations trigger stream processing and consume the stream, producing a result or side effect. They can return a value (single value: findFirst, findAny, reduce, count; or collection: collect, toArray), perform side effects (forEach, forEachOrdered), or check properties (anyMatch, allMatch, noneMatch). Once a terminal operation is invoked, the stream is invalidated and cannot be reused (you must create a new stream from the source). Short-circuiting terminal operations (findFirst, anyMatch, limit) may process only part of the stream. Reduction operations (reduce, collect) combine elements into a result. The collect operation uses Collectors for complex aggregations (grouping, partitioning, joining), making it the most flexible terminal operation."
                        },
                        "code": {
                            "title": "Terminal Operations",
                            "language": "java",
                            "content": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Reductions\nint sum = numbers.stream().reduce(0, Integer::sum); // 15\nOptional<Integer> max = numbers.stream().reduce(Integer::max);\nlong count = numbers.stream().count();\n\n// Collection\nList<Integer> doubled = numbers.stream()\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\nString joined = numbers.stream()\n    .map(String::valueOf)\n    .collect(Collectors.joining(\", \")); // \"1, 2, 3, 4, 5\"\n\n// Matching\nboolean hasEven = numbers.stream().anyMatch(n -> n % 2 == 0);\nboolean allPositive = numbers.stream().allMatch(n -> n > 0);\n\n// Finding\nOptional<Integer> first = numbers.stream().findFirst();\nOptional<Integer> any = numbers.stream().parallel().findAny();\n\n// Side effects\nnumbers.stream().forEach(System.out::println);"
                        },
                        "codeExplanations": {
                            "english": "reduce combines elements with an accumulator (0 is identity). collect gathers results into collections or strings. Matching operations return boolean based on predicates. findFirst returns the first element in encounter order; findAny is more flexible for parallel streams. forEach is a terminal side-effect operation unlike intermediate peek(). After any terminal operation, the stream is closed and cannot be reused."
                        },
                        "keyPoints": [
                            "Trigger execution and consume the stream",
                            "Types: Reduction (reduce), Collection (collect), Matching (anyMatch), Finding (findFirst), Iteration (forEach)",
                            "Stream cannot be reused after terminal operation",
                            "Short-circuiting: findFirst, anyMatch may not process entire stream"
                        ],
                        "extras": {
                            "flowDiagram": "Intermediate Ops (lazy) → Terminal Op → Stream consumed → Result produced",
                            "comparisonTable": "Operation|Returns|Short-circuit|Produces\ncollect|Collection/Value|No|Aggregated result\nreduce|Value|No|Combined value\nforEach|void|No|Side effects\nfindFirst|Optional|Yes|First element\nanyMatch|boolean|Yes|true if any match",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-4-4",
                        "title": "Parallel Streams Overview",
                        "explanations": {
                            "english": "Parallel streams leverage multi-core CPUs by automatically partitioning the stream, processing chunks concurrently in the common ForkJoinPool, and combining results. Convert to parallel with stream.parallel() or create with collection.parallelStream(). Parallelism benefits CPU-intensive operations on large datasets (typically >10,000 elements), but adds overhead from task coordination that may slow small streams. Correctness requires thread-safe operations, avoidance of mutable shared state, and associative non-interfering lambdas. Stateful intermediate operations (sorted, distinct) and encounter-order-sensitive operations (findFirst, limit) may perform poorly or require additional coordination. Always measure performance—parallel streams are not automatically faster and can degrade performance due to splitting overhead and cache contention."
                        },
                        "code": {
                            "title": "Parallel Stream Usage",
                            "language": "java",
                            "content": "List<Integer> numbers = new ArrayList<>();\nfor (int i = 1; i <= 1_000_000; i++) {\n    numbers.add(i);\n}\n\n// Sequential vs Parallel\nlong sumSequential = numbers.stream()\n    .mapToLong(n -> n * n)\n    .sum();\n\nlong sumParallel = numbers.parallelStream() // or .stream().parallel()\n    .mapToLong(n -> n * n)\n    .sum();\n\n// Wrong: mutable shared state (race conditions!)\nList<Integer> result = new ArrayList<>();\nnumbers.parallelStream().forEach(result::add); // ConcurrentModificationException possible\n\n// Correct: use collect to merge results\nList<Integer> resultCorrect = numbers.parallelStream()\n    .map(n -> n * n)\n    .collect(Collectors.toList()); // Thread-safe merging\n\n// Custom ForkJoinPool (advanced)\nForkJoinPool customPool = new ForkJoinPool(4);\ntry {\n    customPool.submit(() ->\n        numbers.parallelStream().map(...).collect(...)\n    ).get();\n} catch (Exception e) {\n    e.printStackTrace();\n} finally {\n    customPool.shutdown();\n}"
                        },
                        "codeExplanations": {
                            "english": "parallelStream() automatically splits the million-element list across CPU cores. The wrong example shows the common mistake of mutating a shared ArrayList from parallel threads, causing data races. The correct approach uses collect() which handles thread-safe merging of results from parallel threads. Custom ForkJoinPool allows controlling parallelism level (default is availableProcessors)."
                        },
                        "keyPoints": [
                            "Enable with parallelStream() or stream.parallel()",
                            "Uses ForkJoinPool.commonPool() (threads = availableProcessors)",
                            "Good for: large datasets, CPU-intensive operations, stateless operations",
                            "Bad for: small datasets, blocking I/O, mutable shared state"
                        ],
                        "extras": {
                            "flowDiagram": "Sequential: Single thread processes all elements\nParallel: Stream split → Multiple threads process chunks → Results combined",
                            "comparisonTable": "Aspect|Sequential|Parallel\nThreading|Single|Multiple (ForkJoinPool)\nBest for|Small data, ordered ops|Large data, math-heavy\nThread safety|Not required|Required\nPerformance|Predictable|Measure first (overhead exists)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-5-1",
                        "title": "Avoiding NullPointerException",
                        "explanations": {
                            "english": "Optional<T>, introduced in Java 8, is a container object that may or may not contain a non-null value, designed to reduce NullPointerExceptions by forcing explicit handling of absent values. Instead of returning null (which may be forgotten and cause NPE), methods return Optional.empty() or Optional.of(value). Callers must explicitly choose what to do when empty: provide default (orElse), throw exception (orElseThrow), or transform if present (map). Optional does not eliminate null but provides a type-safe way to indicate potential absence. It should primarily be used as a return type for methods that might not return a value; using it for fields or method parameters is generally discouraged as it adds unnecessary wrapper overhead and complexity."
                        },
                        "code": {
                            "title": "Optional vs Null",
                            "language": "java",
                            "content": "// Old way - risk of NPE\npublic String findUserNameOld(String id) {\n    User user = findUser(id); // might return null\n    return user.getName().toUpperCase(); // NPE if user or name is null!\n}\n\n// New way with Optional\npublic Optional<String> findUserName(String id) {\n    return Optional.ofNullable(findUser(id))\n        .map(User::getName)\n        .map(String::toUpperCase);\n}\n\n// Handling the Optional\nOptional<String> nameOpt = findUserName(\"123\");\nnameOpt.ifPresent(System.out::println); // Only prints if present\n\n// Providing defaults\nString name = nameOpt.orElse(\"Unknown\"); // Static default\nString name2 = nameOpt.orElseGet(() -> fetchNameExpensively()); // Supplier\nString name3 = nameOpt.orElseThrow(() -> new NotFoundException(\"User not found\"));\n\n// Filtering\nOptional<String> longName = nameOpt.filter(n -> n.length() > 5);"
                        },
                        "codeExplanations": {
                            "english": "Optional.ofNullable wraps a potentially null value. map transforms the value if present (returns empty Optional if input was empty). ifPresent executes a consumer only if value exists. orElse provides fallback; orElseGet defers expensive computation until needed; orElseThrow converts empty to exception. filter returns empty if predicate doesn't match, enabling chained constraints."
                        },
                        "keyPoints": [
                            "Container for value that may be absent (null-safe alternative)",
                            "Use as return type for methods that may not have result",
                            "Forces explicit handling of empty case",
                            "of(value) for non-null, ofNullable(value) for possibly null, empty() for absent"
                        ],
                        "extras": {
                            "flowDiagram": "Method returns Optional → Caller must check:\n    → isPresent()?\n        Yes: get() value\n        No: orElse(), orElseThrow(), or ignore safely",
                            "comparisonTable": "Method|When Null in Source\nOptional.of(null)|Throws NPE immediately\nOptional.ofNullable(null)|Returns Optional.empty()\nOptional.empty()|Returns empty explicitly",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-5-2",
                        "title": "Proper Usage Patterns",
                        "explanations": {
                            "english": "Proper Optional usage emphasizes it as a return type for code that might not produce a result, not as a general null replacement. Avoid using Optional in fields (serialization issues, memory overhead), method parameters (awkward for callers, multiple wrapping), or collections (use empty collection instead). Never call get() without checking isPresent() first; prefer orElse, orElseGet, or ifPresent. Use map and flatMap for safe chaining of operations that return Optionals. flatMap flattens Optional<Optional<T>> to Optional<T>. ifPresentOrElse (Java 9+) handles both present and empty cases. Stream integration via stream() method (Java 9) allows treating Optional as 0-or-1 element stream for seamless Stream API integration."
                        },
                        "code": {
                            "title": "Best Practice Patterns",
                            "language": "java",
                            "content": "// Chaining operations safely\nOptional<Customer> customer = findCustomer(id);\nOptional<Order> order = customer\n    .flatMap(Customer::getLastOrder) // Returns Optional<Order>\n    .filter(o -> o.getTotal() > 100);\n\n// Null-safe chaining with defaults\nString city = findCustomer(id)\n    .flatMap(Customer::getAddress)\n    .map(Address::getCity)\n    .orElse(\"Unknown City\");\n\n// ifPresentOrElse (Java 9+)\nfindCustomer(id).ifPresentOrElse(\n    c -> System.out.println(\"Found: \" + c.getName()),\n    () -> System.out.println(\"Not found\")\n);\n\n// Stream integration (Java 9+)\nList<String> cities = customerIds.stream()\n    .map(this::findCustomer) // Stream<Optional<Customer>>\n    .flatMap(Optional::stream) // Stream<Customer> (filters empty)\n    .map(Customer::getCity)\n    .collect(Collectors.toList());\n\n// BAD: Never do this\nOptional<String> badField; // Don't use as field\nvoid badParam(Optional<String> param) { } // Don't use as parameter\nString value = opt.get(); // Dangerous without isPresent()"
                        },
                        "codeExplanations": {
                            "english": "flatMap handles methods that return Optional (avoiding Optional<Optional<...>> nesting). The city example shows deep null-safe navigation. ifPresentOrElse replaces if-else blocks. Optional.stream() converts empty to 0 elements, present to 1 element, enabling flatMap to filter empties automatically. The bad examples show anti-patterns: fields (serialization issues, overhead), parameters (awkward boxing), and unsafe get()."
                        },
                        "keyPoints": [
                            "Use as return type only; avoid fields and parameters",
                            "Never call get() without isPresent() check",
                            "Use map/flatMap for safe chaining",
                            "stream() method integrates with Stream API (Java 9)"
                        ],
                        "extras": {
                            "flowDiagram": "Optional Chain:\nOptional<Customer> → flatMap(getAddress) → Optional<Address> → map(getCity) → Optional<String> → orElse(default)",
                            "comparisonTable": "Method|Use Case\nmap|Transform value if present\nflatMap|Chain methods returning Optional\nifPresent|Side effect if present\nifPresentOrElse|Dual handling (Java 9)\nstream|Convert to 0-1 element Stream",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-5-3",
                        "title": "Anti-patterns",
                        "explanations": {
                            "english": "Common Optional anti-patterns undermine its purpose and create worse code than null checks. isPresent() followed by get() is verbose and no better than null checks; use orElse or orElseThrow instead. Using Optional in fields serializes poorly (not Serializable in early Java 8, fixed later but still awkward) and doubles object overhead. Method parameters wrapped in Optional annoy callers who must wrap arguments. Creating Optionals via new Optional<>() (constructor) is wrong; use factory methods. Serializing Optionals or using them as Map keys/values adds complexity. Testing Optional with == Optional.empty() instead of isPresent() or isEmpty() works but is less readable. The worst anti-pattern: using Optional to hide nulls without fixing the underlying null-producing code."
                        },
                        "code": {
                            "title": "Avoiding Bad Practices",
                            "language": "java",
                            "content": "// BAD: isPresent() + get() (verbose null-check equivalent)\nif (opt.isPresent()) {\n    return opt.get();\n} else {\n    return \"default\";\n}\n// GOOD: \nreturn opt.orElse(\"default\");\n\n// BAD: Optional as field\npublic class User {\n    private Optional<String> nickname; // Don't do this\n}\n// GOOD:\nprivate String nickname; // Null if absent\n\n// BAD: Optional parameter\npublic void process(Optional<String> data) { }\n// GOOD: Overloading or null with documentation\npublic void process(String data) { } // null means absent\n\n// BAD: Testing equality to empty\nif (opt == Optional.empty()) { }\n// GOOD:\nif (opt.isEmpty()) { } // Java 11+ or !opt.isPresent()\n\n// BAD: Creating with constructor ( compilation error anyway)\n// Optional<String> o = new Optional<>(); // Won't compile\n\n// BAD: Wrapping without checking\nOptional.of(null); // Throws NPE - use ofNullable"
                        },
                        "codeExplanations": {
                            "english": "The isPresent/get pattern is verbose and loses the fluent benefits. Optional fields double memory (Optional + String objects) and complicate serialization. Optional parameters force callers to wrap values awkwardly. Reference equality to Optional.empty() works (it's a singleton) but is idiomatically wrong; use isEmpty() (Java 11) or !isPresent(). Always use ofNullable when the value might be null."
                        },
                        "keyPoints": [
                            "Don't use isPresent() + get(); use orElse/orElseGet/orElseThrow",
                            "Don't use as fields or parameters",
                            "Don't use == Optional.empty(); use isEmpty()",
                            "Don't use constructor; use of/ofNullable/empty factories",
                            "Don't use Optional to avoid fixing null-returning methods"
                        ],
                        "extras": {
                            "flowDiagram": "Anti-pattern Detection:\nopt.isPresent()? opt.get() : default → Replace with opt.orElse()\nfield: Optional<Type> → Replace with Type (null allowed)\nmethod(Optional<T>) → Replace with method(T) + null check",
                            "comparisonTable": "Anti-Pattern|Better Alternative\nisPresent()? get() : value|orElse(value)\nOptional field|T field (null)\nOptional parameter|T parameter + validation\nnew Optional()|Optional.empty()/of()/ofNullable()\n== Optional.empty()|isEmpty() or !isPresent()",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-6-1",
                        "title": "LocalDate",
                        "explanations": {
                            "english": "LocalDate represents a date without time or timezone, such as '2024-03-15', in the ISO-8601 calendar system (year-month-day). It is immutable and thread-safe, suitable for birth dates, hire dates, or any date-only value. Key methods include now() for current date, of() for specific dates, plusDays/plusWeeks/plusMonths/plusYears for arithmetic, and withDayOfMonth/withMonth/withYear for adjustments. LocalDate provides DayOfWeek and Month enums for day/month queries. It handles leap years correctly (February 29 validated only in leap years). Period represents the difference between two LocalDates in years, months, and days. LocalDate is serializable and comparable, with comprehensive toString and parsing support via DateTimeFormatter."
                        },
                        "code": {
                            "title": "LocalDate Operations",
                            "language": "java",
                            "content": "// Creation\nLocalDate today = LocalDate.now();\nLocalDate specific = LocalDate.of(2024, 3, 15);\nLocalDate parsed = LocalDate.parse(\"2024-03-15\");\n\n// Querying\nint year = today.getYear();\nMonth month = today.getMonth(); // Month enum\nint day = today.getDayOfMonth();\nDayOfWeek dow = today.getDayOfWeek(); // MONDAY, etc.\nboolean leap = today.isLeapYear();\n\n// Arithmetic (returns new object, immutable)\nLocalDate tomorrow = today.plusDays(1);\nLocalDate nextMonth = today.plusMonths(1);\nLocalDate previousWeek = today.minusWeeks(1);\n\n// Adjustment (returns new object)\nLocalDate firstDayOfMonth = today.withDayOfMonth(1);\nLocalDate lastDayOfMonth = today.withDayOfMonth(today.lengthOfMonth());\n\n// Comparison\nboolean isBefore = today.isBefore(specific);\nboolean isAfter = today.isAfter(specific);\n\n// Period between dates\nPeriod period = Period.between(specific, today);\nint years = period.getYears();\nint months = period.getMonths();"
                        },
                        "codeExplanations": {
                            "english": "LocalDate is created via now(), factory of(), or parsing. It uses Month and DayOfWeek enums instead of magic numbers. All arithmetic methods return new LocalDate instances (immutable). Period calculates the calendar-based difference between dates (1 year, 2 months, 3 days) rather than absolute days. withXxx methods adjust specific fields while keeping others constant."
                        },
                        "keyPoints": [
                            "Date-only (no time, no timezone)",
                            "Immutable and thread-safe",
                            "Handles leap years and varying month lengths",
                            "Use Period for date-based differences, Duration for time-based"
                        ],
                        "extras": {
                            "flowDiagram": "LocalDate.now() → 2024-01-15\n    .plusDays(5) → 2024-01-20\n    .plusMonths(1) → 2024-02-20\n    .withDayOfMonth(1) → 2024-02-01",
                            "comparisonTable": "Legacy (java.util.Date)|Modern (LocalDate)\nMutable|Immutable\nIncludes time|Date only\nTimezone dependent|Zone-less\nJan=0|Jan=1 (sensible)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-6-2",
                        "title": "LocalDateTime",
                        "explanations": {
                            "english": "LocalDateTime represents date and time without timezone, such as '2024-03-15T10:30:00', combining LocalDate and LocalTime. It is suitable for local event times (appointment at 3 PM) where timezone is handled separately or implied, or for timestamps when zone is unknown or irrelevant. It provides similar arithmetic methods as LocalDate but for time components (plusHours, plusMinutes, plusSeconds) and combined adjustments. The atZone() method converts it to ZonedDateTime by adding a timezone, while toLocalDate() and toLocalTime() extract the components. LocalDateTime truncates nano-of-second precision and offers truncation methods (truncatedTo(ChronoUnit.MINUTES)). It follows the same immutability and thread-safety guarantees as other java.time types."
                        },
                        "code": {
                            "title": "LocalDateTime Usage",
                            "language": "java",
                            "content": "// Creation\nLocalDateTime now = LocalDateTime.now();\nLocalDateTime meeting = LocalDateTime.of(2024, 3, 15, 14, 30);\nLocalDateTime parsed = LocalDateTime.parse(\"2024-03-15T14:30:00\");\n\n// Extract components\nLocalDate date = now.toLocalDate();\nLocalTime time = now.toLocalTime();\n\n// Time arithmetic\nLocalDateTime later = now.plusHours(2).plusMinutes(30);\nLocalDateTime truncated = now.truncatedTo(ChronoUnit.HOURS); // Drop minutes\n\n// Combining with Zone\nZonedDateTime zoned = now.atZone(ZoneId.of(\"America/New_York\"));\nInstant instant = now.atZone(ZoneId.systemDefault()).toInstant();\n\n// Comparisons and between\nDuration duration = Duration.between(meeting, now);\nlong minutes = duration.toMinutes();"
                        },
                        "codeExplanations": {
                            "english": "LocalDateTime combines date and time operations. atZone adds timezone info to create ZonedDateTime, which can convert to Instant (timestamp). truncatedTo rounds down to specified precision. Duration measures exact time difference between two temporals (returns hours/minutes/seconds), while Period measures calendar units."
                        },
                        "keyPoints": [
                            "Date and time without timezone",
                            "Use for local event times, appointments",
                            "Convert to ZonedDateTime with atZone(zone) for absolute instant",
                            "Duration for time-based differences, Period for date-based"
                        ],
                        "extras": {
                            "flowDiagram": "LocalDateTime → atZone(ZoneId) → ZonedDateTime → toInstant() → Instant (absolute timestamp)",
                            "comparisonTable": "Class|Contains|Use Case\nLocalDate|Date only|Birthdays, holidays\nLocalTime|Time only|Business hours\nLocalDateTime|Date + Time|Local appointment\nZonedDateTime|Date + Time + Zone|Global timestamps\nInstant|Timestamp|Machine time, logging",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-6-3",
                        "title": "ZonedDateTime",
                        "explanations": {
                            "english": "ZonedDateTime represents date and time with timezone offset and zone rules, such as '2024-03-15T10:30:00+01:00[Europe/Paris]'. It handles daylight saving time (DST) transitions and historical zone changes via ZoneId rules. ZonedDateTime is fully aware of the complexities of global time, converting correctly between zones with withZoneSameInstant() or withZoneSameLocal(). The ZoneId represents the timezone identifier (e.g., 'America/New_York'), while ZoneOffset represents the offset from UTC (e.g., '+05:30'). During overlap (fall back) or gap (spring forward) transitions, ZonedDateTime resolves appropriately (e.g., choosing earlier offset in overlap). It converts to Instant (absolute point in timeline) via toInstant(), and from LocalDateTime via atZone() or of()."
                        },
                        "code": {
                            "title": "Timezone Handling",
                            "language": "java",
                            "content": "// Creation\nZonedDateTime meetingInNY = ZonedDateTime.now(ZoneId.of(\"America/New_York\"));\nZonedDateTime meetingInTokyo = ZonedDateTime.of(\n    2024, 3, 15, 14, 0, 0, 0, \n    ZoneId.of(\"Asia/Tokyo\")\n);\n\n// Zone conversion\nZonedDateTime sameInstantInLondon = meetingInNY.withZoneSameInstant(\n    ZoneId.of(\"Europe/London\")\n);\n// Adjusts time to represent same point in timeline\n\n// Keep local time, change zone (rarely correct)\nZonedDateTime differentInstant = meetingInNY.withZoneSameLocal(\n    ZoneId.of(\"Europe/London\")\n);\n\n// Get components\nZoneId zone = meetingInNY.getZone();\nZoneOffset offset = meetingInNY.getOffset();\nInstant instant = meetingInNY.toInstant(); // Absolute timestamp\n\n// DST handling\nZonedDateTime beforeDST = ZonedDateTime.of(\n    2024, 3, 10, 2, 30, 0, 0, \n    ZoneId.of(\"America/New_York\")\n); // Illegal time (spring forward) resolves to 3:30 AM"
                        },
                        "codeExplanations": {
                            "english": "withZoneSameInstant converts the time to another zone representing the same actual moment (e.g., 9am NY = 2pm London). withZoneSameLocal keeps the clock time digits but changes the zone (usually wrong unless specifically intended). DST gaps (spring forward) and overlaps (fall back) are handled by the zone rules. toInstant gives the absolute timestamp for storage or transmission."
                        },
                        "keyPoints": [
                            "Date + Time + Zone offset + Zone rules",
                            "Handles DST transitions automatically",
                            "Use withZoneSameInstant to convert between timezones",
                            "Convert to Instant for absolute timestamps (database storage)"
                        ],
                        "extras": {
                            "flowDiagram": "ZonedDateTime (NY 9:00 AM EST)\n    ↓ withZoneSameInstant(London)\nZonedDateTime (London 2:00 PM GMT)\n    ↓\nInstant (same absolute time)",
                            "comparisonTable": "Method|Effect\nwithZoneSameInstant|Convert time to show same moment in new zone\nwithZoneSameLocal|Change zone but keep same clock digits\nofInstant|Create from Instant + ZoneId\ntoInstant|Convert to absolute timestamp",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-6-4",
                        "title": "Formatting & Parsing",
                        "explanations": {
                            "english": "DateTimeFormatter provides thread-safe formatting and parsing for java.time objects, replacing the non-thread-safe SimpleDateFormat. Predefined formats include ISO_LOCAL_DATE ('2024-03-15'), ISO_LOCAL_DATE_TIME, and ISO_ZONED_DATE_TIME. Custom patterns use symbols like yyyy (year), MM (month), dd (day), HH (hour), mm (minute), ss (second), and a (am/pm). The formatter can perform case-sensitive parsing and strict/resolver styles. DateTimeFormatterBuilder allows building complex formatters with optional sections and literal text. For localized formatting, use ofLocalizedDate(), ofLocalizedTime(), or ofLocalizedDateTime() with FormatStyle (FULL, LONG, MEDIUM, SHORT). Parsing uses parse() methods with or without explicit formatter (defaults to ISO)."
                        },
                        "code": {
                            "title": "DateTimeFormatter Usage",
                            "language": "java",
                            "content": "// Predefined formatters\nLocalDate date = LocalDate.now();\nString iso = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2024-03-15\n\n// Custom pattern\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\n    \"EEEE, MMMM d, yyyy\", // Thursday, March 15, 2024\n    Locale.US\n);\nString formatted = date.format(formatter);\n\n// Parsing with pattern\nLocalDate parsed = LocalDate.parse(\n    \"15/03/2024\", \n    DateTimeFormatter.ofPattern(\"dd/MM/yyyy\")\n);\n\n// Zoned formatting\nZonedDateTime zdt = ZonedDateTime.now();\nString zonedStr = zdt.format(DateTimeFormatter.RFC_1123_DATE_TIME);\n\n// Localized\nString localized = date.format(\n    DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL)\n    .withLocale(Locale.FRANCE)\n);\n\n// Builder for complex patterns\nDateTimeFormatter complex = new DateTimeFormatterBuilder()\n    .appendText(ChronoField.YEAR)\n    .appendLiteral(\" year, \")\n    .appendText(ChronoField.MONTH_OF_YEAR)\n    .toFormatter();"
                        },
                        "codeExplanations": {
                            "english": "DateTimeFormatter.ofPattern creates formatters with custom patterns (case sensitive: MM=month, mm=minute). Always specify Locale for month/day names. Parsing with parse() requires the string to match the pattern exactly. ofLocalizedDate uses locale-specific conventions. DateTimeFormatterBuilder provides fine-grained control for complex requirements. All java.time formatters are immutable and thread-safe, unlike SimpleDateFormat."
                        },
                        "keyPoints": [
                            "Thread-safe (unlike SimpleDateFormat)",
                            "Predefined ISO formatters available",
                            "Custom patterns: yyyy-MM-dd HH:mm:ss",
                            "Always specify Locale for localized text"
                        ],
                        "extras": {
                            "flowDiagram": "Temporal Object → Formatter.format() → String\nString → Formatter.parse() → Temporal Object",
                            "comparisonTable": "Pattern|Meaning\nyyyy|4-digit year\nMM|Month number (01-12)\ndd|Day of month (01-31)\nHH|Hour (00-23)\nmm|Minute (00-59)\nss|Second (00-59)\na|AM/PM marker",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-7-1",
                        "title": "When to Use Parallel Streams",
                        "explanations": {
                            "english": "Parallel streams provide performance benefits only under specific conditions: large data sources (typically over 10,000-100,000 elements depending on operation complexity), CPU-intensive operations (complex math, object creation), and stateless, side-effect-free operations. They degrade performance for small collections due to task-splitting overhead, for I/O-bound operations (blocking the common pool), or when encounter-order is required (costly to maintain in parallel). Stateless operations (filter, map) parallelize well; stateful operations (distinct, sorted) require additional coordination. Source structures matter: ArrayList, IntStream.range, and arrays split efficiently; Stream.iterate, Stream.of, and LinkedList split poorly. Always measure performance before and after parallelization; anecdotal assumptions about speedups are often wrong due to poor decomposition or cache contention."
                        },
                        "code": {
                            "title": "Parallel Decision Guide",
                            "language": "java",
                            "content": "// GOOD: Large data, CPU intensive\nlong count = IntStream.range(0, 10_000_000)\n    .parallel()\n    .filter(this::isPrime)\n    .count();\n\n// GOOD: Stateless operations on good source\nList<Integer> result = largeArrayList.parallelStream()\n    .map(this::expensiveComputation)\n    .collect(Collectors.toList());\n\n// BAD: Too small\nList<Integer> small = Arrays.asList(1, 2, 3);\nsmall.parallelStream().map(n -> n * 2); // Overhead exceeds benefit\n\n// BAD: Stateful/ordered expensive operations\nStream.iterate(0, n -> n + 1)\n    .limit(1000)\n    .parallel() // Bad: iterate doesn't split well\n    .distinct() // Expensive in parallel\n    .collect(Collectors.toList());\n\n// BAD: I/O blocking\nurls.parallelStream() // Blocks common pool!\n    .map(this::fetchUrl)\n    .collect(Collectors.toList());"
                        },
                        "codeExplanations": {
                            "english": "The good examples show large datasets with CPU-intensive operations (isPrime checking, expensive transformation). The bad examples demonstrate: small collections where splitting overhead dominates, Stream.iterate which creates poor splitting structure (sequential dependency), and blocking I/O which starves the ForkJoinPool. Parallel streams use the common ForkJoinPool (thread count = CPU cores), so blocking operations freeze all parallel streams in the application."
                        },
                        "keyPoints": [
                            "Use for: Large datasets (>10k elements), CPU-intensive operations",
                            "Avoid for: Small collections, blocking I/O, stateful ops (sorted, distinct), poor sources (iterate, linked lists)",
                            "Measure performance; parallel is not automatically faster",
                            "Side-effect-free operations only"
                        ],
                        "extras": {
                            "flowDiagram": "Large Data + CPU Bound + Stateless = Good for Parallel\nSmall Data + IO Bound + Stateful (sort) = Bad for Parallel",
                            "comparisonTable": "Factor|Good for Parallel|Bad for Parallel\nData Size|Large (>10k)|Small (<1k)\nOperation|Computation heavy|Simple, fast\nSource|ArrayList, arrays, IntStream.range|LinkedList, Stream.iterate, Stream.of\nState|Stateless|Stateful (distinct, sorted)",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-7-2",
                        "title": "Performance Considerations",
                        "explanations": {
                            "english": "Parallel stream performance depends on NQ model: the product of data size (N) and computation cost per element (Q) must be high enough to overcome splitting overhead (typically N*Q > 10,000). Poorly decomposable sources (iterators, linked lists, Stream.of) create imbalanced splits where threads wait idle. Boxing primitives (Stream<Integer> vs IntStream) causes memory overhead and cache misses; always use primitive streams (IntStream, LongStream) for numeric computation. Interference (modifying stream source during operation) causes ConcurrentModificationException or wrong results. Stateless side-effect-free lambdas allow optimal parallelization; stateful lambdas (synchronized, modifying shared variables) create contention that eliminates parallelism benefits. The ForkJoinPool.common.parallelism (default CPU count - 1) limits concurrent threads available for all parallel streams in the JVM."
                        },
                        "code": {
                            "title": "Performance Optimization",
                            "language": "java",
                            "content": "// Good: Primitive stream avoids boxing\nint sum = IntStream.range(0, 1_000_000)\n    .parallel()\n    .map(n -> n * n)\n    .sum();\n\n// Bad: Boxing overhead\nStream<Integer> boxed = IntStream.range(0, 1_000_000)\n    .boxed(); // Avoid if possible in parallel\n\n// Bad: Contended shared state\nList<Integer> results = new ArrayList<>();\nIntStream.range(0, 1000).parallel()\n    .forEach(results::add); // Race conditions, resizing overhead\n\n// Good: Proper merging with collect\nList<Integer> resultsSafe = IntStream.range(0, 1000).parallel()\n    .mapToObj(n -> n)\n    .collect(Collectors.toList()); // Thread-safe merging\n\n// Bad: LinkedList splitting\nLinkedList<Integer> linked = new LinkedList<>(largeList);\nlinked.parallelStream() // Splits poorly, cache misses\n    .map(...) \n    .collect();\n\n// Good: ArrayList splitting\nArrayList<Integer> array = new ArrayList<>(largeList);\narray.parallelStream() // Splits evenly, cache friendly\n    .map(...)\n    .collect();"
                        },
                        "codeExplanations": {
                            "english": "Primitive IntStream avoids Integer boxing overhead. Collectors handle thread-safe merging of partial results from parallel threads efficiently. forEach with concurrent collection modification causes thread-safety issues; collect is proper for parallel gathering. ArrayList splits evenly by index ranges, while LinkedList requires traversal to split, creating uneven work distribution and poor cache locality."
                        },
                        "keyPoints": [
                            "Use primitive streams (IntStream) to avoid boxing overhead",
                            "Ensure N*Q (size * cost) > 10,000 for benefit",
                            "Avoid shared mutable state in lambdas",
                            "Use ArrayList/arrays not LinkedList for sources",
                            "Use collect() not forEach() for aggregating parallel results"
                        ],
                        "extras": {
                            "flowDiagram": "Parallel Stream Splitting:\nArrayList [0-999] → [0-499], [500-999] → Fast split\nLinkedList → Must traverse to find middle → Slow split",
                            "comparisonTable": "Aspect|Impact|Solution\nBoxing|Memory/cache overhead|Use IntStream/LongStream\nBad split|Uneven work|Use ArrayList, arrays\nShared state|Contention|Pure functions only\nWrong terminal|Missed optimizations|Use reduce, collect not forEach",
                            "examples": []
                        }
                    },
                    {
                        "id": "s6-7-3",
                        "title": "Common Pitfalls",
                        "explanations": {
                            "english": "Common parallel stream pitfalls include modifying the stream source during traversal (ConcurrentModificationException), using thread-unsafe operations in forEach (race conditions), and assuming automatic speedup without measuring. Blocking operations (I/O, sleep) in parallel streams monopolize the ForkJoinPool, starving other parallel streams in the application—a critical issue in web servers. Tasks that are too small create more splitting overhead than computation benefit. Non-associative reduce operations (subtraction, string concatenation without ordering) produce wrong results in parallel since operation order is not guaranteed. Assuming encounter order is preserved cheaply in parallel (it's expensive for ordered streams like Stream.of or List.stream); use forEachOrdered sparingly. Debugging parallel streams is harder than sequential due to indeterminate ordering and concurrent modifications."
                        },
                        "code": {
                            "title": "Avoiding Pitfalls",
                            "language": "java",
                            "content": "// PITFALL 1: Modifying source during stream\nList<Integer> list = new ArrayList<>...\nlist.parallelStream()\n    .forEach(list::remove); // ConcurrentModificationException!\n\n// PITFALL 2: Non-associative reduce\nint wrong = IntStream.range(0, 10).parallel()\n    .reduce(0, (a, b) -> a - b); // (0-1-2-3...) order undefined result!\n\n// PITFALL 3: Blocking common pool\nList<String> data = fetchUrls();\ndata.parallelStream()\n    .map(url -> fetchFromNetwork(url)) // Blocks all parallel streams!\n    .collect(Collectors.toList());\n\n// Solution: Custom ForkJoinPool for blocking\nForkJoinPool custom = new ForkJoinPool(2);\ntry {\n    custom.submit(() ->\n        data.parallelStream().map(...).collect(...)\n    ).get();\n} finally {\n    custom.shutdown();\n}\n\n// PITFALL 4: forEachOrdered overhead\nStream.of(\"a\", \"b\", \"c\").parallel()\n    .map(...) // Parallel\n    .forEachOrdered(System.out::println); // Expensive reorder barrier"
                        },
                        "codeExplanations": {
                            "english": "Modifying a list while iterating it in a stream causes ConcurrentModificationException even in parallel. Subtraction is not associative (a-b-c != (a-b)-c), so parallel reduction gives wrong answers. Network calls should not use the common ForkJoinPool as they block threads needed by other parallel streams; use a custom pool with limited threads. forEachOrdered imposes expensive synchronization to maintain order, defeating parallel performance."
                        },
                        "keyPoints": [
                            "Never modify stream source during operation",
                            "Ensure reduce operations are associative and stateless",
                            "Never block in common pool (I/O, sleep); use custom ForkJoinPool",
                            "Avoid forEachOrdered unless absolutely necessary",
                            "Measure performance; don't assume parallel is faster"
                        ],
                        "extras": {
                            "flowDiagram": "Parallel Stream Pitfalls:\nSource modification → ConcurrentModificationException\nNon-associative reduce → Wrong result\nBlocking in common pool → Starvation of other streams\nforEachOrdered → Performance degradation (synchronization)",
                            "comparisonTable": "Pitfall|Symptom|Solution\nSource modification|ConcurrentModificationException|Filter instead of remove\nNon-associative reduce|Incorrect calculation|Use associative ops (sum, min)\nBlocking I/O|System slowdown|Custom ForkJoinPool\nforEachOrdered|Slow performance|Use forEach if order not required",
                            "examples": []
                        }
                    }
                ]
            }
        ]
    }
]