[
  {
  "id": "spring-boot-core-di-2026",
  "category": "Backend Development",
  "title": "Core Spring Boot & Dependency Injection Mastery",
  "subtitle": "Build production-ready Java applications with Spring Boot's magic and master Spring's dependency injection patterns",
  "icon": "spring",
  "stats": [
    {
      "label": "Topics",
      "value": "25",
      "icon": "book-open"
    },
    {
      "label": "Sections",
      "value": "2",
      "icon": "layers"
    },
    {
      "label": "Difficulty",
      "value": "Beginner to Intermediate",
      "icon": "star"
    }
  ],
  "sections": [
    {
      "id": "core-spring-boot-section",
      "title": "Core Spring Boot üå±",
      "intro": "Discover how Spring Boot eliminates boilerplate configuration through smart conventions, embedded servers, and auto-magic setup‚Äîletting you focus on business logic from day one.",
      "topics": [
        {
          "id": "springapplication-annotation",
          "title": "SpringApplication & @SpringBootApplication üöÄ",
          "explanations": {
            "english": "SpringApplication is the entry point that bootstraps your Spring Boot app. The @SpringBootApplication annotation is a powerful shortcut combining three critical annotations: @Configuration (marks class as bean source), @EnableAutoConfiguration (triggers Spring Boot's auto-setup magic based on dependencies), and @ComponentScan (scans current package + sub-packages for components). Place your main class in the root package to ensure all components are discovered.",
            "hinglish": "SpringApplication aapke app ko shuru karta hai‚Äîyeh entry point hota hai. @SpringBootApplication ek smart shortcut hai jo teen kaam ek saath karta hai: @Configuration (class ko bean banane ka source batata hai), @EnableAutoConfiguration (classpath ke dependencies dekhte hue khud-ba-khud settings karta hai), aur @ComponentScan (current folder aur uske andar ke folders mein components dhundhta hai). Apne main class ko root package mein rakho taaki sab kuch automatically mil sake."
          },
          "code": {
            "title": "Minimal Spring Boot Application",
            "language": "java",
            "content": "import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication // Combines @Configuration, @EnableAutoConfiguration, @ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}"
          },
          "codeExplanations": {
            "english": "This single class launches a full Spring Boot app. @SpringBootApplication enables auto-configuration and component scanning. SpringApplication.run() initializes the IoC container, starts embedded server, and triggers startup events.",
            "hinglish": "Yeh ek hi class poora Spring Boot app launch karti hai. @SpringBootApplication auto-configuration aur component scanning ON karta hai. SpringApplication.run() IoC container banata hai, embedded server chalata hai, aur startup events trigger karta hai."
          },
          "keyPoints": [
            "Always place @SpringBootApplication in the root package for proper component scanning",
            "SpringApplication.run() returns ApplicationContext‚Äîuseful for programmatic bean access",
            "Customize startup with SpringApplication methods (e.g., setBannerMode, addListeners)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "auto-configuration",
          "title": "Auto-Configuration Magic ‚ú®",
          "explanations": {
            "english": "Spring Boot analyzes your classpath at startup and automatically configures beans you're likely to need. If H2 database is in dependencies, it configures an in-memory datasource. If Spring Web is present, it sets up embedded Tomcat + MVC. This 'convention over configuration' reduces boilerplate dramatically. Override any auto-configured bean by defining your own bean of the same type.",
            "hinglish": "Startup time par Spring Boot aapke classpath ko scan karta hai aur khud-ba-khud woh beans configure karta hai jo aapko zaroorat padegi. Agar dependencies mein H2 database hai, toh automatic in-memory datasource ban jata hai. Agar Spring Web hai, toh embedded Tomcat + MVC setup ho jata hai. Yeh 'convention over configuration' ka principle hai‚Äîbohot saara manual code bachata hai. Kisi bhi auto-configured bean ko override karne ke liye, bas usi type ka apna bean banao."
          },
          "code": {
            "title": "View Auto-Configuration Report",
            "language": "properties",
            "content": "# Add to application.properties to see auto-config details at startup\ndebug=true"
          },
          "codeExplanations": {
            "english": "Setting debug=true prints a detailed report showing which auto-configurations were applied ('positive matches') and skipped ('negative matches') with reasons. Essential for debugging configuration issues.",
            "hinglish": "debug=true karne se startup par detailed report print hoti hai‚Äîdikhata hai konsi auto-configurations apply hui ('positive matches') aur konsi skip hui ('negative matches') aur kyun. Configuration issues debug karne ke liye zaroori."
          },
          "keyPoints": [
            "Auto-configuration happens AFTER user-defined beans are registered",
            "Use @Conditional annotations (e.g., @ConditionalOnClass) to control auto-config behavior",
            "Exclude specific auto-configurations via @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "starter-dependencies",
          "title": "Starter Dependencies üì¶",
          "explanations": {
            "english": "Starter dependencies are curated dependency descriptors that bundle commonly used libraries for specific functionalities. Instead of manually adding 10+ dependencies for web apps (Spring MVC, Tomcat, Jackson, etc.), just include spring-boot-starter-web. Starters ensure compatible versions and reduce pom.xml clutter. They follow naming convention: spring-boot-starter-* (core starters) or third-party starters like mybatis-spring-boot-starter.",
            "hinglish": "Starter dependencies predefined groups hain jo kisi specific kaam ke liye zaroori libraries ko ek saath jodte hain. Web app banane ke liye manually 10+ dependencies add karne ki jagah, bas spring-boot-starter-web add karo. Starters compatible versions guarantee karte hain aur pom.xml ko clean rakhte hain. Naam hamesha spring-boot-starter-* pattern follow karta hai (jaise spring-boot-starter-data-jpa)."
          },
          "code": {
            "title": "Maven Starter Example",
            "language": "xml",
            "content": "<!-- Instead of adding 15+ individual dependencies -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<!-- Includes: Spring MVC, Tomcat, Jackson, Validation, etc. -->"
          },
          "codeExplanations": {
            "english": "This single dependency pulls in all required libraries for building RESTful web services with embedded Tomcat. Spring Boot's dependency management ensures all transitive dependencies use compatible versions‚Äîno version numbers needed in your pom.xml.",
            "hinglish": "Yeh ek dependency RESTful services banane ke liye zaroori saari libraries (Spring MVC, Tomcat, Jackson) automatically laati hai. Spring Boot dependency management compatible versions guarantee karta hai‚Äîpom.xml mein version numbers likhne ki zaroorat nahi."
          },
          "keyPoints": [
            "Starters NEVER contain code‚Äîonly dependency metadata",
            "Create custom starters for internal enterprise patterns",
            "Use spring-boot-starter-parent for consistent dependency management"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Without Starter",
                "column2": "With Starter"
              },
              {
                "column1": "Manually add 10+ dependencies",
                "column2": "Single dependency declaration"
              },
              {
                "column1": "Version conflicts likely",
                "column2": "Pre-tested compatible versions"
              },
              {
                "column1": "Verbose pom.xml",
                "column2": "Clean, readable pom.xml"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "embedded-servers",
          "title": "Embedded Servers üñ•Ô∏è",
          "explanations": {
            "english": "Spring Boot apps include embedded servers (Tomcat, Jetty, or Netty) packaged directly inside the JAR. No need to deploy WAR files to external servers. The server starts automatically when you run the JAR. This enables true microservices architecture‚Äîeach service is a standalone executable with its own server. Switch servers by excluding default starter and including another (e.g., replace Tomcat with Jetty).",
            "hinglish": "Spring Boot apps ke andar hi server (Tomcat, Jetty, ya Netty) packaged hota hai‚ÄîJAR file ke andar. External server par WAR deploy karne ki zaroorat nahi. JAR run karte hi server khud start ho jata hai. Har microservice ek alag executable JAR hota hai apne server ke saath. Server badalne ke liye default starter exclude karo aur naya include karo (jaise Tomcat ki jagah Jetty)."
          },
          "code": {
            "title": "Switch from Tomcat to Jetty",
            "language": "xml",
            "content": "<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-tomcat</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jetty</artifactId>\n</dependency>"
          },
          "codeExplanations": {
            "english": "Excludes Tomcat starter from spring-boot-starter-web and adds Jetty starter instead. Spring Boot auto-configuration detects Jetty on classpath and configures it automatically. No XML or server config files needed.",
            "hinglish": "spring-boot-starter-web se Tomcat ko exclude karo aur Jetty starter add karo. Spring Boot classpath mein Jetty dekhte hi use automatically configure kar dega. Kisi bhi XML ya server config file ki zaroorat nahi."
          },
          "keyPoints": [
            "Default embedded server for spring-boot-starter-web is Tomcat",
            "spring-boot-starter-webflux uses Netty by default for reactive apps",
            "Customize server port via server.port=8081 in application.properties"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "embedded-tomcat",
          "title": "Tomcat (Servlet Stack) üåê",
          "explanations": {
            "english": "Tomcat is the default embedded servlet container for traditional Spring MVC applications (blocking I/O). Used when including spring-boot-starter-web. Handles HTTP requests synchronously‚Äîeach request uses a dedicated thread. Ideal for CRUD apps, REST APIs with moderate traffic. Configure thread pool, connection timeouts, and SSL directly through Spring Boot properties without touching server.xml.",
            "hinglish": "Tomcat traditional Spring MVC apps (blocking I/O) ke liye default embedded server hai. spring-boot-starter-web include karne par automatically aata hai. Har HTTP request ke liye alag thread use karta hai. CRUD apps aur REST APIs ke liye perfect hai. Thread pool, timeouts, SSL jaise settings Spring Boot properties se karo‚Äîserver.xml edit karne ki zaroorat nahi."
          },
          "code": {
            "title": "Customize Tomcat via Properties",
            "language": "properties",
            "content": "server.port=9090\nserver.tomcat.threads.min-spare=10\nserver.tomcat.threads.max=200\nserver.tomcat.connection-timeout=5s\nserver.ssl.key-store=classpath:keystore.p12"
          },
          "codeExplanations": {
            "english": "All Tomcat settings are exposed through server.tomcat.* properties. Spring Boot maps these directly to Tomcat's internal configuration‚Äîno low-level server tweaks needed. Changes take effect on restart.",
            "hinglish": "Saare Tomcat settings server.tomcat.* properties ke through control hote hain. Spring Boot inhe directly Tomcat ke internal settings se jodta hai‚Äîmanual server configuration ki zaroorat nahi. Changes restart karne par lagu hote hain."
          },
          "keyPoints": [
            "Tomcat is servlet-based (Jakarta Servlet API)",
            "Best for synchronous, thread-per-request architectures",
            "Access Tomcat-specific config via WebServerFactoryCustomizer bean"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "embedded-netty",
          "title": "Netty (Reactive Stack) ‚ö°",
          "explanations": {
            "english": "Netty is a non-blocking, event-driven network application framework used as the default embedded server for Spring WebFlux (reactive stack). Handles thousands of concurrent connections with minimal threads using event loops. Ideal for high-I/O apps: real-time dashboards, chat apps, streaming services. Included automatically via spring-boot-starter-webflux‚Äîno manual setup needed.",
            "hinglish": "Netty ek non-blocking, event-driven framework hai jo Spring WebFlux (reactive apps) ke liye default server hai. Event loops use karke kam threads mein hazaaron connections handle karta hai. Real-time dashboards, chat apps, streaming jaise high-I/O apps ke liye perfect. spring-boot-starter-webflux include karte hi automatically aata hai‚Äîkuch setup nahi karna padta."
          },
          "code": {
            "title": "Reactive Controller using Netty",
            "language": "java",
            "content": "@RestController\npublic class ReactiveController {\n    \n    @GetMapping(\"/events\")\n    public Flux<Event> streamEvents() {\n        return Flux.interval(Duration.ofSeconds(1))\n                   .map(i -> new Event(\"Event-\" + i));\n    }\n}"
          },
          "codeExplanations": {
            "english": "This controller streams events continuously using reactive types (Flux). Netty efficiently handles the persistent connection without blocking threads. Spring Boot auto-configures Netty when spring-boot-starter-webflux is on classpath.",
            "hinglish": "Yeh controller reactive types (Flux) use karke continuous events stream karta hai. Netty connection ko bina threads block kiye efficiently handle karta hai. Jab classpath mein spring-boot-starter-webflux hota hai, Spring Boot khud-ba-khud Netty configure kar deta hai."
          },
          "keyPoints": [
            "Netty powers Spring WebFlux's non-blocking I/O model",
            "Uses event loop threads instead of thread-per-request",
            "Monitor Netty metrics via Micrometer (e.g., netty.connections.active)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "configuration-files",
          "title": "Configuration Files üìÑ",
          "explanations": {
            "english": "Spring Boot supports externalized configuration via application.properties or application.yml files. These live in src/main/resources and override embedded defaults. Configuration is hierarchical: command-line args > profile-specific files > application.yml > application.properties > defaults. Use profiles (application-dev.yml) for environment-specific settings. Values inject into beans via @Value or @ConfigurationProperties.",
            "hinglish": "Spring Boot external configuration ke liye application.properties ya application.yml files support karta hai. Ye src/main/resources mein hote hain aur default settings ko override karte hain. Configuration hierarchical hota hai: command-line args > profile files > application.yml > defaults. Har environment ke liye alag profile (jaise application-prod.yml) banao. Values beans mein @Value ya @ConfigurationProperties se inject karo."
          },
          "code": {
            "title": "Configuration Hierarchy Example",
            "language": "text",
            "content": "Priority order (highest to lowest):\n1. Command line arguments (--server.port=8081)\n2. SPRING_APPLICATION_JSON environment variable\n3. Profile-specific files (application-prod.properties)\n4. application.properties / application.yml\n5. @PropertySource annotations\n6. Default properties"
          },
          "codeExplanations": {
            "english": "Spring Boot merges configurations from all sources following this priority order. Higher priority sources override lower ones. Profile-specific files (e.g., application-dev.yml) load only when active profile matches (set via spring.profiles.active=dev).",
            "hinglish": "Spring Boot saare sources se configuration merge karta hai is priority ke hisaab se. Upar wala source neeche wale ko override karta hai. Profile-specific files tabhi load hote hain jab active profile match kare (spring.profiles.active=dev se set karo)."
          },
          "keyPoints": [
            "YAML supports hierarchical structure and profiles in single file",
            "Encrypt sensitive values using Spring Cloud Config or Jasypt",
            "Reload config at runtime with @RefreshScope (Spring Cloud)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "application-properties",
          "title": "application.properties üîë",
          "explanations": {
            "english": "Simple key-value pair format (.properties). Easy for flat configurations. Comments start with #. Supports placeholders (${other.property}). Ideal for small projects or teams preferring simplicity. Spring Boot auto-loads this file at startup. Override values via environment variables (replace dots with underscores: SERVER_PORT=9000).",
            "hinglish": "Simple key=value format (.properties file). Flat settings ke liye aasan. Comments # se shuru hote hain. Placeholders support karta hai (${other.property}). Chhote projects ya simplicity pasand karne wali teams ke liye best. Spring Boot startup par ise automatically load karta hai. Environment variables se values override karo (dots ko underscores se badlo: SERVER_PORT=9000)."
          },
          "code": {
            "title": "Sample application.properties",
            "language": "properties",
            "content": "# Server settings\nserver.port=8080\nserver.servlet.context-path=/api\n\n# Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\n\n# Custom property\napp.version=1.0.0\n\n# Placeholder usage\nlogging.file.name=${app.name}.log"
          },
          "codeExplanations": {
            "english": "Each line defines a configuration property. Spring Boot maps prefixes (server.*, spring.datasource.*) to auto-configuration classes. Custom properties (app.version) can be injected into beans. Comments improve readability.",
            "hinglish": "Har line ek configuration property define karti hai. Spring Boot prefixes (server.*, spring.datasource.*) ko auto-configuration classes se jodta hai. Custom properties (app.version) beans mein inject kiye ja sakte hain. Comments readability badhate hain."
          },
          "keyPoints": [
            "Use # for comments and ! for disabling lines",
            "Escape special characters with backslash (e.g., Windows paths)",
            "Profile-specific version: application-dev.properties"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "application-yml",
          "title": "application.yml üìú",
          "explanations": {
            "english": "YAML (YAML Ain't Markup Language) uses indentation for hierarchy. More readable for nested structures (like logging or datasource configs). Supports multiple profiles in single file using --- separator. Sensitive to indentation‚Äîuse spaces (not tabs). Spring Boot prefers application.yml over .properties if both exist. Ideal for complex configurations with many nested properties.",
            "hinglish": "YAML indentation use karke hierarchy dikhata hai. Nested settings (jaise logging ya datasource) ke liye padhne mein aasan. Ek file mein multiple profiles --- separator se banaye ja sakte hain. Indentation ke liye spaces use karo (tabs nahi). Agar dono files hain, Spring Boot application.yml ko priority dega. Complex configurations ke liye perfect."
          },
          "code": {
            "title": "Sample application.yml with Profiles",
            "language": "yaml",
            "content": "spring:\n  application:\n    name: user-service\n  datasource:\n    url: jdbc:postgresql://localhost:5432/devdb\n    username: devuser\n\n---\nspring:\n  config:\n    activate:\n      on-profile: prod\n  datasource:\n    url: jdbc:postgresql://prod-db:5432/proddb\n    username: ${DB_USER}\n    password: ${DB_PASSWORD}"
          },
          "codeExplanations": {
            "english": "Hierarchical structure groups related properties. The --- separator defines profile-specific sections. In prod profile, datasource uses environment variables for security. YAML's readability shines with deeply nested configs.",
            "hinglish": "Indentation se related properties group hote hain. --- separator profile-specific sections define karta hai. Prod profile mein datasource security ke liye environment variables use karta hai. YAML complex configurations ko clean dikhata hai."
          },
          "keyPoints": [
            "Always use spaces for indentation (2 or 4 spaces)",
            "String values with special chars should be quoted",
            "Validate YAML syntax using online parsers before deployment"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "application.properties",
                "column2": "application.yml"
              },
              {
                "column1": "Flat key-value pairs",
                "column2": "Hierarchical structure"
              },
              {
                "column1": "Better for simple configs",
                "column2": "Better for nested configs"
              },
              {
                "column1": "No profile separation in single file",
                "column2": "Multiple profiles in one file"
              }
            ],
            "examples": []
          }
        }
      ]
    },
    {
      "id": "spring-core-di-section",
      "title": "Spring Core & Dependency Injection üíâ",
      "intro": "Master the heart of Spring Framework: the IoC container and Dependency Injection. Learn how Spring manages object creation, wiring, and lifecycle to build loosely coupled, testable applications.",
      "topics": [
        {
          "id": "ioc-container",
          "title": "IoC Container üß†",
          "explanations": {
            "english": "The Inversion of Control (IoC) container is Spring's core engine. Instead of your code creating objects (new UserService()), the container creates and manages them ('beans'). You declare dependencies, and the container injects them. This inverts control‚Äîyour classes don't manage dependencies; the framework does. Two container implementations: BeanFactory (basic) and ApplicationContext (advanced, with AOP, events, i18n). Spring Boot uses AnnotationConfigServletWebServerApplicationContext.",
            "hinglish": "IoC container Spring ka dil hai. Aapke code ke bajaye container objects ('beans') banata aur manage karta hai. Aap dependencies batate ho, container unhe inject karta hai. Control ulta ho jata hai‚Äîab aapke classes dependencies manage nahi karti, framework karta hai. Do types ke containers: BeanFactory (basic) aur ApplicationContext (advanced, AOP, events ke saath). Spring Boot AnnotationConfigServletWebServerApplicationContext use karta hai."
          },
          "code": {
            "title": "Container Initialization in Spring Boot",
            "language": "java",
            "content": "// Spring Boot automatically creates ApplicationContext\n@SpringBootApplication\npublic class App {\n    public static void main(String[] args) {\n        // Returns fully initialized ApplicationContext\n        ConfigurableApplicationContext context = \n            SpringApplication.run(App.class, args);\n        \n        // Get bean manually (rarely needed)\n        UserService userService = context.getBean(UserService.class);\n    }\n}"
          },
          "codeExplanations": {
            "english": "SpringApplication.run() bootstraps the ApplicationContext. All beans are created, dependencies injected, and lifecycle callbacks triggered before main() continues. Manual getBean() is discouraged‚Äîprefer constructor injection.",
            "hinglish": "SpringApplication.run() ApplicationContext banata hai. Saare beans bante hain, dependencies inject hoti hain, lifecycle callbacks chalte hain‚Äîphir main() aage badhta hai. getBean() manually use karna avoid karo‚Äîconstructor injection behtar hai."
          },
          "keyPoints": [
            "ApplicationContext is the central interface to the Spring IoC container",
            "Beans are singleton by default (one instance per container)",
            "Container manages full bean lifecycle: instantiation ‚Üí dependency injection ‚Üí initialization ‚Üí destruction"
          ],
          "extras": {
            "flowDiagram": "Application Start\n     ‚Üì\nCreate ApplicationContext\n     ‚Üì\nScan @Components\n     ‚Üì\nInstantiate Beans\n     ‚Üì\nInject Dependencies\n     ‚Üì\nCall @PostConstruct\n     ‚Üì\nApplication Ready",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "bean-lifecycle",
          "title": "Bean Lifecycle üîÑ",
          "explanations": {
            "english": "Spring manages beans through a predictable lifecycle: 1) Instantiate bean (via constructor), 2) Populate properties (dependency injection), 3) Call BeanPostProcessor.postProcessBeforeInitialization(), 4) Call @PostConstruct or InitializingBean.afterPropertiesSet(), 5) Bean is ready for use, 6) On shutdown: Call @PreDestroy or DisposableBean.destroy(), 7) Call BeanPostProcessor.postProcessAfterInitialization(). Use lifecycle callbacks for resource setup/cleanup (DB connections, thread pools).",
            "hinglish": "Spring beans ko ek fixed cycle mein manage karta hai: 1) Bean banana (constructor se), 2) Properties bharna (dependencies inject karna), 3) @PostConstruct method call karna, 4) Bean ready ho jata hai, 5) Shutdown par @PreDestroy call karna. Resource setup/cleanup (DB connections) ke liye in callbacks ka use karo."
          },
          "code": {
            "title": "Bean with Lifecycle Callbacks",
            "language": "java",
            "content": "@Component\npublic class DatabaseConnection {\n    \n    @PostConstruct\n    public void init() {\n        System.out.println(\"Opening DB connection...\");\n        // Initialize connection pool\n    }\n    \n    @PreDestroy\n    public void cleanup() {\n        System.out.println(\"Closing DB connection...\");\n        // Release resources\n    }\n}"
          },
          "codeExplanations": {
            "english": "@PostConstruct runs after dependencies are injected but before bean is used. @PreDestroy runs during container shutdown. These JSR-250 annotations are preferred over implementing InitializingBean/DisposableBean interfaces.",
            "hinglish": "@PostConstruct dependencies inject hone ke baad aur bean use hone se pehle chalta hai. @PreDestroy container band hone par chalta hai. JSR-250 annotations interfaces implement karne se behtar hain."
          },
          "keyPoints": [
            "Use @PostConstruct for initialization logic (not constructor)",
            "Implement SmartLifecycle for beans needing startup/shutdown control",
            "BeanPostProcessor allows custom logic around initialization"
          ],
          "extras": {
            "flowDiagram": "Instantiate Bean\n       ‚Üì\n   Inject Dependencies\n       ‚Üì\n@PostConstruct / afterPropertiesSet\n       ‚Üì\n   Bean Ready (in use)\n       ‚Üì\n@PreDestroy / destroy (on shutdown)",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "dependency-injection-concept",
          "title": "Dependency Injection Concept üí°",
          "explanations": {
            "english": "Dependency Injection (DI) is a design pattern where objects receive dependencies from an external source (the IoC container) instead of creating them internally. This decouples components, making code modular, testable (inject mocks), and maintainable. Three injection types: Constructor (recommended), Setter, and Field injection. Spring resolves dependencies at runtime using type matching (and qualifiers if needed).",
            "hinglish": "Dependency Injection ek design pattern hai jahan objects apni dependencies khud nahi banate‚Äîcontainer unhe provide karta hai. Isse components alag ho jate hain, code test karna aasan ho jata hai (mocks inject karke), aur maintain karna aasan hota hai. Teen types: Constructor (sabse behtar), Setter, aur Field injection. Spring runtime par dependencies type dekhte hue match karta hai."
          },
          "code": {
            "title": "Constructor Injection (Preferred)",
            "language": "java",
            "content": "@Service\npublic class OrderService {\n    private final PaymentService paymentService;\n    private final InventoryService inventoryService;\n    \n    // Dependencies injected via constructor\n    public OrderService(PaymentService paymentService, \n                       InventoryService inventoryService) {\n        this.paymentService = paymentService;\n        this.inventoryService = inventoryService;\n    }\n    \n    public void placeOrder(Order order) {\n        // Business logic using injected dependencies\n    }\n}"
          },
          "codeExplanations": {
            "english": "Constructor injection makes dependencies explicit and immutable. Required dependencies are clear in the signature. Enables easier unit testing (pass mocks in constructor). Spring Boot 2.6+ requires constructor injection for circular dependencies resolution.",
            "hinglish": "Constructor injection dependencies ko clear aur permanent banata hai. Signature mein dikhta hai kya zaroori hai. Unit testing aasan hoti hai (constructor mein mocks pass karo). Circular dependencies solve karne ke liye Spring Boot 2.6+ constructor injection recommend karta hai."
          },
          "keyPoints": [
            "Constructor injection preferred for mandatory dependencies",
            "Field injection (@Autowired on field) is convenient but harder to test",
            "DI enables loose coupling‚Äîcomponents depend on abstractions, not concrete classes"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Tight Coupling: new PaymentService() inside OrderService ‚Üí hard to test",
              "Loose Coupling: PaymentService injected ‚Üí mock during tests"
            ]
          }
        },
        {
          "id": "autowired-annotation",
          "title": "@Autowired Annotation üîå",
          "explanations": {
            "english": "@Autowired tells Spring to inject a dependency automatically. Works on constructors, setter methods, fields, and config methods. Spring matches by type: if exactly one bean of the required type exists, it's injected. If multiple candidates exist, use @Qualifier to specify which bean to inject. Since Spring Boot 2.6, constructor injection doesn't require @Autowired if only one constructor exists.",
            "hinglish": "@Autowired Spring ko kahata hai ki dependency automatically inject karo. Constructor, setter, field, ya method par lagaya ja sakta hai. Spring type ke hisaab se match karta hai: agar sirf ek bean us type ka hai, toh woh inject ho jata hai. Agar multiple beans hain, toh @Qualifier use karo kaunsa bean chahiye. Spring Boot 2.6+ mein agar sirf ek constructor hai, toh @Autowired lagane ki zaroorat nahi."
          },
          "code": {
            "title": "@Autowired Usage Examples",
            "language": "java",
            "content": "// Constructor injection (no @Autowired needed in Spring Boot 2.6+)\n@Service\npublic class UserService {\n    private final UserRepository repo;\n    public UserService(UserRepository repo) {\n        this.repo = repo;\n    }\n}\n\n// Field injection (not recommended for testing)\n@Service\npublic class NotificationService {\n    @Autowired\n    private EmailService emailService;\n}\n\n// With @Qualifier when multiple beans exist\n@Service\npublic class PaymentProcessor {\n    @Autowired\n    @Qualifier(\"stripePaymentService\")\n    private PaymentService paymentService;\n}"
          },
          "codeExplanations": {
            "english": "First example shows modern constructor injection (annotation optional). Second shows field injection‚Äîsimple but creates hidden dependencies. Third resolves ambiguity using @Qualifier with bean name. Prefer constructor injection for clarity and testability.",
            "hinglish": "Pehla example modern constructor injection dikhata hai (annotation optional). Dusra field injection dikhata hai‚Äîsimple lekin dependencies chhupi rehti hain. Teesra @Qualifier use karke ambiguity solve karta hai. Clarity aur testability ke liye constructor injection behtar hai."
          },
          "keyPoints": [
            "@Autowired(required=false) allows optional dependencies",
            "Use constructor injection for required dependencies",
            "Field injection breaks encapsulation and complicates unit tests"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "stereotype-annotations",
          "title": "Stereotype Annotations üè∑Ô∏è",
          "explanations": {
            "english": "Stereotype annotations mark classes for automatic detection during classpath scanning. They provide semantic meaning beyond @Component: @Service (business logic layer), @Repository (data access layer with automatic SQLException translation), @Controller (Spring MVC web controller), @RestController (@Controller + @ResponseBody for REST APIs). All are meta-annotated with @Component‚Äîso they're automatically registered as beans.",
            "hinglish": "Stereotype annotations classes ko automatically detect karne ke liye mark karte hain. @Component se zyada meaning dete hain: @Service (business logic), @Repository (database layer, SQLException ko Spring exceptions mein badalta hai), @Controller (web requests handle karta hai), @RestController (REST APIs ke liye). Saare @Component ke upar banaye gaye hain‚Äîisliye automatically beans ban jate hain."
          },
          "code": {
            "title": "Layered Architecture with Stereotypes",
            "language": "java",
            "content": "@Repository\npublic class UserRepository { /* DB operations */ }\n\n@Service\npublic class UserService {\n    private final UserRepository repo;\n    // Constructor injection\n}\n\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    private final UserService service;\n    // Constructor injection\n}"
          },
          "codeExplanations": {
            "english": "@Repository enables automatic translation of JDBC exceptions to Spring's DataAccessException hierarchy. @RestController combines @Controller and @ResponseBody‚Äîmethods return domain objects directly serialized to JSON/XML. Stereotypes improve code readability and enable layer-specific features.",
            "hinglish": "@Repository JDBC exceptions ko Spring ke DataAccessException mein automatically badalta hai. @RestController @Controller aur @ResponseBody dono ka kaam karta hai‚Äîmethods directly JSON/XML return karte hain. Stereotypes code ko padhne mein aasan banate hain aur layer-specific features enable karte hain."
          },
          "keyPoints": [
            "@Repository provides exception translation for data access layers",
            "@RestController = @Controller + @ResponseBody (for REST endpoints)",
            "All stereotypes are detected by @ComponentScan"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Annotation",
                "column2": "Purpose"
              },
              {
                "column1": "@Component",
                "column2": "Generic Spring-managed bean"
              },
              {
                "column1": "@Service",
                "column2": "Business logic layer"
              },
              {
                "column1": "@Repository",
                "column2": "Data access layer (with exception translation)"
              },
              {
                "column1": "@Controller",
                "column2": "Web MVC controller (returns view names)"
              },
              {
                "column1": "@RestController",
                "column2": "REST API controller (returns data directly)"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "component-annotation",
          "title": "@Component Annotation üß©",
          "explanations": {
            "english": "@Component is the base stereotype annotation that marks a class as a Spring-managed bean. During component scanning, Spring detects all @Component classes (and its derivatives like @Service) and registers them as beans in the ApplicationContext. Use for utility classes, custom validators, or any generic Spring bean not fitting other stereotypes. Bean name defaults to camelCase class name (e.g., 'userHelper' for UserHelper class).",
            "hinglish": "@Component base annotation hai jo kisi class ko Spring-managed bean batata hai. Component scanning ke dauraan, Spring saare @Component classes ko dhundhta hai aur unhe ApplicationContext mein beans ke roop mein register karta hai. Utility classes, custom validators, ya kisi bhi generic bean ke liye use karo jo dusre stereotypes mein fit nahi karta. Bean ka naam default camelCase class name hota hai (jaise 'userHelper' UserHelper class ke liye)."
          },
          "code": {
            "title": "Custom Utility as Component",
            "language": "java",
            "content": "@Component\npublic class EmailValidator {\n    \n    public boolean isValid(String email) {\n        return email != null && email.contains(\"@\");\n    }\n}\n\n@Service\npublic class RegistrationService {\n    private final EmailValidator validator; // Injected automatically\n    \n    public RegistrationService(EmailValidator validator) {\n        this.validator = validator;\n    }\n}"
          },
          "codeExplanations": {
            "english": "EmailValidator is detected as a bean during scanning. RegistrationService receives it via constructor injection. No XML or manual registration needed‚Äîpure convention-based wiring. Bean name is 'emailValidator' (derived from class name).",
            "hinglish": "EmailValidator scanning ke dauraan bean ke roop mein detect hota hai. RegistrationService use constructor injection se receive karta hai. Kisi XML ya manual registration ki zaroorat nahi‚Äîsirf convention-based wiring. Bean ka naam 'emailValidator' hota hai."
          },
          "keyPoints": [
            "Base annotation for all Spring-managed components",
            "Bean name can be customized: @Component(\"customName\")",
            "Detected automatically when package is under @ComponentScan path"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "service-annotation",
          "title": "@Service Annotation üíº",
          "explanations": {
            "english": "@Service is a specialization of @Component for the service layer (business logic). It doesn't add technical functionality beyond @Component, but provides clear semantic meaning to developers and tools. Spring AOP can target @Service beans for transaction management (@Transactional). During component scanning, Spring treats it identically to @Component‚Äîbut your team instantly recognizes it as business logic.",
            "hinglish": "@Service @Component ka special version hai business logic layer ke liye. Technical functionality @Component jaisi hi hai, lekin developers ko clear signal deta hai ki yeh business logic hai. Spring AOP @Service beans par transactions (@Transactional) laga sakta hai. Scanning ke dauraan Spring ise @Component jaisa hi treat karta hai‚Äîlekin team ko pata chal jata hai ki yeh service layer hai."
          },
          "code": {
            "title": "Service Layer with Transaction Management",
            "language": "java",
            "content": "@Service\npublic class AccountService {\n    \n    @Transactional\n    public void transferMoney(Account from, Account to, BigDecimal amount) {\n        // Business logic with automatic transaction management\n        // If exception occurs, transaction rolls back automatically\n    }\n}"
          },
          "codeExplanations": {
            "english": "@Transactional on a @Service method enables declarative transaction management. Spring creates a proxy that starts a transaction before method execution and commits/rolls back after. No boilerplate JDBC transaction code needed. Works because @Service beans are Spring-managed.",
            "hinglish": "@Transactional method par lagane se automatic transaction management shuru ho jata hai. Spring ek proxy banata hai jo method chalne se pehle transaction start karta hai aur baad mein commit/rollback karta hai. Manual transaction code likhne ki zaroorat nahi. @Service beans Spring-managed hote hain isliye yeh kaam karta hai."
          },
          "keyPoints": [
            "Semantically marks business logic layer components",
            "Enables layer-specific AOP (e.g., @Transactional)",
            "No functional difference from @Component at runtime"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "repository-annotation",
          "title": "@Repository Annotation üóÉÔ∏è",
          "explanations": {
            "english": "@Repository is a @Component specialization for data access objects (DAOs). Its key superpower: automatic exception translation. When JDBC exceptions occur (e.g., SQLException), Spring translates them into Spring's unified DataAccessException hierarchy (e.g., DataIntegrityViolationException). This makes error handling consistent across different data sources (JDBC, Hibernate, MongoDB). Also enables repository-specific AOP features.",
            "hinglish": "@Repository DAOs (data access objects) ke liye @Component ka special version hai. Iska sabse badi taqat: automatic exception translation. JDBC exceptions (jaise SQLException) ko Spring apne DataAccessException hierarchy mein badal deta hai (jaise DataIntegrityViolationException). Isse alag-alag databases ke errors handle karna aasan ho jata hai. Repository-specific AOP features bhi enable karta hai."
          },
          "code": {
            "title": "Repository with Exception Translation",
            "language": "java",
            "content": "@Repository\npublic class JdbcUserRepository {\n    \n    public User findById(Long id) {\n        // If SQLException occurs here...\n        // Spring automatically translates to DataAccessException\n    }\n}\n\n@Service\npublic class UserService {\n    @Autowired\n    private JdbcUserRepository repo;\n    \n    public User getUser(Long id) {\n        try {\n            return repo.findById(id);\n        } catch (DataAccessException e) {\n            // Handle Spring's unified exception\n            log.error(\"DB error\", e);\n            throw new CustomAppException(e);\n        }\n    }\n}"
          },
          "codeExplanations": {
            "english": "Without @Repository, SQLException would propagate directly. With @Repository, Spring's PersistenceExceptionTranslationPostProcessor detects the annotation and wraps low-level exceptions. UserService handles a consistent Spring exception type regardless of underlying database.",
            "hinglish": "@Repository ke bina, SQLException seedha propagate hota. @Repository ke saath, Spring low-level exceptions ko wrap karke Spring ke exceptions mein badal deta hai. UserService ko pata hai ki kis type ka exception handle karna hai‚Äîdatabase change hone par bhi code nahi badalna padta."
          },
          "keyPoints": [
            "Translates technology-specific exceptions to Spring's DataAccessException",
            "Enables consistent error handling across data access technologies",
            "Required for Spring Data repositories (JPA, MongoDB, etc.)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "controller-annotation",
          "title": "@Controller Annotation üåê",
          "explanations": {
            "english": "@Controller marks a class as a Spring MVC web controller. It handles HTTP requests and returns view names (for server-side rendering with Thymeleaf, JSP). Methods use @RequestMapping variants (@GetMapping, @PostMapping) to map URLs. Return value is typically a String representing a template name (e.g., \"user/profile\"). For REST APIs returning data directly (JSON/XML), use @RestController instead.",
            "hinglish": "@Controller class ko Spring MVC web controller batata hai. Yeh HTTP requests handle karta hai aur view names return karta hai (Thymeleaf, JSP ke saath server-side rendering ke liye). Methods @GetMapping, @PostMapping jaise annotations se URLs map karte hain. Return value aam taur par ek template ka naam hota hai (jaise \"user/profile\"). Agar directly JSON/XML return karna ho, toh @RestController use karo."
          },
          "code": {
            "title": "Traditional MVC Controller",
            "language": "java",
            "content": "@Controller\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public String showUserProfile(@PathVariable Long id, Model model) {\n        User user = userService.findUser(id);\n        model.addAttribute(\"user\", user); // Add to view model\n        return \"user/profile\"; // Resolves to templates/user/profile.html\n    }\n}"
          },
          "codeExplanations": {
            "english": "This controller handles GET /users/{id}. It fetches user data, adds it to the Model (view data container), and returns a logical view name. Spring MVC's ViewResolver converts \"user/profile\" to an actual template path. Used with server-side templating engines.",
            "hinglish": "Yeh controller GET /users/{id} handle karta hai. User data lekar Model mein daalta hai aur logical view name return karta hai. Spring MVC ViewResolver \"user/profile\" ko actual template path mein badal deta hai. Server-side templating engines ke saath use hota hai."
          },
          "keyPoints": [
            "Returns view names for server-side rendering (Thymeleaf, FreeMarker)",
            "Use Model object to pass data to views",
            "Combine with @ResponseBody on methods to return data directly"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "restcontroller-annotation",
          "title": "@RestController Annotation üì°",
          "explanations": {
            "english": "@RestController = @Controller + @ResponseBody. Used for building RESTful web services. Every method return value is automatically serialized to HTTP response body (JSON/XML) using Jackson or JAXB. No view resolution‚Äîideal for APIs consumed by JavaScript frontends or mobile apps. Methods typically return domain objects, ResponseEntity, or collections. Content-Type headers set automatically based on return type.",
            "hinglish": "@RestController = @Controller + @ResponseBody. RESTful web services banane ke liye. Har method ka return value automatically JSON/XML mein convert ho kar HTTP response body mein jaata hai. Koi view resolution nahi‚ÄîJavaScript ya mobile apps ke liye perfect. Methods aam taur par domain objects, ResponseEntity, ya lists return karte hain. Content-Type headers khud set ho jate hain."
          },
          "code": {
            "title": "REST API Controller",
            "language": "java",
            "content": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserApiController {\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        User user = userService.findById(id);\n        return ResponseEntity.ok(user); // Returns JSON with 200 status\n    }\n    \n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user); // Request body auto-deserialized to User\n    }\n}"
          },
          "codeExplanations": {
            "english": "@RestController ensures all return values go directly to response body. @RequestBody deserializes JSON request body to Java object. @ResponseBody is implicit‚Äîno need to annotate each method. ResponseEntity provides full control over HTTP status and headers.",
            "hinglish": "@RestController guarantee karta hai ki saare return values seedhe response body mein jaayein. @RequestBody JSON ko Java object mein badal deta hai. @ResponseBody implicit hai‚Äîhar method par lagane ki zaroorat nahi. ResponseEntity HTTP status aur headers control karne deta hai."
          },
          "keyPoints": [
            "All methods implicitly have @ResponseBody",
            "Ideal for JSON/XML APIs (mobile, SPA frontends)",
            "Use ResponseEntity for custom HTTP status codes and headers"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "custom-beans",
          "title": "Custom Beans üå±",
          "explanations": {
            "english": "Create beans for third-party classes you don't control (e.g., DataSource, RestTemplate) or complex configurations. Two approaches: 1) @Configuration class with @Bean methods (preferred), 2) XML configuration (legacy). @Configuration classes are Spring-managed and can inject other beans. @Bean methods define how to instantiate and configure the bean. Spring calls these methods once (singleton scope) and manages the instance.",
            "hinglish": "Un classes ke liye beans banao jin par aapka control nahi hai (jaise DataSource, RestTemplate) ya complex configurations ke liye. Do tarike: 1) @Configuration class ke andar @Bean methods (behtar), 2) XML configuration (purana tareeka). @Configuration classes Spring-managed hote hain aur dusre beans inject kar sakte hain. @Bean methods batate hain ki bean kaise banana hai. Spring in methods ko ek baar call karta hai aur instance manage karta hai."
          },
          "code": {
            "title": "Defining Custom Beans",
            "language": "java",
            "content": "@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    \n    @Bean\n    @ConfigurationProperties(\"app.payment\")\n    public PaymentConfig paymentConfig() {\n        return new PaymentConfig();\n    }\n}"
          },
          "codeExplanations": {
            "english": "restTemplate() method creates and returns a RestTemplate instance. Spring registers it as a bean named 'restTemplate'. paymentConfig() uses @ConfigurationProperties to bind properties under 'app.payment' prefix to the PaymentConfig object fields automatically.",
            "hinglish": "restTemplate() method RestTemplate ka instance banata aur return karta hai. Spring ise 'restTemplate' naam ke bean ke roop mein register karta hai. paymentConfig() @ConfigurationProperties use karke 'app.payment' ke neeche ke properties ko PaymentConfig object ke fields se jodta hai."
          },
          "keyPoints": [
            "@Bean methods can accept other beans as parameters (dependency injection)",
            "Bean name defaults to method name; override with @Bean(\"customName\")",
            "Use @Scope to change bean scope (prototype, request, session)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "configuration-annotation",
          "title": "@Configuration Annotation ‚öôÔ∏è",
          "explanations": {
            "english": "@Configuration marks a class as a source of bean definitions. Methods annotated with @Bean inside this class produce Spring-managed beans. @Configuration classes are themselves beans‚Äîthey can be injected, have dependencies injected, and participate in the full bean lifecycle. Spring creates CGLIB proxies for @Configuration classes to ensure singleton semantics (calling bean methods returns the same instance).",
            "hinglish": "@Configuration class ko bean definitions ka source batata hai. Iske andar @Bean annotated methods Spring-managed beans banate hain. @Configuration classes khud bhi beans hote hain‚Äîunhe inject kiya ja sakta hai, unmein dependencies inject ki ja sakti hain. Spring @Configuration classes ke liye CGLIB proxies banata hai taaki singleton behavior guarantee ho (bean methods call karne par wahi instance mile)."
          },
          "code": {
            "title": "Configuration Class with Dependencies",
            "language": "java",
            "content": "@Configuration\npublic class SecurityConfig {\n    \n    // Inject existing bean into configuration method\n    @Bean\n    public PasswordEncoder passwordEncoder(Environment env) {\n        if (env.getActiveProfiles().contains(\"prod\")) {\n            return new BCryptPasswordEncoder(12);\n        }\n        return NoOpPasswordEncoder.getInstance(); // For dev\n    }\n}"
          },
          "codeExplanations": {
            "english": "Environment bean is injected into the @Bean method. This allows environment-aware bean creation. Spring resolves dependencies of @Bean methods automatically. The returned PasswordEncoder is registered as a singleton bean named 'passwordEncoder'.",
            "hinglish": "Environment bean @Bean method mein inject ho raha hai. Isse environment ke hisaab se alag beans bana sakte hain. Spring @Bean methods ke dependencies khud resolve karta hai. Return kiya gaya PasswordEncoder 'passwordEncoder' naam ke singleton bean ke roop mein register hota hai."
          },
          "keyPoints": [
            "@Configuration classes are enhanced by Spring to manage bean scopes correctly",
            "Can import other config classes via @Import",
            "Use @Profile to activate config only in specific environments"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "bean-annotation",
          "title": "@Bean Annotation ü´ò",
          "explanations": {
            "english": "@Bean annotation declares a method's return value as a Spring-managed bean. Used inside @Configuration classes (or component classes). Spring calls the method once (by default) and caches the instance. Method parameters are automatically injected with matching beans from the container. Ideal for configuring third-party libraries, complex objects, or conditional bean creation. Bean name defaults to method name.",
            "hinglish": "@Bean annotation kisi method ke return value ko Spring-managed bean batata hai. @Configuration classes ke andar use hota hai. Spring method ko ek baar call karta hai aur instance cache karta hai. Method ke parameters automatically container se matching beans se bharte hain. Third-party libraries, complex objects, ya conditional beans banane ke liye perfect. Bean ka naam default method ka naam hota hai."
          },
          "code": {
            "title": "Advanced @Bean Usage",
            "language": "java",
            "content": "@Configuration\npublic class DataSourceConfig {\n    \n    @Bean\n    @ConfigurationProperties(\"spring.datasource\")\n    public HikariDataSource dataSource() {\n        return new HikariDataSource(); // Properties auto-bound\n    }\n    \n    @Bean\n    @ConditionalOnMissingBean // Only create if no other DataSource exists\n    public DataSource testDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .build();\n    }\n}"
          },
          "codeExplanations": {
            "english": "First bean uses @ConfigurationProperties to bind application.properties values to HikariDataSource fields. Second bean uses @ConditionalOnMissingBean‚Äîa Spring Boot condition‚Äîto provide a fallback datasource only if none is configured. Demonstrates powerful conditional bean registration.",
            "hinglish": "Pehla bean application.properties ke values ko HikariDataSource fields se jodta hai. Dusra bean @ConditionalOnMissingBean use karta hai‚Äîsirf tab banega jab koi DataSource configure nahi kiya gaya ho. Conditional bean registration ka powerful example."
          },
          "keyPoints": [
            "Method parameters are autowired by type from ApplicationContext",
            "Use @Scope to define non-singleton beans (prototype, request)",
            "Combine with @Conditional annotations for environment-aware beans"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "advanced-wiring",
          "title": "Advanced Wiring üîÄ",
          "explanations": {
            "english": "When multiple beans of the same type exist, Spring needs help to choose the right one. Use @Qualifier to specify bean name explicitly. @Primary marks a bean as the default candidate when multiple matches exist. For complex scenarios, use @Resource (JSR-250) for name-based injection, or implement custom logic with ApplicationContext.getBean(). Prefer constructor injection with @Qualifier over field injection for clarity.",
            "hinglish": "Jab ek hi type ke multiple beans hoon, Spring ko sahi bean chunne mein madad chahiye. @Qualifier use karo bean ka naam explicitly batane ke liye. @Primary kisi bean ko default candidate mark karta hai jab multiple matches hoon. Complex cases ke liye @Resource (JSR-250) naam-based injection ke liye use karo, ya ApplicationContext.getBean() se custom logic likho. Clarity ke liye field injection ke bajaye constructor injection with @Qualifier behtar hai."
          },
          "code": {
            "title": "Resolving Ambiguous Dependencies",
            "language": "java",
            "content": "@Configuration\npublic class PaymentConfig {\n    @Bean\n    @Primary // Default when type PaymentService requested\n    public PaymentService stripeService() {\n        return new StripePaymentService();\n    }\n    \n    @Bean(\"paypalService\")\n    public PaymentService paypalService() {\n        return new PayPalPaymentService();\n    }\n}\n\n@Service\npublic class OrderService {\n    // Uses @Primary bean (stripeService)\n    private final PaymentService defaultPayment;\n    \n    // Explicitly requests paypalService bean\n    private final PaymentService paypalPayment;\n    \n    public OrderService(PaymentService defaultPayment,\n                       @Qualifier(\"paypalService\") PaymentService paypalPayment) {\n        this.defaultPayment = defaultPayment;\n        this.paypalPayment = paypalPayment;\n    }\n}"
          },
          "codeExplanations": {
            "english": "@Primary makes stripeService the default injection candidate. @Qualifier(\"paypalService\") explicitly selects the PayPal bean. Constructor injection with qualifiers is explicit and testable. Avoid @Autowired on fields when multiple candidates exist‚Äîit causes ambiguity errors.",
            "hinglish": "@Primary stripeService ko default candidate banata hai. @Qualifier(\"paypalService\") explicitly PayPal bean select karta hai. Constructor injection with qualifiers clear aur testable hota hai. Jab multiple candidates hoon, field par @Autowired use karna avoid karo‚Äîambiguity errors aate hain."
          },
          "keyPoints": [
            "@Primary resolves ambiguity when one bean is the 'default' choice",
            "@Qualifier specifies exact bean name when multiple candidates exist",
            "Use Map<String, BeanType> to inject all beans of a type with names"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "qualifier-annotation",
          "title": "@Qualifier Annotation üéØ",
          "explanations": {
            "english": "@Qualifier resolves dependency injection ambiguity by specifying the exact bean name to inject. Use alongside @Autowired when multiple beans of the same type exist. Can be applied to constructor parameters, setter methods, or fields. Bean names come from @Component(\"name\"), @Bean(\"name\"), or default camelCase class/method names. Prefer constructor injection with @Qualifier for testability and clarity.",
            "hinglish": "@Qualifier dependency injection ki ambiguity ko solve karta hai‚Äîexact bean ka naam specify karke. Jab ek hi type ke multiple beans hoon, @Autowired ke saath use karo. Constructor parameters, setter methods, ya fields par lagaya ja sakta hai. Bean names @Component(\"name\"), @Bean(\"name\"), ya default camelCase names se aate hain. Testability aur clarity ke liye constructor injection with @Qualifier behtar hai."
          },
          "code": {
            "title": "@Qualifier in Constructor Injection",
            "language": "java",
            "content": "@Service\npublic class NotificationService {\n    private final EmailService primaryEmail;\n    private final EmailService marketingEmail;\n    \n    public NotificationService(\n            @Qualifier(\"primaryEmailService\") EmailService primaryEmail,\n            @Qualifier(\"marketingEmailService\") EmailService marketingEmail) {\n        this.primaryEmail = primaryEmail;\n        this.marketingEmail = marketingEmail;\n    }\n}\n\n@Configuration\npublic class EmailConfig {\n    @Bean(\"primaryEmailService\")\n    public EmailService primaryEmail() {\n        return new SendGridEmailService(\"api-key-prod\");\n    }\n    \n    @Bean(\"marketingEmailService\")\n    public EmailService marketingEmail() {\n        return new MailchimpEmailService(\"api-key-marketing\");\n    }\n}"
          },
          "codeExplanations": {
            "english": "Two EmailService beans exist with custom names. @Qualifier on constructor parameters specifies exactly which bean to inject. This avoids ambiguity and makes dependencies explicit. Unit tests can inject mock implementations by name.",
            "hinglish": "Do EmailService beans custom names ke saath banaye gaye hain. Constructor parameters par @Qualifier explicitly batata hai konsa bean inject karna hai. Ambiguity avoid hoti hai aur dependencies clear rehti hain. Unit tests mock implementations names ke saath inject kar sakte hain."
          },
          "keyPoints": [
            "Must match the bean name defined in @Component or @Bean",
            "Can create custom qualifier annotations (e.g., @PrimaryEmail)",
            "Works with constructor, setter, and field injection"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "primary-annotation",
          "title": "@Primary Annotation ü•á",
          "explanations": {
            "english": "@Primary marks a bean as the preferred choice when multiple candidates of the same type exist. Spring injects this bean by default when no @Qualifier is specified. Useful when one implementation is the 'default' (e.g., production service) while others are alternatives (e.g., test/mock implementations). Can be used on @Component classes or @Bean methods. Avoid overusing‚Äîexplicit @Qualifier is clearer for non-default choices.",
            "hinglish": "@Primary kisi bean ko preferred choice mark karta hai jab ek hi type ke multiple beans hoon. Jab @Qualifier specify nahi kiya gaya ho, Spring yehi bean inject karta hai. Jab ek implementation 'default' ho (jaise production service) aur doosre alternatives hoon (jaise test/mock), tab useful hota hai. @Component classes ya @Bean methods par lagaya ja sakta hai. Zyada use na karo‚Äînon-default choices ke liye explicit @Qualifier clear hota hai."
          },
          "code": {
            "title": "@Primary for Default Implementation",
            "language": "java",
            "content": "@Repository\n@Primary // Default DataSource for most services\npublic class ProductionDataSource implements DataSource {\n    // Production DB configuration\n}\n\n@Repository\npublic class TestDataSource implements DataSource {\n    // In-memory DB for tests\n}\n\n@Service\npublic class UserService {\n    // Injects ProductionDataSource (marked @Primary)\n    private final DataSource dataSource;\n    \n    public UserService(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n}\n\n@Service\npublic class TestDataLoader {\n    // Explicitly requests test implementation\n    private final DataSource testDataSource;\n    \n    public TestDataLoader(@Qualifier(\"testDataSource\") DataSource testDataSource) {\n        this.testDataSource = testDataSource;\n    }\n}"
          },
          "codeExplanations": {
            "english": "ProductionDataSource is injected by default into UserService due to @Primary. TestDataLoader explicitly requests TestDataSource using @Qualifier. This pattern allows seamless switching between implementations while keeping most code unaware of alternatives.",
            "hinglish": "@Primary ke karan UserService mein ProductionDataSource inject ho jata hai. TestDataLoader explicitly @Qualifier use karke TestDataSource maangta hai. Yeh pattern implementations ke beech aasan switch allow karta hai bina zyada code ko affect kiye."
          },
          "keyPoints": [
            "Solves ambiguity without requiring @Qualifier everywhere",
            "Ideal for marking 'default' implementation in multi-bean scenarios",
            "Can be overridden per injection point using @Qualifier"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        }
      ]
    },
      {
      "id": "web-rest-section",
      "title": "Web / REST Layer Deep Dive üåê",
      "intro": "Master Spring Boot's web layer architecture‚Äîfrom request handling to response management. Learn how Spring MVC processes HTTP requests, maps them to controllers, and returns responses. Perfect for building REST APIs and server-rendered web apps.",
      "topics": [
        {
          "id": "spring-mvc-architecture",
          "title": "Spring MVC Architecture üèóÔ∏è",
          "explanations": {
            "english": "Spring MVC follows the Model-View-Controller pattern. All HTTP requests first hit the DispatcherServlet (front controller). It uses Handler Mappings to find the right Controller, processes the request, then View Resolvers locate the template to render the response. This separation keeps code organized and testable.",
            "hinglish": "Spring MVC Model-View-Controller pattern follow karta hai. Saare HTTP requests pehle DispatcherServlet (front controller) par pahunchte hain. Ye Handler Mappings ka use karke sahi Controller dhundhta hai, request process karta hai, phir View Resolvers template ko dhundhkar response banate hain. Ye separation code ko organized aur testable rakhta hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "DispatcherServlet is the central orchestrator handling all incoming requests",
            "Handler Mappings match URLs to controller methods using annotations or configurations",
            "View Resolvers convert logical view names (e.g., 'home') to actual templates (Thymeleaf/JSP)"
          ],
          "extras": {
            "flowDiagram": "HTTP Request ‚Üí DispatcherServlet ‚Üí HandlerMapping ‚Üí Controller ‚Üí Service ‚Üí Model ‚Üí ViewResolver ‚Üí View Template ‚Üí HTTP Response",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "dispatcher-servlet",
          "title": "DispatcherServlet üåê",
          "explanations": {
            "english": "DispatcherServlet is Spring MVC's front controller. Registered automatically in Spring Boot via @SpringBootApplication. It delegates requests to handlers (controllers), manages handler mappings, view resolution, and exception handling. You rarely configure it directly‚ÄîSpring Boot auto-configures it with sensible defaults.",
            "hinglish": "DispatcherServlet Spring MVC ka front controller hai. @SpringBootApplication ke through Spring Boot mein automatically register hota hai. Ye requests ko handlers (controllers) ko delegate karta hai, handler mappings, view resolution, aur exception handling manage karta hai. Aap ise directly configure nahi karte‚ÄîSpring Boot ise sensible defaults ke saath auto-configure karta hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Single entry point for all web requests in Spring MVC applications",
            "Auto-configured by Spring Boot‚Äîno manual setup needed in most cases",
            "Integrates all MVC components: handlers, resolvers, converters, and exception handlers"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "In Spring Boot, adding spring-boot-starter-web dependency auto-registers DispatcherServlet",
              "Customization possible via WebMvcConfigurer interface if needed"
            ]
          }
        },
        {
          "id": "handler-mappings",
          "title": "Handler Mappings üó∫Ô∏è",
          "explanations": {
            "english": "Handler Mappings determine which controller method handles a specific request URL. Spring uses annotations like @RequestMapping to map URLs to methods. The RequestMappingHandlerMapping component scans controllers at startup and builds a registry of URL patterns to handler methods.",
            "hinglish": "Handler Mappings decide karte hain ki konsi controller method kisi specific request URL ko handle karegi. Spring annotations jaise @RequestMapping ka use karke URLs ko methods se map karta hai. RequestMappingHandlerMapping component startup par controllers ko scan karta hai aur URL patterns ko handler methods ke registry mein banata hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Annotation-based mapping (@GetMapping, @PostMapping) is the modern standard",
            "Matches requests using URL path, HTTP method, headers, and parameters",
            "Multiple mappings can exist‚ÄîSpring selects the most specific match"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "@GetMapping(\"/api/users\") handles GET requests to /api/users",
              "@PostMapping(\"/api/users\") handles POST requests to the same path"
            ]
          }
        },
        {
          "id": "view-resolvers",
          "title": "View Resolvers üëÅÔ∏è",
          "explanations": {
            "english": "View Resolvers translate logical view names (returned by controllers) into actual view templates. For example, returning 'user-list' might resolve to templates/user-list.html. Common implementations: ThymeleafViewResolver, InternalResourceViewResolver (for JSP). In REST APIs using @RestController, view resolvers are typically unused since responses are direct data (JSON/XML).",
            "hinglish": "View Resolvers logical view names (jo controllers return karte hain) ko actual view templates mein convert karte hain. Jaise 'user-list' return karna templates/user-list.html resolve ho sakta hai. Common implementations: ThymeleafViewResolver, InternalResourceViewResolver (JSP ke liye). REST APIs mein @RestController use karne par view resolvers usually unused hote hain kyunki responses direct data (JSON/XML) hote hain."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Critical for server-rendered applications (Thymeleaf, JSP, FreeMarker)",
            "Not used in pure REST APIs where @ResponseBody or @RestController returns raw data",
            "Configurable prefix/suffix (e.g., prefix='templates/', suffix='.html')"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "controller-annotations",
          "title": "Controller Annotations üè∑Ô∏è",
          "explanations": {
            "english": "Controller annotations mark classes as web request handlers. @Controller is for traditional MVC (returns view names). @RestController combines @Controller + @ResponseBody‚Äîideal for REST APIs returning data directly (JSON/XML). Both are detected automatically via component scanning.",
            "hinglish": "Controller annotations classes ko web request handlers ke roop mein mark karte hain. @Controller traditional MVC ke liye hai (view names return karta hai). @RestController @Controller + @ResponseBody ko combine karta hai‚ÄîREST APIs ke liye perfect jo directly data (JSON/XML) return karte hain. Dono automatically component scanning se detect hote hain."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "@Controller requires @ResponseBody on methods to return raw data",
            "@RestController applies @ResponseBody to all methods automatically",
            "Both enable Spring to detect and register controllers without XML"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "@Controller",
                "column2": "@RestController"
              },
              {
                "column1": "Returns view names (for templates)",
                "column2": "Returns data directly (JSON/XML)"
              },
              {
                "column1": "Needs @ResponseBody per method for APIs",
                "column2": "Implicit @ResponseBody on all methods"
              },
              {
                "column1": "Best for server-rendered apps",
                "column2": "Best for RESTful APIs"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "controller-annotation",
          "title": "@Controller Annotation",
          "explanations": {
            "english": "@Controller marks a class as a Spring MVC controller for handling web requests. Typically used with view technologies (Thymeleaf, JSP). Methods return logical view names (e.g., 'home'), which View Resolvers map to templates. To return raw data (JSON), add @ResponseBody to individual methods.",
            "hinglish": "@Controller ek class ko Spring MVC controller ke roop mein mark karta hai web requests handle karne ke liye. Aam taur par view technologies (Thymeleaf, JSP) ke saath use hota hai. Methods logical view names (jaise 'home') return karte hain, jinhe View Resolvers templates se map karte hain. Raw data (JSON) return karne ke liye, individual methods par @ResponseBody add karo."
          },
          "code": {
            "title": "Traditional MVC Controller",
            "language": "java",
            "content": "@Controller\npublic class HomeController {\n    \n    @GetMapping(\"/\")\n    public String home(Model model) {\n        model.addAttribute(\"message\", \"Welcome!\");\n        return \"home\"; // Logical view name ‚Üí templates/home.html\n    }\n    \n    // For API endpoint in same controller\n    @GetMapping(\"/api/message\")\n    @ResponseBody\n    public String apiMessage() {\n        return \"{\\\"msg\\\":\\\"API Response\\\"}\";\n    }\n}"
          },
          "codeExplanations": {
            "english": "HomeController handles '/' request, adds data to Model, returns 'home' view name. ViewResolver finds home.html. The apiMessage() method uses @ResponseBody to bypass view resolution and return raw JSON string directly.",
            "hinglish": "HomeController '/' request ko handle karta hai, Model mein data add karta hai, 'home' view name return karta hai. ViewResolver home.html dhundhta hai. apiMessage() method @ResponseBody use karta hai taaki view resolution skip ho aur directly raw JSON string return ho."
          },
          "keyPoints": [
            "Primarily used for server-side rendered applications",
            "Methods return String view names by default",
            "Combine with @ResponseBody on specific methods for mixed MVC/API controllers"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "restcontroller-annotation",
          "title": "@RestController Annotation",
          "explanations": {
            "english": "@RestController = @Controller + @ResponseBody. Every method in this class automatically returns data (not view names). Ideal for REST APIs. Spring converts return values to JSON/XML using HttpMessageConverters (like Jackson for JSON). No need for @ResponseBody on individual methods.",
            "hinglish": "@RestController = @Controller + @ResponseBody. Is class ki har method automatically data return karti hai (view names nahi). REST APIs ke liye perfect. Spring return values ko JSON/XML mein convert karta hai HttpMessageConverters (Jackson JSON ke liye) ka use karke. Individual methods par @ResponseBody ki zaroorat nahi."
          },
          "code": {
            "title": "REST API Controller",
            "language": "java",
            "content": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll(); // Auto-converted to JSON\n    }\n    \n    @PostMapping\n    public User createUser(@RequestBody User user) {\n        return userService.save(user);\n    }\n}"
          },
          "codeExplanations": {
            "english": "getAllUsers() returns List<User> ‚Üí Spring auto-converts to JSON array. createUser() accepts JSON body via @RequestBody, saves user, returns saved User as JSON. No view resolution occurs.",
            "hinglish": "getAllUsers() List<User> return karta hai ‚Üí Spring automatically JSON array mein convert karta hai. createUser() @RequestBody ke through JSON body accept karta hai, user save karta hai, saved User ko JSON ke roop mein return karta hai. Koi view resolution nahi hota."
          },
          "keyPoints": [
            "Eliminates need for @ResponseBody on every method",
            "Return types automatically serialized to JSON/XML",
            "Standard choice for building RESTful web services in Spring Boot"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "http-method-mapping",
          "title": "HTTP Method Mapping üîÄ",
          "explanations": {
            "english": "Spring provides dedicated annotations for HTTP methods: @GetMapping (GET), @PostMapping (POST), etc. These are shorthand for @RequestMapping(method = RequestMethod.XXX). They improve code readability, reduce errors, and enable Spring to optimize request routing. Always prefer these over generic @RequestMapping.",
            "hinglish": "Spring HTTP methods ke liye dedicated annotations provide karta hai: @GetMapping (GET), @PostMapping (POST), etc. Ye @RequestMapping(method = RequestMethod.XXX) ka shorthand hain. Ye code readability badhate hain, errors kam karte hain, aur Spring ko request routing optimize karne mein madad karte hain. Hamesha inhe generic @RequestMapping par prefer karo."
          },
          "code": {
            "title": "HTTP Method Annotations",
            "language": "java",
            "content": "@RestController\npublic class ProductController {\n    \n    @GetMapping(\"/products\")        // GET all\n    public List<Product> list() { ... }\n    \n    @PostMapping(\"/products\")       // CREATE new\n    public Product create(@RequestBody Product p) { ... }\n    \n    @PutMapping(\"/products/{id}\")   // FULL UPDATE\n    public Product update(@PathVariable Long id, @RequestBody Product p) { ... }\n    \n    @PatchMapping(\"/products/{id}\") // PARTIAL UPDATE\n    public Product patch(@PathVariable Long id, @RequestBody Map updates) { ... }\n    \n    @DeleteMapping(\"/products/{id}\")// DELETE\n    public void delete(@PathVariable Long id) { ... }\n}"
          },
          "codeExplanations": {
            "english": "Each annotation maps to a specific HTTP method and URL pattern. @PutMapping replaces entire resource; @PatchMapping updates specific fields. Path variables ({id}) extract values from URL segments.",
            "hinglish": "Har annotation ek specific HTTP method aur URL pattern se map hota hai. @PutMapping pure resource ko replace karta hai; @PatchMapping specific fields update karta hai. Path variables ({id}) URL segments se values extract karte hain."
          },
          "keyPoints": [
            "@GetMapping = safe, idempotent reads (no side effects)",
            "@PostMapping = creates new resources (non-idempotent)",
            "@PutMapping = full resource replacement; @PatchMapping = partial updates"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "getmapping",
          "title": "@GetMapping",
          "explanations": {
            "english": "@GetMapping handles HTTP GET requests. Used for retrieving resources. Safe and idempotent‚Äîmultiple identical requests have the same effect. Supports path variables, query parameters, and headers. Spring automatically serializes return objects to JSON/XML.",
            "hinglish": "@GetMapping HTTP GET requests ko handle karta hai. Resources retrieve karne ke liye use hota hai. Safe aur idempotent‚Äîmultiple identical requests ka same effect hota hai. Path variables, query parameters, aur headers support karta hai. Spring return objects ko automatically JSON/XML mein serialize karta hai."
          },
          "code": {
            "title": "GET Request Handler",
            "language": "java",
            "content": "@RestController\npublic class BookController {\n    \n    @GetMapping(\"/books/{isbn}\")\n    public ResponseEntity<Book> getBook(\n            @PathVariable String isbn,\n            @RequestParam(required = false) String format) {\n        \n        Book book = bookService.findByIsbn(isbn);\n        if (book == null) {\n            return ResponseEntity.notFound().build();\n        }\n        return ResponseEntity.ok(book);\n    }\n}"
          },
          "codeExplanations": {
            "english": "Handles GET /books/123-456. @PathVariable extracts '123-456' as isbn. @RequestParam optionally captures 'format' query param (e.g., ?format=pdf). Returns 404 if not found, else 200 with book JSON.",
            "hinglish": "GET /books/123-456 ko handle karta hai. @PathVariable '123-456' ko isbn ke roop mein extract karta hai. @RequestParam optionally 'format' query param capture karta hai (jaise ?format=pdf). Agar book nahi milti to 404 return karta hai, warna book JSON ke saath 200."
          },
          "keyPoints": [
            "Always use for read-only operations",
            "Supports multiple parameters: @PathVariable, @RequestParam, @RequestHeader",
            "Return types auto-converted to response body (JSON/XML)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "GET /api/users ‚Üí returns all users",
              "GET /api/users/5?fields=name,email ‚Üí returns user 5 with selected fields"
            ]
          }
        },
        {
          "id": "postmapping",
          "title": "@PostMapping",
          "explanations": {
            "english": "@PostMapping handles HTTP POST requests. Used for creating new resources or triggering actions. Non-idempotent‚Äîrepeating the request may create duplicate resources. Typically consumes JSON/XML payloads via @RequestBody. Returns 201 Created with Location header on success.",
            "hinglish": "@PostMapping HTTP POST requests ko handle karta hai. Naye resources banana ya actions trigger karne ke liye use hota hai. Non-idempotent‚Äîrequest dobara bhejne se duplicate resources banein. Aam taur par @RequestBody ke through JSON/XML payloads consume karta hai. Success par 201 Created Location header ke saath return karta hai."
          },
          "code": {
            "title": "POST Request Handler",
            "language": "java",
            "content": "@PostMapping\npublic ResponseEntity<User> createUser(\n        @RequestBody @Valid User user,\n        UriComponentsBuilder builder) {\n    \n    User savedUser = userService.save(user);\n    HttpHeaders headers = new HttpHeaders();\n    headers.setLocation(\n        builder.path(\"/api/users/{id}\")\n               .buildAndExpand(savedUser.getId())\n               .toUri()\n    );\n    return new ResponseEntity<>(savedUser, headers, HttpStatus.CREATED);\n}"
          },
          "codeExplanations": {
            "english": "Accepts JSON user object via @RequestBody. @Valid triggers bean validation. On save, sets Location header to new resource URL (e.g., /api/users/101) and returns 201 Created with saved user JSON.",
            "hinglish": "@RequestBody ke through JSON user object accept karta hai. @Valid bean validation trigger karta hai. Save hone par, Location header new resource URL (jaise /api/users/101) par set karta hai aur saved user JSON ke saath 201 Created return karta hai."
          },
          "keyPoints": [
            "Creates new resources; client doesn't specify the ID",
            "Use @Valid for automatic input validation",
            "Return 201 Created with Location header pointing to new resource"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "putmapping",
          "title": "@PutMapping",
          "explanations": {
            "english": "@PutMapping handles HTTP PUT requests. Used for full resource replacement. Idempotent‚Äîrepeating the request has the same effect. Client sends complete updated resource representation. If resource doesn't exist, typically creates it (upsert). Requires resource ID in URL path.",
            "hinglish": "@PutMapping HTTP PUT requests ko handle karta hai. Full resource replacement ke liye use hota hai. Idempotent‚Äîrequest dobara bhejne ka same effect hota hai. Client complete updated resource representation bhejta hai. Agar resource exist nahi karta, typically use create karta hai (upsert). URL path mein resource ID ki zaroorat hoti hai."
          },
          "code": {
            "title": "PUT Request Handler",
            "language": "java",
            "content": "@PutMapping(\"/{id}\")\npublic ResponseEntity<Product> updateProduct(\n        @PathVariable Long id,\n        @RequestBody @Valid Product updatedProduct) {\n    \n    Product existing = productService.findById(id);\n    if (existing == null) {\n        // Upsert: create new if not exists\n        updatedProduct.setId(id);\n        Product created = productService.save(updatedProduct);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n    \n    // Full replacement\n    updatedProduct.setId(id);\n    Product saved = productService.save(updatedProduct);\n    return ResponseEntity.ok(saved);\n}"
          },
          "codeExplanations": {
            "english": "Replaces entire product at /products/5 with JSON body. If product 5 doesn't exist, creates it (upsert) and returns 201. If exists, replaces fully and returns 200. Note: ID in path must match ID in JSON body for consistency.",
            "hinglish": "/products/5 par JSON body ke saath pure product ko replace karta hai. Agar product 5 exist nahi karta, use create karta hai (upsert) aur 201 return karta hai. Agar exist karta hai, fully replace karta hai aur 200 return karta hai. Note: Path mein ID JSON body mein ID se match karni chahiye consistency ke liye."
          },
          "keyPoints": [
            "Replaces the entire resource‚Äîpartial updates use @PatchMapping",
            "Idempotent: safe to retry without side effects",
            "Often implements upsert (update or insert) behavior"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "deletemapping",
          "title": "@DeleteMapping",
          "explanations": {
            "english": "@DeleteMapping handles HTTP DELETE requests. Used to remove resources. Idempotent‚Äîdeleting an already-deleted resource has no effect. Returns 204 No Content on success. Always validate resource existence before deletion to avoid silent failures.",
            "hinglish": "@DeleteMapping HTTP DELETE requests ko handle karta hai. Resources ko remove karne ke liye use hota hai. Idempotent‚Äîpehle se delete kiye gaye resource ko delete karna koi effect nahi deta. Success par 204 No Content return karta hai. Silent failures avoid karne ke liye hamesha deletion se pehle resource existence validate karo."
          },
          "code": {
            "title": "DELETE Request Handler",
            "language": "java",
            "content": "@DeleteMapping(\"/{id}\")\npublic ResponseEntity<Void> deleteOrder(\n        @PathVariable Long id) {\n    \n    if (!orderService.existsById(id)) {\n        return ResponseEntity.notFound().build();\n    }\n    \n    orderService.deleteById(id);\n    return ResponseEntity.noContent().build(); // 204\n}"
          },
          "codeExplanations": {
            "english": "Deletes order by ID. Checks existence first‚Äîreturns 404 if not found. On successful delete, returns 204 No Content (empty body). Never returns deleted data for security.",
            "hinglish": "ID ke hisaab se order delete karta hai. Pehle existence check karta hai‚Äîagar nahi milta to 404 return karta hai. Successful delete par, 204 No Content (khali body) return karta hai. Security ke liye kabhi deleted data return nahi karta."
          },
          "keyPoints": [
            "Always check resource existence before deleting",
            "Return 204 No Content on success (no response body)",
            "Idempotent: safe to call multiple times"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "patchmapping",
          "title": "@PatchMapping",
          "explanations": {
            "english": "@PatchMapping handles HTTP PATCH requests. Used for partial updates‚Äîclient sends only changed fields. Not inherently idempotent (depends on implementation). Commonly uses Map<String, Object> or JSON Merge Patch format. Validate which fields are allowed to update.",
            "hinglish": "@PatchMapping HTTP PATCH requests ko handle karta hai. Partial updates ke liye use hota hai‚Äîclient sirf changed fields bhejta hai. Inherently idempotent nahi hai (implementation par nirbhar karta hai). Aam taur par Map<String, Object> ya JSON Merge Patch format use karta hai. Validate karo ki kaunse fields update karne allowed hain."
          },
          "code": {
            "title": "PATCH Request Handler",
            "language": "java",
            "content": "@PatchMapping(\"/{id}\")\npublic ResponseEntity<User> partialUpdate(\n        @PathVariable Long id,\n        @RequestBody Map<String, Object> updates) {\n    \n    User existing = userService.findById(id);\n    if (existing == null) {\n        return ResponseEntity.notFound().build();\n    }\n    \n    // Apply only allowed fields\n    if (updates.containsKey(\"email\")) {\n        existing.setEmail((String) updates.get(\"email\"));\n    }\n    if (updates.containsKey(\"phone\")) {\n        existing.setPhone((String) updates.get(\"phone\"));\n    }\n    \n    User updated = userService.save(existing);\n    return ResponseEntity.ok(updated);\n}"
          },
          "codeExplanations": {
            "english": "Accepts JSON with only changed fields (e.g., {\"email\": \"new@test.com\"}). Updates specific fields on existing user. Ignores unrecognized fields. Returns full updated user object. Prevents overposting by validating allowed fields.",
            "hinglish": "Sirf changed fields ke saath JSON accept karta hai (jaise {\"email\": \"new@test.com\"}). Existing user par specific fields update karta hai. Unrecognized fields ko ignore karta hai. Full updated user object return karta hai. Allowed fields validate karke overposting rokta hai."
          },
          "keyPoints": [
            "Updates only specified fields‚Äîpreserves others",
            "Critical to validate allowed update fields to prevent overposting",
            "Not idempotent if updates are relative (e.g., \"increment count\")"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "request-handling",
          "title": "Request Handling üì•",
          "explanations": {
            "english": "Spring Boot provides annotations to extract data from HTTP requests: @PathVariable (URL segments), @RequestParam (query params), @RequestBody (JSON/XML body). Spring automatically converts values to Java types (String, int, custom objects). Validation via @Valid ensures data integrity before processing.",
            "hinglish": "Spring Boot HTTP requests se data extract karne ke liye annotations provide karta hai: @PathVariable (URL segments), @RequestParam (query params), @RequestBody (JSON/XML body). Spring values ko automatically Java types (String, int, custom objects) mein convert karta hai. @Valid ke through validation data integrity ensure karta hai processing se pehle."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "@PathVariable extracts values from URL path segments (e.g., /users/{id})",
            "@RequestParam captures query parameters (e.g., ?page=2&size=10)",
            "@RequestBody binds JSON/XML request body to Java objects"
          ],
          "extras": {
            "flowDiagram": "HTTP Request ‚Üí DispatcherServlet ‚Üí @Controller Method\n‚îÇ\n‚îú‚îÄ URL Path ‚Üí @PathVariable\n‚îú‚îÄ Query String ‚Üí @RequestParam\n‚îú‚îÄ Headers ‚Üí @RequestHeader\n‚îî‚îÄ Body (JSON/XML) ‚Üí @RequestBody ‚Üí HttpMessageConverter ‚Üí Java Object",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "pathvariable",
          "title": "@PathVariable",
          "explanations": {
            "english": "@PathVariable extracts values from URL path segments. Define placeholders in @GetMapping/@PostMapping paths using {name}. Spring matches the placeholder name to the method parameter name (or use @PathVariable(\"name\") for explicit mapping). Automatically converts to target Java type (String, Long, UUID).",
            "hinglish": "@PathVariable URL path segments se values extract karta hai. @GetMapping/@PostMapping paths mein {name} use karke placeholders define karo. Spring placeholder name ko method parameter name se match karta hai (ya explicit mapping ke liye @PathVariable(\"name\") use karo). Target Java type (String, Long, UUID) mein automatically convert karta hai."
          },
          "code": {
            "title": "Path Variable Usage",
            "language": "java",
            "content": "@GetMapping(\"/orders/{orderId}/items/{itemId}\")\npublic OrderItem getItem(\n        @PathVariable Long orderId,  // Matches {orderId}\n        @PathVariable(\"itemId\") Long id) { // Explicit name mapping\n    \n    return orderService.findItem(orderId, id);\n}\n\n// Request: GET /orders/1001/items/55\n// orderId = 1001, id = 55"
          },
          "codeExplanations": {
            "english": "URL /orders/1001/items/55 maps orderId=1001 and itemId=55. First parameter uses implicit naming (orderId matches {orderId}). Second uses explicit @PathVariable(\"itemId\") to map to parameter 'id'. Spring converts strings to Long automatically.",
            "hinglish": "URL /orders/1001/items/55 orderId=1001 aur itemId=55 map karta hai. Pehla parameter implicit naming use karta hai (orderId {orderId} se match karta hai). Dusra explicit @PathVariable(\"itemId\") use karta hai parameter 'id' se map karne ke liye. Spring strings ko automatically Long mein convert karta hai."
          },
          "keyPoints": [
            "Placeholders defined in URL path with curly braces: {id}",
            "Parameter names must match placeholder names (or use explicit value)",
            "Supports multiple path variables in a single URL pattern"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "@GetMapping(\"/users/{userId}/posts/{postId}\")",
              "@DeleteMapping(\"/api/v1/resources/{resourceId}\")"
            ]
          }
        },
        {
          "id": "url-segments",
          "title": "URL Segments",
          "explanations": {
            "english": "URL segments are parts of the path separated by slashes. In REST, segments represent resources and identifiers. Example: /api/users/123/orders/456 has segments: 'api', 'users', '123', 'orders', '456'. Path variables bind to dynamic segments (like 123, 456). Keep URLs hierarchical, nouns-based, and versioned (e.g., /api/v1/).",
            "hinglish": "URL segments path ke woh hisse hote hain jo slashes se alag hote hain. REST mein, segments resources aur identifiers ko represent karte hain. Example: /api/users/123/orders/456 ke segments hain: 'api', 'users', '123', 'orders', '456'. Path variables dynamic segments (jaise 123, 456) se bind hote hain. URLs ko hierarchical, nouns-based, aur versioned (jaise /api/v1/) rakho."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Use nouns for resources (users, orders), not verbs (getUser)",
            "Hierarchy shows relationships: /users/{id}/orders",
            "Version APIs in URL path (e.g., /api/v1/) for backward compatibility"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Good: /api/v1/users/5/posts",
              "Avoid: /api/getUserPosts?userId=5 (RPC-style)"
            ]
          }
        },
        {
          "id": "requestparam",
          "title": "@RequestParam",
          "explanations": {
            "english": "@RequestParam extracts query parameters from the URL (after ?). Example: /search?query=java&page=2. Parameters are optional by default‚Äîuse required=false or defaultValue. Spring converts values to target types. Ideal for filters, pagination, sorting. For complex queries, consider a DTO object.",
            "hinglish": "@RequestParam URL se query parameters extract karta hai ( ? ke baad). Example: /search?query=java&page=2. Parameters default mein optional hote hain‚Äîrequired=false ya defaultValue use karo. Spring values ko target types mein convert karta hai. Filters, pagination, sorting ke liye perfect. Complex queries ke liye, DTO object consider karo."
          },
          "code": {
            "title": "Query Parameter Handling",
            "language": "java",
            "content": "@GetMapping(\"/search\")\npublic Page<Product> searchProducts(\n        @RequestParam String query,\n        @RequestParam(defaultValue = \"0\") int page,\n        @RequestParam(defaultValue = \"10\") int size,\n        @RequestParam(required = false) String category) {\n    \n    return productService.search(query, category, page, size);\n}\n\n// Request: GET /search?query=laptop&page=1&size=20&category=electronics"
          },
          "codeExplanations": {
            "english": "query is required. page/size have defaults (0, 10). category is optional. Spring converts '1' to int page=1. Missing category passes null. Use Pageable interface for cleaner pagination handling in Spring Data.",
            "hinglish": "query required hai. page/size ke defaults hain (0, 10). category optional hai. Spring '1' ko int page=1 mein convert karta hai. Missing category null pass karta hai. Spring Data mein cleaner pagination handling ke liye Pageable interface use karo."
          },
          "keyPoints": [
            "Handles optional parameters with defaultValue or required=false",
            "Automatic type conversion (String ‚Üí int, boolean, etc.)",
            "Use for filtering, pagination, sorting parameters"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "query-parameters",
          "title": "Query Parameters",
          "explanations": {
            "english": "Query parameters appear after ? in URL: /users?role=admin&page=2. Key-value pairs separated by &. Used for optional filters, pagination, sorting, or non-identifying data. Not part of resource identity (unlike path variables). Keep URLs bookmarkable and cacheable. Avoid for sensitive data (visible in logs).",
            "hinglish": "Query parameters URL mein ? ke baad aate hain: /users?role=admin&page=2. & se alag key-value pairs. Optional filters, pagination, sorting, ya non-identifying data ke liye use hote hain. Resource identity ka hissa nahi hote (path variables ke unlike). URLs ko bookmarkable aur cacheable rakho. Sensitive data ke liye avoid karo (logs mein visible hote hain)."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Format: ?key1=value1&key2=value2",
            "Ideal for optional, non-hierarchical data",
            "Values are URL-encoded (spaces = %20 or +)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "/api/users?active=true&sort=name&direction=asc",
              "/products?minPrice=100&maxPrice=500&inStock=true"
            ]
          }
        },
        {
          "id": "requestbody",
          "title": "@RequestBody",
          "explanations": {
            "english": "@RequestBody binds the HTTP request body (JSON/XML) to a Java object. Spring uses HttpMessageConverters (like Jackson) for deserialization. Works with POST, PUT, PATCH. Add @Valid to trigger JSR-303 validation. Never use with GET/DELETE (they shouldn't have bodies per HTTP spec).",
            "hinglish": "@RequestBody HTTP request body (JSON/XML) ko Java object se bind karta hai. Spring deserialization ke liye HttpMessageConverters (Jackson jaise) use karta hai. POST, PUT, PATCH ke saath kaam karta hai. JSR-303 validation trigger karne ke liye @Valid add karo. Kabhi GET/DELETE ke saath use nahi karna chahiye (HTTP spec ke hisaab se unke paas bodies nahi hone chahiye)."
          },
          "code": {
            "title": "Binding Request Body",
            "language": "java",
            "content": "@PostMapping(\"/register\")\npublic ResponseEntity<User> registerUser(\n        @Valid @RequestBody UserRegistrationDTO dto) {\n    \n    User newUser = userService.register(dto);\n    return ResponseEntity.status(HttpStatus.CREATED).body(newUser);\n}\n\n// Request Body (JSON):\n// {\n//   \"email\": \"user@test.com\",\n//   \"password\": \"secure123\",\n//   \"name\": \"John Doe\"\n// }"
          },
          "codeExplanations": {
            "english": "JSON body automatically converted to UserRegistrationDTO object. @Valid triggers validation (e.g., @Email on email field). If validation fails, Spring throws MethodArgumentNotValidException (handled globally). Never expose entity classes directly‚Äîuse DTOs.",
            "hinglish": "JSON body automatically UserRegistrationDTO object mein convert ho jata hai. @Valid validation trigger karta hai (jaise email field par @Email). Agar validation fail hoti hai, Spring MethodArgumentNotValidException throw karta hai (globally handle hota hai). Kabhi bhi directly entity classes expose nahi karni chahiye‚ÄîDTOs use karo."
          },
          "keyPoints": [
            "Requires content-type header: application/json or application/xml",
            "Use DTOs (Data Transfer Objects), not JPA entities, for security",
            "Add @Valid for automatic input validation with error messages"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "json-payloads",
          "title": "JSON Payloads",
          "explanations": {
            "english": "JSON (JavaScript Object Notation) is the standard format for REST API request/response bodies. Lightweight, human-readable, language-agnostic. Spring Boot auto-configures Jackson library to serialize/deserialize JSON. Use @RequestBody to receive JSON, return objects directly for automatic JSON conversion. Configure with application.properties (e.g., spring.jackson.indent-output=true).",
            "hinglish": "JSON (JavaScript Object Notation) REST API request/response bodies ka standard format hai. Lightweight, human-readable, language-agnostic. Spring Boot Jackson library ko serialize/deserialize JSON ke liye auto-configure karta hai. JSON receive karne ke liye @RequestBody use karo, objects directly return karo automatic JSON conversion ke liye. application.properties se configure karo (jaise spring.jackson.indent-output=true)."
          },
          "code": {
            "title": "JSON Handling Example",
            "language": "java",
            "content": "// application.properties\nspring.jackson.serialization.indent_output=true\nspring.jackson.default-property-inclusion=non_null\n\n// Controller method\n@PostMapping(\"/api/data\")\npublic DataResponse processData(@RequestBody DataRequest request) {\n    // request is Java object from JSON\n    return service.process(request); // Auto-converted to JSON\n}\n\n// Sample JSON Request:\n// {\n//   \"id\": 101,\n//   \"items\": [\"A\", \"B\"],\n//   \"metadata\": {\"source\": \"web\"}\n// }"
          },
          "codeExplanations": {
            "english": "Jackson converts incoming JSON to DataRequest object. Outgoing DataResponse object auto-converted to JSON. Properties file configures pretty-print and skips null fields. Spring handles Content-Type: application/json automatically.",
            "hinglish": "Jackson aane wale JSON ko DataRequest object mein convert karta hai. Jaane wala DataResponse object automatically JSON mein convert ho jata hai. Properties file pretty-print configure karta hai aur null fields skip karta hai. Spring Content-Type: application/json automatically handle karta hai."
          },
          "keyPoints": [
            "Default content-type for Spring Boot REST APIs",
            "Jackson library handles all JSON serialization/deserialization",
            "Configure globally via application.properties or @Json annotations"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "xml-payloads",
          "title": "XML Payloads",
          "explanations": {
            "english": "XML payloads are supported via JAXB (Java Architecture for XML Binding). Add spring-boot-starter-web + jackson-dataformat-xml dependency. Spring uses Jackson XML module or JAXB converters. Less common than JSON in modern APIs but required for legacy systems. Content-Type header must be application/xml. Use @XmlRootElement on DTOs.",
            "hinglish": "XML payloads JAXB (Java Architecture for XML Binding) ke through supported hain. spring-boot-starter-web + jackson-dataformat-xml dependency add karo. Spring Jackson XML module ya JAXB converters use karta hai. Modern APIs mein JSON se kam common hai lekin legacy systems ke liye zaroori hai. Content-Type header application/xml hona chahiye. DTOs par @XmlRootElement use karo."
          },
          "code": {
            "title": "XML Support Configuration",
            "language": "java",
            "content": "// pom.xml dependency\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n\n// DTO with JAXB annotation\n@XmlRootElement(name = \"user\")\npublic class UserDTO {\n    private String name;\n    private String email;\n    // getters/setters\n}\n\n// Controller\n@PostMapping(value = \"/xml\", consumes = MediaType.APPLICATION_XML_VALUE)\npublic UserDTO handleXml(@RequestBody UserDTO user) {\n    return userService.process(user);\n}"
          },
          "codeExplanations": {
            "english": "Adding Jackson XML dependency enables automatic XML support. @XmlRootElement marks DTO for XML binding. consumes = MediaType.APPLICATION_XML_VALUE ensures endpoint only accepts XML. Spring auto-converts XML body to UserDTO and back.",
            "hinglish": "Jackson XML dependency add karne se automatic XML support enable hota hai. @XmlRootElement DTO ko XML binding ke liye mark karta hai. consumes = MediaType.APPLICATION_XML_VALUE ensure karta hai ki endpoint sirf XML accept kare. Spring XML body ko automatically UserDTO mein aur wapas convert karta hai."
          },
          "keyPoints": [
            "Requires additional dependency: jackson-dataformat-xml",
            "Use consumes/produces attributes to specify XML endpoints",
            "Legacy systems integration; JSON preferred for new APIs"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "response-handling",
          "title": "Response Handling üì§",
          "explanations": {
            "english": "Spring Boot simplifies HTTP response creation. Return objects directly from @RestController methods‚ÄîSpring auto-converts to JSON/XML. For fine-grained control (status codes, headers), use ResponseEntity. Global exception handling via @ControllerAdvice ensures consistent error responses across all endpoints.",
            "hinglish": "Spring Boot HTTP response creation ko simplify karta hai. @RestController methods se directly objects return karo‚ÄîSpring automatically JSON/XML mein convert karta hai. Fine-grained control (status codes, headers) ke liye ResponseEntity use karo. @ControllerAdvice ke through global exception handling ensure karta hai ki saare endpoints par consistent error responses ho."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Return objects directly for 200 OK with auto-serialized body",
            "ResponseEntity for custom status codes, headers, or body",
            "@ControllerAdvice centralizes exception handling for uniform errors"
          ],
          "extras": {
            "flowDiagram": "Controller Method Return ‚Üí Spring Converts to HTTP Response\n‚îÇ\n‚îú‚îÄ Plain Object ‚Üí 200 OK + JSON Body\n‚îú‚îÄ ResponseEntity ‚Üí Custom Status/Headers/Body\n‚îî‚îÄ Exception ‚Üí @ControllerAdvice ‚Üí Standard Error JSON",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "responsebody",
          "title": "@ResponseBody",
          "explanations": {
            "english": "@ResponseBody indicates a method's return value should be bound to the web response body (not a view name). In @RestController classes, it's implicit on all methods. In @Controller classes, add it per method to return data (JSON/XML) instead of view names. Spring uses HttpMessageConverters to serialize the object.",
            "hinglish": "@ResponseBody batata hai ki method ka return value web response body se bind hona chahiye (view name nahi). @RestController classes mein, ye saare methods par implicit hota hai. @Controller classes mein, data (JSON/XML) return karne ke liye ise har method par add karo view names ke bajaye. Spring object ko serialize karne ke liye HttpMessageConverters use karta hai."
          },
          "code": {
            "title": "@ResponseBody in @Controller",
            "language": "java",
            "content": "@Controller\npublic class MixedController {\n    \n    // Returns view name 'dashboard'\n    @GetMapping(\"/dashboard\")\n    public String showDashboard(Model model) {\n        model.addAttribute(\"stats\", getStats());\n        return \"dashboard\";\n    }\n    \n    // Returns JSON data directly\n    @GetMapping(\"/api/stats\")\n    @ResponseBody\n    public Stats getStats() {\n        return new Stats(100, 50);\n    }\n}"
          },
          "codeExplanations": {
            "english": "showDashboard() returns 'dashboard' ‚Üí ViewResolver finds template. getStats() has @ResponseBody ‚Üí Stats object serialized to JSON. Without @ResponseBody, Spring would look for a view named 'Stats{...}'.",
            "hinglish": "showDashboard() 'dashboard' return karta hai ‚Üí ViewResolver template dhundhta hai. getStats() mein @ResponseBody hai ‚Üí Stats object JSON mein serialize ho jata hai. @ResponseBody ke bina, Spring 'Stats{...}' naam ke view ko dhundhta."
          },
          "keyPoints": [
            "Required in @Controller classes to return raw data",
            "Implicit in all methods of @RestController classes",
            "Triggers HttpMessageConverters (Jackson for JSON)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "responseentity",
          "title": "ResponseEntity",
          "explanations": {
            "english": "ResponseEntity gives full control over the HTTP response: status code, headers, and body. Use it when you need custom responses (e.g., 201 Created with Location header, 204 No Content, or custom headers). Builder pattern makes it readable. Ideal for precise REST semantics.",
            "hinglish": "ResponseEntity HTTP response par full control deta hai: status code, headers, aur body. Jab aapko custom responses ki zaroorat ho (jaise 201 Created Location header ke saath, 204 No Content, ya custom headers) ise use karo. Builder pattern ise readable banata hai. Precise REST semantics ke liye perfect."
          },
          "code": {
            "title": "ResponseEntity Usage",
            "language": "java",
            "content": "@PostMapping\npublic ResponseEntity<User> createUser(@RequestBody User user) {\n    User saved = userService.save(user);\n    \n    // Build 201 Created with Location header\n    URI location = ServletUriComponentsBuilder\n        .fromCurrentRequest()\n        .path(\"/{id}\")\n        .buildAndExpand(saved.getId())\n        .toUri();\n    \n    return ResponseEntity\n        .created(location) // Sets 201 + Location header\n        .body(saved);\n}\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity<User> getUser(@PathVariable Long id) {\n    return userService.findById(id)\n        .map(ResponseEntity::ok)\n        .orElse(ResponseEntity.notFound().build());\n}"
          },
          "codeExplanations": {
            "english": "createUser() returns 201 Created with Location header pointing to new resource URL. getUser() returns 200 with user or 404 if not found. ResponseEntity.ok() = 200, notFound().build() = 404. Chain methods for clean, expressive responses.",
            "hinglish": "createUser() new resource URL par pointing Location header ke saath 201 Created return karta hai. getUser() user ke saath 200 ya agar nahi milta to 404 return karta hai. ResponseEntity.ok() = 200, notFound().build() = 404. Clean, expressive responses ke liye methods chain karo."
          },
          "keyPoints": [
            "Set custom HTTP status codes (201, 204, 400, etc.)",
            "Add response headers (Location, Cache-Control, Custom headers)",
            "Use builder methods: ok(), created(), notFound(), badRequest()"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "custom-status",
          "title": "Custom Status Codes",
          "explanations": {
            "english": "HTTP status codes communicate request outcome. Use standard codes: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 404 (Not Found), 500 (Server Error). ResponseEntity.status(HttpStatus.XXX) sets custom codes. Never return 200 for errors‚Äîclients rely on status codes for logic.",
            "hinglish": "HTTP status codes request outcome batate hain. Standard codes use karo: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 404 (Not Found), 500 (Server Error). ResponseEntity.status(HttpStatus.XXX) custom codes set karta hai. Errors ke liye kabhi 200 mat return karo‚Äîclients logic ke liye status codes par rely karte hain."
          },
          "code": {
            "title": "Setting Status Codes",
            "language": "java",
            "content": "// 201 Created with resource location\nreturn ResponseEntity.created(locationUri).body(resource);\n\n// 204 No Content (empty body)\nreturn ResponseEntity.noContent().build();\n\n// 400 Bad Request with error details\nreturn ResponseEntity.badRequest()\n    .body(new ErrorResponse(\"Invalid email format\"));\n\n// 409 Conflict\nif (userExists(email)) {\n    return ResponseEntity.status(HttpStatus.CONFLICT)\n        .body(new ErrorResponse(\"Email already registered\"));\n}"
          },
          "codeExplanations": {
            "english": "created() sets 201 + Location header. noContent() sets 204 (no body). badRequest() sets 400. status(HttpStatus.CONFLICT) sets 409. Always pair non-2xx codes with meaningful error bodies for clients.",
            "hinglish": "created() 201 + Location header set karta hai. noContent() 204 set karta hai (koi body nahi). badRequest() 400 set karta hai. status(HttpStatus.CONFLICT) 409 set karta hai. Hamesha non-2xx codes ko clients ke liye meaningful error bodies ke saath pair karo."
          },
          "keyPoints": [
            "2xx = Success, 4xx = Client error, 5xx = Server error",
            "201 Created must include Location header with new resource URL",
            "204 No Content has empty body‚Äîdon't return data with it"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "headers",
          "title": "Response Headers",
          "explanations": {
            "english": "HTTP headers carry metadata about the response: Content-Type, Cache-Control, Location, custom headers. Use ResponseEntity headers() method to add them. Common uses: pagination (Link header), caching directives, CORS headers, or business-specific metadata (e.g., X-RateLimit-Remaining).",
            "hinglish": "HTTP headers response ke baare mein metadata le kar aate hain: Content-Type, Cache-Control, Location, custom headers. Unhe add karne ke liye ResponseEntity headers() method use karo. Common uses: pagination (Link header), caching directives, CORS headers, ya business-specific metadata (jaise X-RateLimit-Remaining)."
          },
          "code": {
            "title": "Adding Response Headers",
            "language": "java",
            "content": "@GetMapping(\"/reports/{id}\")\npublic ResponseEntity<byte[]> getReport(@PathVariable String id) {\n    byte[] pdf = reportService.generate(id);\n    \n    return ResponseEntity.ok()\n        .contentType(MediaType.APPLICATION_PDF)\n        .header(HttpHeaders.CONTENT_DISPOSITION, \n                \"attachment; filename=report-\" + id + \".pdf\")\n        .header(\"X-Report-Generated\", Instant.now().toString())\n        .body(pdf);\n}\n\n// Response Headers:\n// Content-Type: application/pdf\n// Content-Disposition: attachment; filename=report-123.pdf\n// X-Report-Generated: 2026-01-27T10:30:00Z"
          },
          "codeExplanations": {
            "english": "Sets Content-Type to PDF. Content-Disposition triggers 'Save As' dialog in browsers. Custom header X-Report-Generated adds metadata. Use HttpHeaders constants for standard headers to avoid typos.",
            "hinglish": "Content-Type ko PDF par set karta hai. Content-Disposition browsers mein 'Save As' dialog trigger karta hai. Custom header X-Report-Generated metadata add karta hai. Typos avoid karne ke liye standard headers ke liye HttpHeaders constants use karo."
          },
          "keyPoints": [
            "Use HttpHeaders constants (CONTENT_TYPE, CACHE_CONTROL) for safety",
            "Custom headers prefix with 'X-' (e.g., X-Request-ID)",
            "Critical for caching, security (CORS), and client behavior"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "body",
          "title": "Response Body",
          "explanations": {
            "english": "The response body contains the actual data (JSON/XML). In Spring Boot, return objects directly from controller methods‚ÄîJackson serializes them automatically. For errors, return standardized error objects (not raw exceptions). Use DTOs to control exposed fields. Never expose JPA entities directly (security risk).",
            "hinglish": "Response body actual data (JSON/XML) contain karta hai. Spring Boot mein, controller methods se directly objects return karo‚ÄîJackson unhe automatically serialize karta hai. Errors ke liye, standardized error objects return karo (raw exceptions nahi). Exposed fields control karne ke liye DTOs use karo. Kabhi bhi directly JPA entities expose nahi karni chahiye (security risk)."
          },
          "code": {
            "title": "Response Body Best Practices",
            "language": "java",
            "content": "// ‚úÖ Good: DTO for response\npublic class UserResponse {\n    private Long id;\n    private String email;\n    private String name;\n    // No password field!\n}\n\n@GetMapping(\"/{id}\")\npublic UserResponse getUser(@PathVariable Long id) {\n    User user = userService.findById(id);\n    return modelMapper.map(user, UserResponse.class);\n}\n\n// ‚ùå Avoid: Returning JPA entity directly\n// public User getUser(...) { ... } // Exposes password, internal fields!"
          },
          "codeExplanations": {
            "english": "UserResponse DTO exposes only safe fields (id, email, name). ModelMapper converts internal User entity to DTO. Prevents accidental exposure of sensitive data (passwords, tokens). Always validate what clients receive.",
            "hinglish": "UserResponse DTO sirf safe fields (id, email, name) expose karta hai. ModelMapper internal User entity ko DTO mein convert karta hai. Sensitive data (passwords, tokens) ke accidental exposure ko rokta hai. Hamesha validate karo ki clients kya receive kar rahe hain."
          },
          "keyPoints": [
            "Always use DTOs‚Äînot JPA entities‚Äîfor responses",
            "Exclude sensitive fields (passwords, tokens, internal IDs)",
            "Standardize error responses: {\"error\": \"message\", \"timestamp\": \"...\"}"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "global-exception-handling",
          "title": "Global Exception Handling üåç",
          "explanations": {
            "english": "Global exception handling centralizes error response logic using @ControllerAdvice. Catches exceptions across all controllers. Define @ExceptionHandler methods for specific exceptions (e.g., ResourceNotFoundException). Return consistent error JSON with status code, message, timestamp. Avoids repetitive try-catch in every controller.",
            "hinglish": "Global exception handling @ControllerAdvice ka use karke error response logic ko centralize karta hai. Saare controllers par exceptions catch karta hai. Specific exceptions (jaise ResourceNotFoundException) ke liye @ExceptionHandler methods define karo. Status code, message, timestamp ke saath consistent error JSON return karo. Har controller mein repetitive try-catch se bachata hai."
          },
          "code": {
            "title": "Global Exception Handler",
            "language": "java",
            "content": "@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(\n            ResourceNotFoundException ex, WebRequest request) {\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.NOT_FOUND.value(),\n            ex.getMessage(),\n            LocalDateTime.now(),\n            request.getDescription(false)\n        );\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidation(\n            MethodArgumentNotValidException ex) {\n        \n        String errors = ex.getBindingResult().getFieldErrors().stream()\n            .map(e -> e.getField() + \": \" + e.getDefaultMessage())\n            .collect(Collectors.joining(\"; \"));\n        \n        ErrorResponse error = new ErrorResponse(\n            HttpStatus.BAD_REQUEST.value(),\n            \"Validation Failed: \" + errors,\n            LocalDateTime.now(),\n            null\n        );\n        return ResponseEntity.badRequest().body(error);\n    }\n}"
          },
          "codeExplanations": {
            "english": "@ControllerAdvice applies to all controllers. handleNotFound() catches ResourceNotFoundException ‚Üí returns 404 JSON. handleValidation() catches validation errors from @Valid ‚Üí returns 400 with field errors. ErrorResponse is a custom DTO for uniform errors.",
            "hinglish": "@ControllerAdvice saare controllers par apply hota hai. handleNotFound() ResourceNotFoundException catch karta hai ‚Üí 404 JSON return karta hai. handleValidation() @Valid se validation errors catch karta hai ‚Üí field errors ke saath 400 return karta hai. ErrorResponse uniform errors ke liye custom DTO hai."
          },
          "keyPoints": [
            "One place to handle all application exceptions",
            "Return standardized error format for all endpoints",
            "Log errors centrally before returning response"
          ],
          "extras": {
            "flowDiagram": "Exception in Controller ‚Üí @ControllerAdvice ‚Üí @ExceptionHandler Method ‚Üí ErrorResponse JSON",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "controlleradvice",
          "title": "@ControllerAdvice",
          "explanations": {
            "english": "@ControllerAdvice is a specialization of @Component for global exception handling, data binding, or model attributes across all @Controller classes. Typically contains @ExceptionHandler methods. Can target specific packages/controllers with basePackages attribute. Essential for clean, maintainable error handling in REST APIs.",
            "hinglish": "@ControllerAdvice @Component ka ek specialization hai global exception handling, data binding, ya model attributes ke liye saare @Controller classes par. Aam taur par @ExceptionHandler methods contain karta hai. basePackages attribute se specific packages/controllers target kar sakta hai. REST APIs mein clean, maintainable error handling ke liye zaroori."
          },
          "code": {
            "title": "@ControllerAdvice Configuration",
            "language": "java",
            "content": "// Handles exceptions for all controllers in com.app.web package\n@ControllerAdvice(basePackages = \"com.app.web\")\npublic class ApiExceptionHandler {\n    \n    // Handles exceptions globally\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ApiError> handleGeneric(\n            Exception ex, WebRequest request) {\n        \n        ApiError error = new ApiError(\n            HttpStatus.INTERNAL_SERVER_ERROR.value(),\n            \"Server error: \" + ex.getMessage(),\n            System.currentTimeMillis(),\n            request.getDescription(false)\n        );\n        \n        // Log error details internally\n        logger.error(\"Unhandled exception\", ex);\n        \n        return ResponseEntity\n            .status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(error);\n    }\n}"
          },
          "codeExplanations": {
            "english": "basePackages restricts advice to controllers in specified package. handleGeneric() catches any unhandled exception ‚Üí logs internally, returns 500 error JSON. ApiError DTO standardizes error format. Never expose raw exception messages to clients in production.",
            "hinglish": "basePackages advice ko specified package ke controllers tak limit karta hai. handleGeneric() kisi bhi unhandled exception ko catch karta hai ‚Üí internally logs karta hai, 500 error JSON return karta hai. ApiError DTO error format ko standardize karta hai. Production mein kabhi bhi clients ko raw exception messages expose nahi karni chahiye."
          },
          "keyPoints": [
            "Apply globally or to specific controller packages",
            "Combine with @ExceptionHandler for centralized error responses",
            "Log errors internally but return sanitized messages to clients"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Use forÁªü‰∏Ä error format across microservices",
              "Add @InitBinder in @ControllerAdvice for global date formatting"
            ]
          }
        }
      ]
    },
        {
      "id": "section-1",
      "title": "üå± Spring Data JPA & Hibernate Fundamentals",
      "intro": "Build a strong foundation with Spring Data JPA and Hibernate‚Äîthe powerhouse duo for object-relational mapping and database operations in Spring Boot. Learn repository patterns, entity mapping, and query techniques.",
      "topics": [
        {
          "id": "topic-1-1",
          "title": "üìö Repository Interfaces: CrudRepository vs JpaRepository",
          "explanations": {
            "english": "Repository interfaces act as bridges between your application and database. CrudRepository provides basic CRUD operations (save, findById, delete). JpaRepository extends CrudRepository with JPA-specific features like flushing persistence context, batch deletes, and pagination support. You simply declare an interface extending these‚ÄîSpring Data auto-generates the implementation at runtime.",
            "hinglish": "Repository interfaces aapke application aur database ke beech ka bridge hain. CrudRepository basic CRUD operations deta hai (save, findById, delete). JpaRepository CrudRepository ko extend karta hai aur JPA-specific features jaise persistence context flush karna, batch deletes, aur pagination support add karta hai. Aapko bas ek interface banana hai inko extend karke‚ÄîSpring Data runtime pe khud implementation generate kar deta hai."
          },
          "code": {
            "title": "User Repository Implementation",
            "language": "java",
            "content": "public interface UserRepository extends JpaRepository<User, Long> {\n    // Auto-implemented methods:\n    // Optional<User> findById(Long id);\n    // User save(User user);\n    // void deleteById(Long id);\n    // Page<User> findAll(Pageable pageable);\n}"
          },
          "codeExplanations": {
            "english": "This interface extends JpaRepository with User entity and Long ID type. Spring Data automatically implements all CRUD and pagination methods. No boilerplate code needed‚Äîjust declare the interface!",
            "hinglish": "Yeh interface JpaRepository ko User entity aur Long ID type ke saath extend karta hai. Spring Data khud-ba-khud saare CRUD aur pagination methods implement kar deta hai. Koi boilerplate code ki zaroorat nahi‚Äîbas interface declare karo!"
          },
          "keyPoints": [
            "CrudRepository = Basic CRUD operations (Create, Read, Update, Delete)",
            "JpaRepository = Adds JPA-specific methods (flush, batch delete) + pagination/sorting",
            "Spring Data generates implementation at runtime‚Äîzero manual implementation needed"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "CrudRepository",
                "column2": "JpaRepository"
              },
              {
                "column1": "Basic CRUD methods only",
                "column2": "All CrudRepository methods + JPA-specific features"
              },
              {
                "column1": "No pagination support",
                "column2": "Built-in pagination & sorting (Pageable)"
              },
              {
                "column1": "Generic for any persistence tech",
                "column2": "JPA/Hibernate specific"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-1-2",
          "title": "üè∑Ô∏è Core Entity Annotations (@Entity, @Id, @GeneratedValue)",
          "explanations": {
            "english": "@Entity marks a Java class as a database table. @Id defines the primary key field. @GeneratedValue specifies how the primary key value is generated (e.g., AUTO for database-assigned IDs, IDENTITY for auto-increment columns). These annotations enable Hibernate to map objects to database rows automatically.",
            "hinglish": "@Entity ek Java class ko database table ke roop mein mark karta hai. @Id primary key field define karta hai. @GeneratedValue batata hai ki primary key value kaise generate hogi (jaise AUTO database-assigned IDs ke liye, IDENTITY auto-increment columns ke liye). Ye annotations Hibernate ko objects ko database rows ke saath automatically map karne mein madad karte hain."
          },
          "code": {
            "title": "User Entity with Core Annotations",
            "language": "java",
            "content": "@Entity\n@Table(name = \"users\")\npublic class User {\n    \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @Column(nullable = false, unique = true)\n    private String email;\n    \n    // Getters, setters, constructors\n}"
          },
          "codeExplanations": {
            "english": "@Entity maps User class to 'users' table. @Id marks 'id' as primary key. @GeneratedValue(strategy=IDENTITY) tells Hibernate to use database auto-increment. @Column adds constraints (non-null, unique) on email field.",
            "hinglish": "@Entity User class ko 'users' table ke saath map karta hai. @Id 'id' ko primary key mark karta hai. @GeneratedValue(strategy=IDENTITY) Hibernate ko batata hai ki database auto-increment use kare. @Column email field par constraints lagata hai (non-null, unique)."
          },
          "keyPoints": [
            "@Entity = Class becomes database table",
            "@Id = Mandatory primary key declaration",
            "@GeneratedValue = Auto-manages ID creation (IDENTITY, SEQUENCE, AUTO)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "GenerationType.IDENTITY: Uses database auto-increment (MySQL)",
              "GenerationType.SEQUENCE: Uses DB sequence object (PostgreSQL, Oracle)",
              "GenerationType.AUTO: Lets Hibernate choose best strategy per database"
            ]
          }
        },
        {
          "id": "topic-1-3",
          "title": "üîó Entity Associations (Relationships)",
          "explanations": {
            "english": "Associations define relationships between entities. @OneToOne (User ‚Üî Profile), @OneToMany (Department ‚Üî Employees), @ManyToOne (Employee ‚Üî Department), @ManyToMany (Student ‚Üî Course). Use FetchType.LAZY to load related data only when accessed (prevents performance issues). CascadeType controls if operations cascade to related entities.",
            "hinglish": "Associations entities ke beech relationships define karte hain. @OneToOne (User ‚Üî Profile), @OneToMany (Department ‚Üî Employees), @ManyToOne (Employee ‚Üî Department), @ManyToMany (Student ‚Üî Course). FetchType.LAZY ka use karo taaki related data sirf tab load ho jab access kiya jaye (performance issues se bachata hai). CascadeType control karta hai ki operations related entities tak cascade karein ya nahi."
          },
          "code": {
            "title": "Department with Employees (OneToMany)",
            "language": "java",
            "content": "@Entity\npublic class Department {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @OneToMany(mappedBy = \"department\", fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n    private List<Employee> employees;\n}\n\n@Entity\npublic class Employee {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"department_id\")\n    private Department department;\n}"
          },
          "codeExplanations": {
            "english": "Department has OneToMany relationship with Employee. 'mappedBy' shows Employee owns the relationship. FetchType.LAZY prevents loading all employees when fetching department. Employee uses @ManyToOne with @JoinColumn to define foreign key column.",
            "hinglish": "Department ka Employee ke saath OneToMany relationship hai. 'mappedBy' dikhata hai ki Employee relationship ka owner hai. FetchType.LAZY department fetch karte waqt saare employees load hone se rokta hai. Employee @ManyToOne aur @JoinColumn ka use karke foreign key column define karta hai."
          },
          "keyPoints": [
            "Always specify FetchType.LAZY for collections to avoid N+1 issues",
            "Owner side of relationship defines the foreign key (@JoinColumn)",
            "Use CascadeType carefully‚Äîonly where logical (e.g., delete department deletes employees?)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-1-4",
          "title": "üîç Derived Query Methods",
          "explanations": {
            "english": "Spring Data creates queries automatically from method names in repository interfaces. Follow naming conventions: 'findBy[Property]', 'findBy[Property]And[Property]', 'findBy[Property]OrderBy[Property]Desc'. Supports keywords like IsNull, Between, Like. No JPQL needed for simple queries‚ÄîSpring parses the method name at startup.",
            "hinglish": "Spring Data repository interfaces mein method names se automatically queries create karta hai. Naming conventions follow karo: 'findBy[Property]', 'findBy[Property]And[Property]', 'findBy[Property]OrderBy[Property]Desc'. IsNull, Between, Like jaise keywords support karta hai. Simple queries ke liye JPQL ki zaroorat nahi‚ÄîSpring startup pe method name parse kar leta hai."
          },
          "code": {
            "title": "Derived Query Examples",
            "language": "java",
            "content": "public interface UserRepository extends JpaRepository<User, Long> {\n    // Find by single property\n    Optional<User> findByEmail(String email);\n    \n    // Find by multiple properties\n    List<User> findByLastNameAndActive(String lastName, boolean active);\n    \n    // With sorting\n    List<User> findByCityOrderByJoinDateDesc(String city);\n    \n    // With special keywords\n    List<User> findByAgeBetween(int min, int max);\n    long countByActiveTrue();\n}"
          },
          "codeExplanations": {
            "english": "Method names become queries: findByEmail ‚Üí SELECT * FROM users WHERE email = ?. Spring validates these at startup. Return types can be Optional, List, long (for counts). OrderBy adds SQL ORDER BY clause.",
            "hinglish": "Method names queries ban jate hain: findByEmail ‚Üí SELECT * FROM users WHERE email = ?. Spring inhe startup pe validate kar leta hai. Return types Optional, List, long (counts ke liye) ho sakte hain. OrderBy SQL ORDER BY clause add karta hai."
          },
          "keyPoints": [
            "Method name must follow Spring Data naming conventions precisely",
            "Parameters must match property names in entity (case-sensitive)",
            "Startup failure occurs if method name is invalid‚Äîcatches errors early"
          ],
          "extras": {
            "flowDiagram": "User calls repository method ‚Üí Spring parses method name at startup ‚Üí Generates JPQL/SQL ‚Üí Executes query ‚Üí Returns results",
            "comparisonTable": [],
            "examples": [
              "findByEmailAndActive ‚Üí WHERE email = ? AND active = ?",
              "findByJoinDateAfter ‚Üí WHERE join_date > ?",
              "deleteByStatus ‚Üí DELETE FROM users WHERE status = ?"
            ]
          }
        },
        {
          "id": "topic-1-5",
          "title": "‚úçÔ∏è Custom Queries with @Query Annotation",
          "explanations": {
            "english": "Use @Query when derived methods aren't enough. Write JPQL (object-oriented queries) or native SQL directly in repository methods. Place @Query above the method declaration. For native SQL, set nativeQuery=true. Parameters use positional (?1) or named (:email) syntax. Enables complex queries while keeping repository clean.",
            "hinglish": "Jab derived methods kaam nahi karte tab @Query ka use karo. Repository methods mein directly JPQL (object-oriented queries) ya native SQL likho. @Query method declaration ke upar lagao. Native SQL ke liye nativeQuery=true set karo. Parameters positional (?1) ya named (:email) syntax use karte hain. Complex queries ko enable karta hai bina repository ko ganda kiye."
          },
          "code": {
            "title": "JPQL and Native Query Examples",
            "language": "java",
            "content": "public interface UserRepository extends JpaRepository<User, Long> {\n    \n    // JPQL query (default)\n    @Query(\"SELECT u FROM User u WHERE u.email = :email\")\n    Optional<User> findUserByEmail(@Param(\"email\") String email);\n    \n    // Native SQL query\n    @Query(value = \"SELECT * FROM users WHERE created_at > ?1\", nativeQuery = true)\n    List<User> findRecentUsers(Instant afterDate);\n}"
          },
          "codeExplanations": {
            "english": "First method uses JPQL (references entity names/properties). @Param binds named parameter. Second method uses raw SQL with positional parameter (?1) and nativeQuery=true. Spring handles parameter binding and result mapping automatically.",
            "hinglish": "Pehla method JPQL use karta hai (entity names/properties ko reference karta hai). @Param named parameter ko bind karta hai. Dusra method raw SQL positional parameter (?1) aur nativeQuery=true ke saath use karta hai. Spring automatically parameter binding aur result mapping handle karta hai."
          },
          "keyPoints": [
            "JPQL is database-agnostic (uses entity names), native SQL is DB-specific",
            "Always prefer JPQL unless you need DB-specific features",
            "Use @Param for named parameters to avoid index errors"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        }
      ]
    },
    {
      "id": "section-2",
      "title": "‚ö° Advanced Custom Queries",
      "intro": "Go beyond basic queries! Master JPQL, native SQL, pagination, and projections to write efficient, optimized database operations for complex application needs.",
      "topics": [
        {
          "id": "topic-2-1",
          "title": "üß† JPQL (Java Persistence Query Language)",
          "explanations": {
            "english": "JPQL is object-oriented query language for JPA. Queries use entity names and properties instead of table/column names (e.g., 'SELECT u FROM User u'). Supports joins, aggregates, and path expressions (u.department.name). Database-agnostic‚ÄîHibernate translates JPQL to SQL for your specific database. Safer than native SQL (prevents SQL injection via parameter binding).",
            "hinglish": "JPQL JPA ke liye object-oriented query language hai. Queries table/column names ki jagah entity names aur properties use karte hain (jaise 'SELECT u FROM User u'). Joins, aggregates, aur path expressions (u.department.name) support karta hai. Database-agnostic‚ÄîHibernate JPQL ko aapke specific database ke liye SQL mein translate karta hai. Native SQL se zyada safe (parameter binding se SQL injection rokta hai)."
          },
          "code": {
            "title": "Advanced JPQL Examples",
            "language": "java",
            "content": "@Query(\"SELECT u FROM User u WHERE u.active = true AND u.age > :minAge\")\nList<User> findActiveUsersOlderThan(@Param(\"minAge\") int minAge);\n\n@Query(\"SELECT new com.example.dto.UserSummary(u.id, u.name, COUNT(o)) \" +\n       \"FROM User u LEFT JOIN u.orders o GROUP BY u.id\")\nList<UserSummary> getUserOrderSummaries();"
          },
          "codeExplanations": {
            "english": "First query filters active users with parameter binding. Second query uses constructor expression to project results into a DTO (UserSummary). LEFT JOIN with GROUP BY counts orders per user. JPQL understands entity relationships‚Äîno manual join conditions needed.",
            "hinglish": "Pehla query parameter binding ke saath active users filter karta hai. Dusra query results ko DTO (UserSummary) mein project karne ke liye constructor expression use karta hai. LEFT JOIN GROUP BY ke saath har user ke orders count karta hai. JPQL entity relationships samajhta hai‚Äîmanual join conditions ki zaroorat nahi."
          },
          "keyPoints": [
            "JPQL queries entities, not tables‚Äîuse class/property names",
            "Constructor expressions enable DTO projections directly in query",
            "Automatic relationship handling (joins via entity associations)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "JPQL",
                "column2": "Native SQL"
              },
              {
                "column1": "Uses entity/property names",
                "column2": "Uses table/column names"
              },
              {
                "column1": "Database portable",
                "column2": "Database specific"
              },
              {
                "column1": "Safer (parameter binding)",
                "column2": "Risk of SQL injection if misused"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-2-2",
          "title": "‚öôÔ∏è Native SQL Queries",
          "explanations": {
            "english": "Use native SQL when you need database-specific features (window functions, CTEs) or complex optimizations. Set nativeQuery=true in @Query. Results can map to entities, DTOs, or Object[]. Always use parameter binding (?1 or :name) to prevent SQL injection. Best for read-only operations or when JPQL lacks required functionality.",
            "hinglish": "Jab aapko database-specific features (window functions, CTEs) ya complex optimizations ki zaroorat ho tab native SQL ka use karo. @Query mein nativeQuery=true set karo. Results entities, DTOs, ya Object[] mein map ho sakte hain. SQL injection se bachne ke liye hamesha parameter binding (?1 ya :name) ka use karo. Read-only operations ya jab JPQL mein required functionality na ho tab best hai."
          },
          "code": {
            "title": "Native SQL with DTO Mapping",
            "language": "java",
            "content": "@Query(value = \"SELECT u.id AS userId, u.name AS userName, \" +\n       \"COUNT(o.id) AS orderCount \" +\n       \"FROM users u LEFT JOIN orders o ON u.id = o.user_id \" +\n       \"WHERE u.created_at > ?1 \" +\n       \"GROUP BY u.id\", \n       nativeQuery = true)\nList<Object[]> findUserStats(Instant afterDate);"
          },
          "codeExplanations": {
            "english": "Raw SQL query using database column names. Returns Object[] where index 0=userId, 1=userName, 2=orderCount. Requires manual result processing. Use only when JPQL can't express the query. Always validate SQL for your target database version.",
            "hinglish": "Database column names ka use karke raw SQL query. Object[] return karta hai jahan index 0=userId, 1=userName, 2=orderCount. Manual result processing ki zaroorat hai. Sirf tab use karo jab JPQL query express nahi kar sakta. Hamesha apne target database version ke liye SQL validate karo."
          },
          "keyPoints": [
            "Escape hatch for database-specific optimizations",
            "Higher maintenance cost (breaks if DB schema changes)",
            "Critical: Always use parameter binding‚Äînever string concatenation"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Use case: PostgreSQL JSONB queries",
              "Use case: MySQL FULLTEXT search",
              "Use case: Complex window functions (ROW_NUMBER)"
            ]
          }
        },
        {
          "id": "topic-2-3",
          "title": "üìë Pagination & Sorting",
          "explanations": {
            "english": "Pagination splits large result sets into pages. Use Pageable parameter in repository methods. Returns Page<T> (contains content + metadata like total elements, page number). Sort specifies field(s) and direction. Critical for performance‚Äîavoids loading thousands of records at once. Spring Data handles OFFSET/FETCH or cursor-based pagination automatically.",
            "hinglish": "Pagination large result sets ko pages mein divide karta hai. Repository methods mein Pageable parameter ka use karo. Page<T> return karta hai (content + metadata jaise total elements, page number). Sort field(s) aur direction specify karta hai. Performance ke liye critical‚Äîek saath hazaaron records load hone se bachata hai. Spring Data automatically OFFSET/FETCH ya cursor-based pagination handle karta hai."
          },
          "code": {
            "title": "Pagination in Service Layer",
            "language": "java",
            "content": "// Repository\nPage<User> findByActiveTrue(Pageable pageable);\n\n// Service\npublic Page<UserDTO> getActiveUsers(int page, int size) {\n    Pageable pageable = PageRequest.of(page, size, Sort.by(\"joinDate\").descending());\n    Page<User> users = userRepository.findByActiveTrue(pageable);\n    return users.map(this::convertToDTO);\n}"
          },
          "codeExplanations": {
            "english": "Repository method accepts Pageable. Service creates PageRequest with page number (0-indexed), size, and sort direction. Page object contains content, total elements, total pages. map() transforms entities to DTOs efficiently. Frontend uses metadata for pagination controls.",
            "hinglish": "Repository method Pageable accept karta hai. Service page number (0-indexed), size, aur sort direction ke saath PageRequest banata hai. Page object content, total elements, total pages contain karta hai. map() entities ko efficiently DTOs mein transform karta hai. Frontend pagination controls ke liye metadata use karta hai."
          },
          "keyPoints": [
            "Page numbers are 0-indexed in Spring Data",
            "Page<T> includes metadata (totalElements, totalPages) for UI pagination",
            "Always set reasonable max page size to prevent abuse"
          ],
          "extras": {
            "flowDiagram": "Client requests page 2, size 20 ‚Üí Service creates Pageable ‚Üí Repository executes query with LIMIT/OFFSET ‚Üí Returns Page with content + metadata ‚Üí Service transforms to DTOs ‚Üí Client renders page with navigation controls",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-2-4",
          "title": "üéØ Projections (DTOs & Interfaces)",
          "explanations": {
            "english": "Projections fetch only required fields instead of full entities‚Äîreducing memory and network load. Two types: Interface-based (Spring creates proxy) or Class-based (DTO with constructor). Define projection interface/DTO, then repository method returns it. Ideal for lists where you don't need all entity data (e.g., user list showing only name/email).",
            "hinglish": "Projections full entities ki jagah sirf required fields fetch karte hain‚Äîmemory aur network load kam karte hain. Do types: Interface-based (Spring proxy banata hai) ya Class-based (DTO constructor ke saath). Projection interface/DTO define karo, phir repository method use return karega. Lists ke liye ideal jahan aapko saari entity data ki zaroorat nahi (jaise user list sirf name/email dikhane ke liye)."
          },
          "code": {
            "title": "Interface-Based Projection",
            "language": "java",
            "content": "// Projection interface\npublic interface UserSummary {\n    String getName();\n    String getEmail();\n    Long getOrderCount();\n}\n\n// Repository method\n@Query(\"SELECT u.name AS name, u.email AS email, COUNT(o) AS orderCount \" +\n       \"FROM User u LEFT JOIN u.orders o GROUP BY u.id\")\nList<UserSummary> findUserSummaries();"
          },
          "codeExplanations": {
            "english": "UserSummary interface defines getters for required fields. Spring Data dynamically creates implementation. Query uses aliases matching getter names (name, email, orderCount). No DTO class needed‚Äîlightweight and type-safe. Avoids over-fetching data.",
            "hinglish": "UserSummary interface required fields ke getters define karta hai. Spring Data dynamically implementation banata hai. Query getter names se match karne wale aliases use karta hai (name, email, orderCount). DTO class ki zaroorat nahi‚Äîlightweight aur type-safe. Over-fetching data se bachata hai."
          },
          "keyPoints": [
            "Reduces data transfer by 50-90% for list views",
            "Interface projections = zero implementation code",
            "Use closed projections (exact field names) for best performance"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "User list view: Only id, name, avatar needed ‚Üí Projection saves loading bio, settings, etc.",
              "Search results: Title, snippet, URL ‚Üí No need for full content",
              "Analytics dashboard: Aggregated counts per category"
            ]
          }
        }
      ]
    },
    {
      "id": "section-3",
      "title": "üîÑ Transaction Management",
      "intro": "Master transaction control in Spring Boot! Learn @Transactional annotation, propagation/isolation levels, and critical best practices to ensure data integrity while avoiding common pitfalls like N+1 queries and LazyInitializationException.",
      "topics": [
        {
          "id": "topic-3-1",
          "title": "üõ°Ô∏è @Transactional Annotation",
          "explanations": {
            "english": "@Transactional defines transaction boundaries. Apply to service layer methods (not repositories!). Spring starts transaction before method, commits on success, rolls back on RuntimeException. Default rollback only for unchecked exceptions‚Äîuse rollbackFor to customize. Keeps business logic atomic: all operations succeed or none do.",
            "hinglish": "@Transactional transaction boundaries define karta hai. Isko service layer methods par lagao (repositories par nahi!). Spring method se pehle transaction start karta hai, success par commit karta hai, RuntimeException par rollback karta hai. Default rollback sirf unchecked exceptions ke liye‚Äîcustomize karne ke liye rollbackFor use karo. Business logic ko atomic rakhta hai: ya toh saare operations succeed karenge ya koi nahi karega."
          },
          "code": {
            "title": "Transactional Service Method",
            "language": "java",
            "content": "@Service\npublic class OrderService {\n    \n    @Transactional(rollbackFor = Exception.class)\n    public Order createOrder(OrderRequest request) {\n        // 1. Save order header\n        Order order = orderRepository.save(new Order(request));\n        \n        // 2. Save order items\n        for (Item item : request.getItems()) {\n            orderItemRepository.save(new OrderItem(order, item));\n        }\n        \n        // 3. Update inventory\n        inventoryService.updateStock(request.getItems());\n        \n        return order; // Commit happens here\n    }\n}"
          },
          "codeExplanations": {
            "english": "Entire method runs in one transaction. If inventory update fails after saving order/items, everything rolls back. rollbackFor=Exception.class ensures rollback on any exception (not just RuntimeException). Critical for data consistency across multiple operations.",
            "hinglish": "Poora method ek hi transaction mein chalta hai. Agar inventory update order/items save karne ke baad fail hota hai, toh sab kuch rollback ho jata hai. rollbackFor=Exception.class ensure karta hai ki kisi bhi exception par rollback ho (sirf RuntimeException nahi). Multiple operations mein data consistency ke liye critical."
          },
          "keyPoints": [
            "Always apply @Transactional at service layer (business logic boundary)",
            "Default rollback only for RuntimeException/Error‚Äîcustomize with rollbackFor",
            "Transactions are thread-bound‚Äînever pass transactional objects between threads"
          ],
          "extras": {
            "flowDiagram": "Method call ‚Üí Spring opens transaction ‚Üí Execute business logic ‚Üí On success: COMMIT ‚Üí On exception: ROLLBACK ‚Üí Return result/throw exception",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-3-2",
          "title": "üîÄ Propagation Levels",
          "explanations": {
            "english": "Propagation defines transaction behavior when method calls another @Transactional method. REQUIRED (default): Join existing transaction or create new. REQUIRES_NEW: Always create new transaction (suspend current). NESTED: Create savepoint within current transaction. MANDATORY: Fail if no existing transaction. Choose based on whether operations should be atomic together or independent.",
            "hinglish": "Propagation define karta hai transaction behavior jab koi method doosre @Transactional method ko call karta hai. REQUIRED (default): Existing transaction join karo ya naya banao. REQUIRES_NEW: Hamesha naya transaction banao (current suspend karo). NESTED: Current transaction ke andar savepoint banao. MANDATORY: Agar existing transaction nahi hai toh fail karo. Choose karo based on whether operations ko saath atomic hona chahiye ya independent."
          },
          "code": {
            "title": "Propagation Example",
            "language": "java",
            "content": "@Service\npublic class AuditService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logAction(String action) {\n        // Always runs in NEW transaction\n        // Commits even if outer transaction rolls back\n        auditRepository.save(new AuditLog(action));\n    }\n}\n\n@Service\npublic class OrderService {\n    \n    @Transactional\n    public void processOrder() {\n        // Business logic...\n        auditService.logAction(\"ORDER_CREATED\"); // Outer transaction suspended\n    }\n}"
          },
          "codeExplanations": {
            "english": "logAction uses REQUIRES_NEW‚Äîruns in separate transaction. Audit log commits even if processOrder fails later. Outer transaction suspends during logAction execution. Critical for audit logs, notifications where success must be recorded independently.",
            "hinglish": "logAction REQUIRES_NEW use karta hai‚Äîalag transaction mein chalta hai. Audit log tab bhi commit hota hai agar processOrder baad mein fail ho jata hai. Outer transaction logAction execution ke dauraan suspend ho jata hai. Audit logs, notifications ke liye critical jahan success independently record karna zaroori hai."
          },
          "keyPoints": [
            "REQUIRED = Default (join or create)",
            "REQUIRES_NEW = Independent transaction (suspend current)",
            "Use REQUIRES_NEW for audit logs, notifications, non-critical operations"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Propagation Level",
                "column2": "Behavior"
              },
              {
                "column1": "REQUIRED (default)",
                "column2": "Join existing or create new"
              },
              {
                "column1": "REQUIRES_NEW",
                "column2": "Suspend current, create new"
              },
              {
                "column1": "MANDATORY",
                "column2": "Fail if no transaction exists"
              },
              {
                "column1": "NEVER",
                "column2": "Fail if transaction exists"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-3-3",
          "title": "üîí Isolation Levels",
          "explanations": {
            "english": "Isolation controls visibility of uncommitted changes between concurrent transactions. READ_UNCOMMITTED (risky‚Äîdirty reads), READ_COMMITTED (default in most DBs‚Äîno dirty reads), REPEATABLE_READ (no non-repeatable reads), SERIALIZABLE (highest‚Äîno phantom reads). Higher isolation = more locking = lower concurrency. Choose based on data sensitivity.",
            "hinglish": "Isolation concurrent transactions ke beech uncommitted changes ki visibility control karta hai. READ_UNCOMMITTED (risky‚Äîdirty reads), READ_COMMITTED (zyada tar DBs mein default‚Äîdirty reads nahi), REPEATABLE_READ (non-repeatable reads nahi), SERIALIZABLE (highest‚Äîphantom reads nahi). Higher isolation = zyada locking = kam concurrency. Data sensitivity ke hisaab se choose karo."
          },
          "code": {
            "title": "Setting Isolation Level",
            "language": "java",
            "content": "@Transactional(isolation = Isolation.REPEATABLE_READ)\npublic Account getAccountWithBalance(Long accountId) {\n    // Ensures balance doesn't change during this transaction\n    return accountRepository.findById(accountId)\n        .orElseThrow(() -> new AccountNotFoundException());\n}\n\n@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void updateProfile(User user) {\n    // Standard isolation for non-financial operations\n    userRepository.save(user);\n}"
          },
          "codeExplanations": {
            "english": "getAccountWithBalance uses REPEATABLE_READ to prevent balance changes during transaction (critical for financial ops). updateProfile uses default READ_COMMITTED‚Äîsufficient for profile updates. Database must support the isolation level; Spring delegates to JDBC driver.",
            "hinglish": "getAccountWithBalance transaction ke dauraan balance changes hone se rokne ke liye REPEATABLE_READ use karta hai (financial operations ke liye critical). updateProfile default READ_COMMITTED use karta hai‚Äîprofile updates ke liye kaafi hai. Database ko isolation level support karna chahiye; Spring JDBC driver ko delegate karta hai."
          },
          "keyPoints": [
            "READ_COMMITTED = Safe default for most operations",
            "REPEATABLE_READ = Required for financial calculations",
            "SERIALIZABLE = Heavy performance cost‚Äîuse sparingly"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Isolation Level",
                "column2": "Phenomena Prevented"
              },
              {
                "column1": "READ_UNCOMMITTED",
                "column2": "None (dirty reads possible)"
              },
              {
                "column1": "READ_COMMITTED",
                "column2": "Dirty reads"
              },
              {
                "column1": "REPEATABLE_READ",
                "column2": "Dirty + Non-repeatable reads"
              },
              {
                "column1": "SERIALIZABLE",
                "column2": "All (including phantom reads)"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-3-4",
          "title": "‚úÖ Transaction Best Practices",
          "explanations": {
            "english": "1. Keep transactions short‚Äîonly include DB operations. 2. Apply @Transactional at service layer (not controllers/repositories). 3. Avoid business logic inside transactions (validation before, processing after). 4. Use read-only=true for query-only methods (optimization hint). 5. Never call transactional method from same class (bypasses proxy‚Äîuse self-injection). 6. Test rollback behavior!",
            "hinglish": "1. Transactions ko chhota rakho‚Äîsirf DB operations include karo. 2. @Transactional ko service layer par lagao (controllers/repositories par nahi). 3. Transactions ke andar business logic avoid karo (validation pehle, processing baad mein). 4. Query-only methods ke liye read-only=true use karo (optimization hint). 5. Kabhi bhi same class se transactional method ko call mat karo (proxy bypass hota hai‚Äîself-injection use karo). 6. Rollback behavior test karo!"
          },
          "code": {
            "title": "Read-Only Optimization & Self-Invocation Fix",
            "language": "java",
            "content": "// Good: Read-only hint for queries\n@Transactional(readOnly = true)\npublic List<User> getAllUsers() {\n    return userRepository.findAll();\n}\n\n// BAD: Self-invocation bypasses transaction\npublic void process() {\n    saveData(); // @Transactional ignored!\n}\n\n// GOOD: Self-injection pattern\n@Autowired\nprivate OrderService self;\n\npublic void process() {\n    self.saveData(); // Transactional proxy invoked\n}\n\n@Transactional\npublic void saveData() { ... }"
          },
          "codeExplanations": {
            "english": "readOnly=true hints Hibernate to skip dirty checks‚Äîperformance boost for queries. Self-invocation problem: Calling saveData() directly bypasses Spring's transactional proxy. Solution: Inject self reference to go through proxy. Always verify transactions work via tests.",
            "hinglish": "readOnly=true Hibernate ko dirty checks skip karne ka hint deta hai‚Äîqueries ke liye performance boost. Self-invocation problem: saveData() ko directly call karna Spring ke transactional proxy ko bypass karta hai. Solution: Proxy se guzarni ke liye self reference inject karo. Hamesha tests ke zariye verify karo ki transactions kaam kar rahe hain."
          },
          "keyPoints": [
            "Short transactions = higher concurrency and fewer deadlocks",
            "readOnly=true improves query performance (Hibernate optimization)",
            "Test rollback scenarios‚Äîdon't assume transactions work"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Anti-pattern: Heavy PDF generation inside @Transactional method ‚Üí long lock time",
              "Anti-pattern: Calling private helper method with @Transactional ‚Üí ignored",
              "Best practice: Validate input ‚Üí start transaction ‚Üí save ‚Üí commit ‚Üí send email"
            ]
          }
        },
        {
          "id": "topic-3-5",
          "title": "‚ö†Ô∏è Common Pitfalls: N+1 & LazyInitializationException",
          "explanations": {
            "english": "N+1 Problem: Fetching 10 users triggers 1 query for users + 10 queries for their departments (if LAZY). Fix: Use JOIN FETCH in JPQL. LazyInitializationException: Accessing LAZY association after transaction closes (session detached). Fixes: 1) EAGER fetching (rarely), 2) JOIN FETCH, 3) Open Session In View (OSIV‚Äîdiscouraged), 4) DTO projections. Always profile queries!",
            "hinglish": "N+1 Problem: 10 users fetch karne se 1 query users ke liye + 10 queries unke departments ke liye trigger hote hain (agar LAZY hai). Fix: JPQL mein JOIN FETCH use karo. LazyInitializationException: Transaction band hone ke baad (session detached) LAZY association ko access karna. Fixes: 1) EAGER fetching (kam), 2) JOIN FETCH, 3) Open Session In View (OSIV‚Äîavoid karo), 4) DTO projections. Hamesha queries profile karo!"
          },
          "code": {
            "title": "Fixing N+1 with JOIN FETCH",
            "language": "java",
            "content": "// BAD: Triggers N+1 queries\nList<User> users = userRepository.findAll();\nfor (User u : users) {\n    System.out.println(u.getDepartment().getName()); // Lazy load per user\n}\n\n// GOOD: Single query with JOIN FETCH\n@Query(\"SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.department\")\nList<User> findAllWithDepartment();\n\n// BETTER: Projection (avoids entity overhead)\n@Query(\"SELECT new com.example.dto.UserDept(u.id, u.name, d.name) \" +\n       \"FROM User u LEFT JOIN u.department d\")\nList<UserDept> findUserDepartments();"
          },
          "codeExplanations": {
            "english": "First approach causes N+1: 1 query for users + N queries for departments. JOIN FETCH loads departments in single query. Projection is most efficient‚Äîfetches only needed fields into DTO. Always check SQL logs during development to catch N+1 early.",
            "hinglish": "Pehla approach N+1 cause karta hai: users ke liye 1 query + departments ke liye N queries. JOIN FETCH departments ko single query mein load karta hai. Projection sabse efficient hai‚Äîsirf required fields DTO mein fetch karta hai. Development ke dauraan hamesha SQL logs check karo N+1 ko jaldi pakadne ke liye."
          },
          "keyPoints": [
            "N+1 is silent performance killer‚Äîprofile queries in development",
            "LazyInitializationException = Accessing lazy data outside transaction",
            "Projections > JOIN FETCH > EAGER for performance and safety"
          ],
          "extras": {
            "flowDiagram": "N+1 Flow: 1. Query users (1 SQL) ‚Üí 2. Loop users ‚Üí 3. Access department per user (N SQL queries) ‚Üí Total: N+1 queries\nFix Flow: 1. Query with JOIN FETCH ‚Üí 2. Single SQL with JOIN ‚Üí 3. All data loaded in one go",
            "comparisonTable": [],
            "examples": [
              "N+1 symptom: 101 queries for 100 users + departments",
              "LazyInitializationException stack trace: 'failed to lazily initialize... no Session'",
              "Tool: Enable Hibernate statistics (spring.jpa.properties.hibernate.generate_statistics=true)"
            ]
          }
        }
      ]
    },
        {
      "id": "section-config-management",
      "title": "‚öôÔ∏è Configuration Management",
      "intro": "Learn to externalize application settings using Spring Boot's flexible configuration systems. Separate code from environment-specific values for maintainable, deployable applications.",
      "topics": [
        {
          "id": "topic-config-management-overview",
          "title": "üß† Configuration Management Overview",
          "explanations": {
            "english": "Configuration Management in Spring Boot lets you separate application settings (like ports, URLs, feature flags) from your code. Store configs externally in files, environment variables, or cloud services. Spring Boot automatically loads them at startup, making your app adaptable across dev, test, and production environments without code changes.",
            "hinglish": "Configuration Management ka matlab hai ki aap apne app ke settings (jaise port number, database URL) ko code se alag rakho. Inhe properties files, environment variables ya cloud services mein store karo. Spring Boot automatically inhe load kar leta hai jab app start hota hai. Isse aap bina code change kiye dev, test, production environments ke liye alag settings use kar sakte ho."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Externalize all environment-specific values (never hardcode secrets or URLs)",
            "Spring Boot follows a strict configuration precedence order (command line > environment variables > profile files > default files)",
            "Use relaxed binding: property names can use kebab-case, camelCase, or snake_case interchangeably"
          ],
          "extras": {
            "flowDiagram": "App Start ‚Üí Scan Config Sources (17 locations) ‚Üí Merge Values (higher priority wins) ‚Üí Inject into Beans",
            "comparisonTable": [
              {
                "column1": "Configuration Source",
                "column2": "Use Case"
              },
              {
                "column1": "application.properties",
                "column2": "Default simple key-value settings"
              },
              {
                "column1": "Environment Variables",
                "column2": "Cloud/platform deployments (e.g., Kubernetes)"
              },
              {
                "column1": "@ConfigurationProperties",
                "column2": "Type-safe grouping of related settings"
              }
            ],
            "examples": [
              "Database URL changes per environment",
              "Feature flags for gradual rollouts",
              "API keys/secrets injected at deploy time"
            ]
          }
        },
        {
          "id": "topic-app-properties",
          "title": "üìÑ application.properties",
          "explanations": {
            "english": "The simplest configuration file format in Spring Boot. Uses plain key-value pairs with dot notation for hierarchy. Loaded automatically from src/main/resources. Ideal for flat configurations with minimal nesting. Comments start with #. Spring Boot supports profile-specific variants like application-dev.properties.",
            "hinglish": "Ye Spring Boot ka sabse simple configuration file format hai. Isme aap key=value likhte ho, jaise server.port=8080. Hierarchy ke liye dot notation use karte hain (app.name=MyApp). Ye file automatically load hoti hai resources folder se. Agar settings thoda complex ho (jaise nested objects), tab YAML behtar hai. Comments ke liye # use karo."
          },
          "code": {
            "title": "src/main/resources/application.properties",
            "language": "properties",
            "content": "# Server Settings\nserver.port=8081\nserver.servlet.context-path=/api\n\n# Custom Application Properties\napp.name=ConfigDemo\napp.version=1.0.0\napp.feature.toggle=true\n\n# Database (H2)\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa"
          },
          "codeExplanations": {
            "english": "Lines starting with # are comments. server.port changes the default Tomcat port. Custom properties (app.*) can be injected into beans using @Value or @ConfigurationProperties. Spring Boot auto-configures components (like datasource) using spring.* prefixes.",
            "hinglish": "Jo lines # se shuru hoti hain woh comments hain. server.port Tomcat ka default port badalta hai. app.* se shuru hone wale properties aap khud define karte hain aur inhe beans mein inject kar sakte hain. spring.datasource.* properties Spring Boot ko batate hain ki database kaise configure karna hai."
          },
          "keyPoints": [
            "UTF-8 encoding recommended for non-ASCII characters",
            "Escape special characters: \\ for backslash, \\uXXXX for Unicode",
            "Profile-specific files override defaults (e.g., application-prod.properties)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "server.error.whitelabel.enabled=false ‚Üí Disable default error page",
              "logging.level.com.example=DEBUG ‚Üí Set package-specific log level"
            ]
          }
        },
        {
          "id": "topic-app-yml",
          "title": "üßæ application.yml",
          "explanations": {
            "english": "YAML (YAML Ain't Markup Language) offers a human-friendly format for hierarchical configurations. Uses indentation (spaces, NOT tabs) to denote structure. Ideal for nested properties (like lists or complex objects). Spring Boot loads application.yml automatically. Supports multi-document files with --- separators for profiles.",
            "hinglish": "YAML format hierarchical settings ko naturally dikhata hai. Indentation (spaces se, tabs nahi) se structure define hota hai. Agar aapke paas nested settings hain (jaise list of servers), YAML properties file se zyada readable hota hai. Dhyan rahe: indentation mein sirf spaces use karo, tabs error dega. --- se aap ek hi file mein multiple profiles define kar sakte hain."
          },
          "code": {
            "title": "src/main/resources/application.yml",
            "language": "yaml",
            "content": "server:\n  port: 8082\n  servlet:\n    context-path: /api\n\napp:\n  name: YAML-Demo\n  features:\n    - auth\n    - reporting\n    - notifications\n  social:\n    facebook:\n      app-id: \"fb_123\"\n      enabled: true\n\n---\n# Profile-specific section\nspring:\n  config:\n    activate:\n      on-profile: dev\nlogging:\n  level:\n    root: DEBUG"
          },
          "codeExplanations": {
            "english": "Indentation creates hierarchy: app.features is a list. app.social.facebook.app-id is a nested property. The --- separator starts a new document for the 'dev' profile. YAML is sensitive to indentation errors‚Äîalways use spaces. Strings with special characters (like underscores) should be quoted.",
            "hinglish": "Indentation se hierarchy banati hai: app.features ek list hai. app.social.facebook.app-id nested property hai. --- ke baad 'dev' profile ke specific settings hain. YAML indentation errors ko seriously leta hai‚Äîisliye hamesha spaces use karo. Agar value mein special characters hain (jaise underscore), usse quotes mein likho."
          },
          "keyPoints": [
            "Never use tabs for indentation‚Äîonly spaces (2 or 4 per level)",
            "Colon (:) must be followed by a space in key-value pairs",
            "Multi-document YAML files combine multiple profiles in one file"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "List configuration: app.supported-languages: [en, es, fr]",
              "Multi-line strings using | character"
            ]
          }
        },
        {
          "id": "topic-value-annotation",
          "title": "üìé @Value Annotation",
          "explanations": {
            "english": "@Value injects configuration values directly into Spring beans using SpEL (Spring Expression Language). Reference properties with ${property.name}. Supports default values (${property:default}). Best for injecting 1-2 simple values. Not ideal for many related properties‚Äîuse @ConfigurationProperties instead for type safety and validation.",
            "hinglish": "@Value annotation se aap configuration values ko seedha apne Java beans mein inject kar sakte hain. ${property.name} likhkar property ko refer karo. Agar property nahi milti, to default value de sakte hain: ${port:8080}. Ye 1-2 simple values ke liye accha hai. Lekin agar bahut saare related properties hain (jaise database settings), to @ConfigurationProperties use karo‚Äîwoh zyada safe aur maintainable hai."
          },
          "code": {
            "title": "Injecting Values with @Value",
            "language": "java",
            "content": "@Component\npublic class AppInfo {\n    \n    @Value(\"${app.name}\")\n    private String appName;\n    \n    @Value(\"${server.port:8080}\") // Default port if not set\n    private int serverPort;\n    \n    @Value(\"#{'${app.features}'.split(',')}\")) // SpEL to split string\n    private List<String> features;\n    \n    public void printInfo() {\n        System.out.println(\"App: \" + appName + \" on port \" + serverPort);\n    }\n}"
          },
          "codeExplanations": {
            "english": "@Value pulls values from Spring's Environment. ${app.name} fetches 'app.name' property. ${server.port:8080} uses 8080 if server.port is undefined. SpEL (#{...}) enables transformations like splitting comma-separated strings into lists. Avoid complex SpEL‚Äîkeep logic minimal.",
            "hinglish": "@Value Spring ke Environment se value leta hai. ${app.name} 'app.name' property ki value lega. ${server.port:8080} mein :8080 default value hai agar property set nahi hai. SpEL (#{...}) se aap string ko split kar sakte hain list mein. Complex logic yahan mat likho‚Äîsimple rakho."
          },
          "keyPoints": [
            "Throws IllegalStateException at startup if required property is missing (no default)",
            "Limited validation support‚Äîno built-in JSR-303 validation",
            "Harder to test‚Äîrequires Spring context or manual mocking"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-configuration-properties",
          "title": "Î¨∂ @ConfigurationProperties",
          "explanations": {
            "english": "@ConfigurationProperties binds external configuration to a strongly-typed Java bean. Group related properties under a prefix (e.g., @ConfigurationProperties(prefix = \"app\")). Enables IDE auto-completion, type safety, and metadata generation. Requires @EnableConfigurationProperties or @Component. Preferred over @Value for structured configurations.",
            "hinglish": "@ConfigurationProperties external settings ko ek structured Java class mein map karta hai. Jaise agar aapke paas app.name, app.version jaise properties hain, to ek class banao jisme ye fields ho aur @ConfigurationProperties(prefix=\"app\") lagao. Isse IDE aapko auto-complete dega, aur type errors compile time pe pakde jaayenge. @Value se behtar hai jab aapke paas related properties ka group ho."
          },
          "code": {
            "title": "Type-Safe Configuration Class",
            "language": "java",
            "content": "@Component\n@ConfigurationProperties(prefix = \"app\")\n@Data // Lombok for getters/setters\npublic class AppProperties {\n    private String name;\n    private String version;\n    private boolean featureToggle;\n    private Social social = new Social();\n    \n    @Data\n    public static class Social {\n        private String facebookAppId;\n        private boolean enabled;\n    }\n}\n\n// Usage in service\n@Service\npublic class NotificationService {\n    private final AppProperties appProps;\n    \n    public NotificationService(AppProperties appProps) {\n        this.appProps = appProps;\n    }\n    \n    public void send() {\n        if (appProps.getSocial().isEnabled()) {\n            // Use facebookAppId\n        }\n    }\n}"
          },
          "codeExplanations": {
            "english": "Prefix \"app\" maps to app.name, app.version, etc. Nested classes (Social) handle hierarchical properties (app.social.facebook-app-id). Lombok's @Data generates getters/setters. Constructor injection makes testing easy. Spring Boot validates and binds properties at startup. Add spring-boot-configuration-processor dependency for IDE metadata.",
            "hinglish": "Prefix \"app\" ke saath jo bhi properties hain (app.name, app.version) woh is class ke fields se match honge. Social inner class app.social.facebook-app-id jaise nested properties ko handle karega. Lombok @Data getters/setters automatically banata hai. Constructor injection se testing aasan hoti hai. Spring Boot startup pe properties ko validate aur bind karta hai."
          },
          "keyPoints": [
            "Enable configuration metadata: Add spring-boot-configuration-processor to pom.xml for IDE hints",
            "Relaxed binding converts property names: facebook-app-id ‚Üí facebookAppId",
            "Immutable configurations possible with @ConstructorBinding (Spring Boot 2.2+)"
          ],
          "extras": {
            "flowDiagram": "Properties File ‚Üí Spring Environment ‚Üí @ConfigurationProperties Binder ‚Üí Java Bean (with validation)",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-type-safe-config",
          "title": "üõ°Ô∏è Type-Safe Configuration",
          "explanations": {
            "english": "Type-safe configuration means using Java classes (with @ConfigurationProperties) instead of string-based lookups (@Value). Benefits: compile-time error checking, IDE refactoring support, auto-completion, and clear structure. Spring Boot validates types during binding‚Äîe.g., fails startup if a boolean property gets \"yes\" instead of true/false. Critical for large applications with many settings.",
            "hinglish": "Type-safe configuration ka matlab hai ki aap settings ko Java classes ke through handle karo, string-based lookups (@Value) ke bajaye. Fayde: agar aap field ka naam badlo, to compiler error dega; IDE aapko help karega; auto-complete milega; aur structure clear rahega. Spring Boot startup pe check karta hai ki saare values sahi type ke hain‚Äîjaise agar boolean property ke liye \"yes\" diya, to app start hi nahi hoga. Bade projects ke liye zaroori hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Prevents runtime errors from typos in property names (caught at compile time)",
            "Enables safe refactoring of configuration structures",
            "Generates metadata (META-INF/spring-configuration-metadata.json) for IDE autocomplete"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "@Value Approach",
                "column2": "@ConfigurationProperties Approach"
              },
              {
                "column1": "String-based lookups (${app.name})",
                "column2": "Strongly-typed Java objects"
              },
              {
                "column1": "Hard to refactor",
                "column2": "IDE-friendly refactoring"
              },
              {
                "column1": "No compile-time checks",
                "column2": "Type errors fail fast at startup"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-config-validation",
          "title": "‚úÖ Validation",
          "explanations": {
            "english": "Validate configuration values at startup using JSR-303 annotations (@NotBlank, @Min, @Pattern) on @ConfigurationProperties classes. Add @Validated to enable validation. Spring Boot fails fast if constraints are violated‚Äîpreventing runtime errors from bad configs. Combine with custom validators for complex rules. Essential for catching misconfigurations early in deployment pipelines.",
            "hinglish": "Startup pe hi configuration values ko validate karo JSR-303 annotations (@NotBlank, @Min) use karke @ConfigurationProperties class par. @Validated annotation lagao taaki validation enable ho. Agar koi value rule ke against hai (jaise port number negative), to Spring Boot app ko start hi nahi hone dega‚Äîruntime errors se bachao. Complex rules ke liye custom validators bana sakte hain. Deployment pipeline mein early error catch karne ke liye zaroori."
          },
          "code": {
            "title": "Validated Configuration Properties",
            "language": "java",
            "content": "@Component\n@ConfigurationProperties(prefix = \"app\")\n@Validated\n@Data\npublic class ValidatedAppProperties {\n    \n    @NotBlank(message = \"App name is required\")\n    private String name;\n    \n    @Pattern(regexp = \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\", message = \"Version must be semantic (e.g., 1.0.0)\")\n    private String version;\n    \n    @Min(value = 1024, message = \"Port must be >= 1024\")\n    @Max(value = 65535, message = \"Port must be <= 65535\")\n    private int serverPort;\n    \n    @Email(message = \"Admin email must be valid\")\n    private String adminEmail;\n}"
          },
          "codeExplanations": {
            "english": "@Validated triggers validation on this bean. @NotBlank ensures 'name' isn't empty. @Pattern uses regex for semantic versioning. @Min/@Max restrict port range. Invalid values throw BindException at startup with clear messages. Add spring-boot-starter-validation dependency to enable.",
            "hinglish": "@Validated is class par validation ko trigger karta hai. @NotBlank check karta hai ki 'name' khali na ho. @Pattern regex se version format validate karta hai. @Min/@Max port number ko valid range mein rakhte hain. Agar koi value galat hai, app start hote waqt clear error message ke saath ruk jayega. Validation enable karne ke liye spring-boot-starter-validation dependency add karo."
          },
          "keyPoints": [
            "Fails fast during application startup‚Äîno partial initialization",
            "Custom validators possible via @Constraint and ConstraintValidator",
            "Validation groups allow conditional validation per environment"
          ],
          "extras": {
            "flowDiagram": "App Start ‚Üí Load Properties ‚Üí Bind to @ConfigurationProperties ‚Üí Run Validators ‚Üí [Valid?] ‚Üí Proceed / Fail with Error",
            "comparisonTable": [],
            "examples": [
              "Validate database connection timeout range",
              "Ensure API endpoint URLs use https protocol",
              "Check feature flag names against allowed list"
            ]
          }
        }
      ]
    },
    {
      "id": "section-spring-profiles",
      "title": "üåç Spring Profiles",
      "intro": "Manage environment-specific configurations (dev, test, prod) and conditional bean registration. Activate profiles via multiple strategies to adapt your application behavior without code changes.",
      "topics": [
        {
          "id": "topic-profiles-overview",
          "title": "üß† Spring Profiles Overview",
          "explanations": {
            "english": "Spring Profiles allow you to define environment-specific beans and configurations. Create profile-specific files (application-dev.yml) or annotate beans with @Profile. Only beans/configs for active profiles load at runtime. Essential for separating dev databases, prod secrets, or feature flags. Profiles can be combined (e.g., dev,local) for granular control.",
            "hinglish": "Spring Profiles aapko alag-alag environments (dev, test, prod) ke liye alag beans aur settings define karne dete hain. Jaise dev environment ke liye H2 database, prod ke liye PostgreSQL. Profile-specific files banao (application-dev.properties) ya beans par @Profile annotation lagao. Sirf active profile ke beans load hote hain runtime pe. Aap multiple profiles bhi activate kar sakte hain (jaise dev aur local dono)."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Default profile is 'default'‚Äîactive if no other profile is set",
            "Multiple profiles can be active simultaneously (comma-separated)",
            "Profile-specific configs override default application.properties/yml"
          ],
          "extras": {
            "flowDiagram": "App Start ‚Üí Determine Active Profiles ‚Üí Load application.yml ‚Üí Load application-{profile}.yml (override) ‚Üí Register @Profile Beans",
            "comparisonTable": [],
            "examples": [
              "dev profile: Use H2 database, enable debug logs",
              "prod profile: Use PostgreSQL, disable stack traces in errors",
              "test profile: Mock external service beans"
            ]
          }
        },
        {
          "id": "topic-profile-specific-config",
          "title": "üìÅ Profile-Specific Config Files",
          "explanations": {
            "english": "Name files as application-{profile}.properties or application-{profile}.yml. Spring Boot auto-loads them when the profile is active. Place in src/main/resources. Values override defaults from application.properties. Supports YAML multi-document files with spring.config.activate.on-profile. Ideal for environment-specific settings like database URLs or feature toggles.",
            "hinglish": "Files ka naam rakho application-{profile}.properties (jaise application-prod.properties). Jab woh profile active hogi, Spring Boot automatically ye file load karega. Isme di gayi values default application.properties ki values ko override kar denge. YAML files mein aap --- ke baad spring.config.activate.on-profile: dev likhkar ek hi file mein multiple profiles define kar sakte hain."
          },
          "code": {
            "title": "application-prod.yml",
            "language": "yaml",
            "content": "spring:\n  datasource:\n    url: jdbc:postgresql://prod-db:5432/myapp\n    username: ${DB_USER}\n    password: ${DB_PASSWORD}\n  jpa:\n    hibernate:\n      ddl-auto: validate\n\napp:\n  feature:\n    analytics: true\n    debug-mode: false\n\nlogging:\n  level:\n    root: WARN"
          },
          "codeExplanations": {
            "english": "This config loads ONLY when 'prod' profile is active. Database credentials injected via environment variables (DB_USER, DB_PASSWORD). ddl-auto: validate prevents Hibernate from altering prod schema. debug-mode: false disables development features. Environment variables take precedence over file values for secrets.",
            "hinglish": "Ye settings sirf tab load hongi jab 'prod' profile active hogi. Database ke username/password environment variables se aayenge (jo securely set honge server pe). ddl-auto: validate Hibernate ko prod database schema change karne se rokta hai. debug-mode: false development features band karta hai. Secrets ke liye hamesha environment variables prefer karo files se."
          },
          "keyPoints": [
            "File naming convention is strict: application-{profile}.properties/yml",
            "Profile names are case-sensitive (use lowercase conventions)",
            "Cloud platforms (AWS, Kubernetes) inject profile names via environment variables"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "application-local.yml: Override API base URL for local testing",
              "application-test.yml: Set mock service endpoints"
            ]
          }
        },
        {
          "id": "topic-profile-annotation",
          "title": "üè∑Ô∏è @Profile Annotation",
          "explanations": {
            "english": "@Profile registers a Spring bean ONLY when specified profiles are active. Apply to @Component, @Service, @Configuration, or @Bean methods. Use logical operators: @Profile(\"!prod\") for non-prod, @Profile({\"dev\", \"test\"}) for multiple. Enables conditional infrastructure‚Äîe.g., in-memory database beans for dev, cloud storage beans for prod.",
            "hinglish": "@Profile annotation lagane se woh bean sirf tab create hota hai jab specified profile active ho. Isse aap conditionally beans define kar sakte hain‚Äîjaise dev profile ke liye H2 database bean, prod profile ke liye PostgreSQL bean. Aap logical operators bhi use kar sakte hain: @Profile(\"!prod\") matlab prod ke alawa sab profiles mein ye bean banega."
          },
          "code": {
            "title": "Conditional Bean Registration",
            "language": "java",
            "content": "@Configuration\npublic class DataSourceConfig {\n    \n    // Active ONLY in dev or local profiles\n    @Bean\n    @Profile({\"dev\", \"local\"})\n    public DataSource devDataSource() {\n        return new EmbeddedDatabaseBuilder()\n            .setType(EmbeddedDatabaseType.H2)\n            .addScript(\"schema.sql\")\n            .build();\n    }\n    \n    // Active ONLY in prod profile\n    @Bean\n    @Profile(\"prod\")\n    @ConfigurationProperties(\"spring.datasource\")\n    public DataSource prodDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n    \n    // Active when prod profile is NOT active\n    @Bean\n    @Profile(\"!prod\")\n    public EmailService mockEmailService() {\n        return new MockEmailService(); // Doesn't send real emails\n    }\n}"
          },
          "codeExplanations": {
            "english": "devDataSource() creates an in-memory H2 database for development. prodDataSource() uses production datasource properties. mockEmailService() activates only outside prod (safe for testing). Spring ignores beans whose profiles aren't active‚Äîno runtime overhead. Combine with @Primary for default beans.",
            "hinglish": "devDataSource() development ke liye temporary H2 database banata hai. prodDataSource() production ke liye configured datasource use karta hai. mockEmailService() sirf tab activate hota hai jab prod profile active nahi hai‚Äîtesting ke liye safe. Spring un beans ko ignore karta hai jinke profiles active nahi hain. @Primary annotation se aap default bean bhi specify kar sakte hain."
          },
          "keyPoints": [
            "Beans with inactive profiles are completely excluded from Spring context",
            "Use @Profile on @Configuration classes to group multiple beans",
            "Test classes support @ActiveProfiles for profile-specific tests"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-activation-strategies-overview",
          "title": "üöÄ Activation Strategies Overview",
          "explanations": {
            "english": "Activate Spring profiles through multiple strategies. Spring Boot checks sources in precedence order: command line > environment variables > JVM properties > default properties. Choose strategy based on deployment context: CLI for local runs, environment variables for containers/cloud, JVM properties for legacy systems. Multiple profiles can be combined (e.g., prod,aws).",
            "hinglish": "Spring profiles ko activate karne ke kai tarike hain. Spring Boot in sources ko priority ke hisaab se check karta hai: sabse pehle command line arguments, phir environment variables, phir JVM properties. Deployment ke hisaab se strategy chuno: local run ke liye CLI, cloud containers ke liye environment variables. Aap ek saath multiple profiles bhi activate kar sakte hain (jaise prod aur aws dono)."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Precedence order is critical: Higher priority sources override lower ones",
            "Never hardcode active profiles in application.properties",
            "Cloud platforms (Heroku, AWS) set profiles via environment variables"
          ],
          "extras": {
            "flowDiagram": "Check Sources in Order:\n1. Command Line (--spring.profiles.active=prod)\n2. Environment Variable (SPRING_PROFILES_ACTIVE)\n3. JVM Property (-Dspring.profiles.active=prod)\n4. application.properties (spring.profiles.active)\n‚Üí Set Active Profiles",
            "comparisonTable": [
              {
                "column1": "Strategy",
                "column2": "Best For"
              },
              {
                "column1": "Command Line Arguments",
                "column2": "Local development, ad-hoc runs"
              },
              {
                "column1": "Environment Variables",
                "column2": "Docker, Kubernetes, cloud platforms (12-factor apps)"
              },
              {
                "column1": "JVM System Properties",
                "column2": "Legacy app servers, build tools (Maven/Gradle)"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-env-variables-activation",
          "title": "üå± Environment Variables",
          "explanations": {
            "english": "Set SPRING_PROFILES_ACTIVE environment variable. Preferred for cloud-native deployments (Docker, Kubernetes, AWS). Follows 12-factor app principles‚Äîconfiguration externalized from code. Works across OS: export SPRING_PROFILES_ACTIVE=prod (Linux/Mac), set SPRING_PROFILES_ACTIVE=prod (Windows). Spring Boot automatically reads this variable at startup.",
            "hinglish": "Environment variable SPRING_PROFILES_ACTIVE set karo. Cloud deployments (Docker, Kubernetes) ke liye best hai. Ye 12-factor app principle follow karta hai‚Äîconfiguration code se alag. Linux/Mac pe: export SPRING_PROFILES_ACTIVE=prod, Windows pe: set SPRING_PROFILES_ACTIVE=prod. Spring Boot startup pe automatically is variable ko padhta hai."
          },
          "code": {
            "title": "Dockerfile Example",
            "language": "dockerfile",
            "content": "# Build stage\nFROM maven:3.8-openjdk-17 AS build\nCOPY src /app/src\nCOPY pom.xml /app\nRUN mvn -f /app/pom.xml clean package -DskipTests\n\n# Runtime stage\nFROM openjdk:17-jre-slim\nCOPY --from=build /app/target/*.jar app.jar\nENV SPRING_PROFILES_ACTIVE=prod\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"/app.jar\"]"
          },
          "codeExplanations": {
            "english": "ENV SPRING_PROFILES_ACTIVE=prod sets the profile for the container. Kubernetes uses similar config in deployment YAML under env[]. This approach keeps configuration out of the JAR file‚Äîcritical for security and environment isolation. Never commit .env files with secrets to version control.",
            "hinglish": "ENV SPRING_PROFILES_ACTIVE=prod container ke liye profile set karta hai. Kubernetes deployment YAML mein bhi aisa hi env section mein likhte hain. Isse configuration JAR file ke bahar rehti hai‚Äîsecurity aur environment isolation ke liye zaroori. Kabhi bhi .env files ko version control (Git) mein commit mat karo."
          },
          "keyPoints": [
            "Environment variable names are uppercase with underscores",
            "Kubernetes ConfigMaps/Secrets inject profiles securely",
            "Override locally without rebuilding the application artifact"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Heroku: heroku config:set SPRING_PROFILES_ACTIVE=prod",
              "AWS ECS: Set environment variable in task definition"
            ]
          }
        },
        {
          "id": "topic-cli-activation",
          "title": "‚å®Ô∏è Command Line Arguments",
          "explanations": {
            "english": "Pass --spring.profiles.active=dev when running the JAR. Highest precedence‚Äîoverrides all other sources. Ideal for quick local testing or one-off runs. Works with java -jar and Spring Boot Maven plugin (mvn spring-boot:run -Dspring-boot.run.profiles=dev). Avoid in production scripts where environment variables are more secure and auditable.",
            "hinglish": "Jab aap JAR file run karen, to --spring.profiles.active=dev argument pass karo. Ye sabse high priority ka source hai‚Äîdusre saare sources ko override kar deta hai. Local testing ke liye perfect hai. java -jar app.jar --spring.profiles.active=dev ya Maven se: mvn spring-boot:run -Dspring-boot.run.profiles=dev. Production scripts mein ise avoid karo‚Äîwahan environment variables zyada secure hain."
          },
          "code": {
            "title": "Running with Active Profile",
            "language": "bash",
            "content": "# Run JAR with dev profile\njava -jar myapp.jar --spring.profiles.active=dev\n\n# Multiple profiles\njava -jar myapp.jar --spring.profiles.active=prod,aws\n\n# Spring Boot Maven Plugin\nmvn spring-boot:run -Dspring-boot.run.profiles=local\n\n# Gradle\n./gradlew bootRun -Dspring-boot.run.profiles=test"
          },
          "codeExplanations": {
            "english": "Command line arguments start with --. Multiple profiles use comma separation (no spaces). Maven/Gradle plugins have specific syntax for passing profiles. This method is transient‚Äîsettings don't persist after process ends. Never use for secrets (visible in process lists).",
            "hinglish": "Command line arguments -- se shuru hote hain. Multiple profiles comma se alag karo (spaces nahi). Maven/Gradle ke liye alag syntax hai. Ye settings temporary hote hain‚Äîprocess band hone ke baad khatam. Kabhi bhi secrets ke liye ise use mat karo (process list mein dikhai dete hain)."
          },
          "keyPoints": [
            "Highest precedence in Spring Boot's property source order",
            "Visible in process listings (ps aux)‚Äîavoid for sensitive data",
            "Perfect for developer ad-hoc testing without modifying files"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-jvm-properties-activation",
          "title": "‚òï JVM System Properties",
          "explanations": {
            "english": "Set profile via JVM argument: -Dspring.profiles.active=prod. Common in legacy app servers (Tomcat, WebLogic) or build tools. Lower precedence than CLI args but higher than config files. Useful when you control JVM startup but not the command line directly. Avoid hardcoding in build scripts‚Äîprefer environment injection.",
            "hinglish": "JVM argument ke through profile set karo: -Dspring.profiles.active=prod. Purane app servers (Tomcat) ya build tools ke saath common hai. CLI arguments se kam priority hai lekin config files se zyada. Jab aap JVM startup control karte hain lekin direct command line nahi de sakte, tab useful hai. Build scripts mein hardcode mat karo‚Äîenvironment se inject karo."
          },
          "code": {
            "title": "JVM Property Activation",
            "language": "bash",
            "content": "# Direct JVM argument\njava -Dspring.profiles.active=prod -jar app.jar\n\n# Tomcat setenv.sh\nexport CATALINA_OPTS=\"$CATALINA_OPTS -Dspring.profiles.active=prod\"\n\n# Maven Surefire Plugin (for tests)\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-surefire-plugin</artifactId>\n  <configuration>\n    <argLine>-Dspring.profiles.active=test</argLine>\n  </configuration>\n</plugin>"
          },
          "codeExplanations": {
            "english": "-D sets a JVM system property. Spring Boot reads spring.profiles.active from System.getProperties(). Tomcat uses CATALINA_OPTS to pass JVM args. Build tools (Maven Surefire) inject properties during test execution. Less cloud-native than environment variables but necessary for some deployments.",
            "hinglish": "-D JVM system property set karta hai. Spring Boot System.getProperties() se spring.profiles.active padhta hai. Tomcat CATALINA_OPTS use karta hai JVM arguments pass karne ke liye. Build tools (Maven) test chalate waqt properties inject karte hain. Cloud ke liye environment variables behtar hain, lekin kuch purane systems ke liye zaroori hai."
          },
          "keyPoints": [
            "Precedence: Overrides application.properties but overridden by CLI args",
            "Visible in JVM process arguments (jps -v)",
            "Legacy systems may require this method for profile activation"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        }
      ]
    },
    {
      "id": "section-spring-security",
      "title": "üîí Spring Security",
      "intro": "Implement authentication, authorization, and modern security patterns. Protect endpoints, enable OAuth2, JWT, and method-level security with minimal configuration.",
      "topics": [
        {
          "id": "topic-security-overview",
          "title": "üß† Spring Security Overview",
          "explanations": {
            "english": "Spring Security is a powerful framework for authentication (verifying identity) and authorization (granting permissions). Provides default security: HTTP basic auth, CSRF protection, session management. Auto-configures a security filter chain. Customize via SecurityFilterChain bean. Start with spring-boot-starter-security dependency. Always override default password (shown in logs on startup).",
            "hinglish": "Spring Security authentication (identity verify karna) aur authorization (permissions dena) ke liye ek powerful framework hai. Default mein ye HTTP basic auth, CSRF protection, session management provide karta hai. SecurityFilterChain bean bana kar aap ise customize kar sakte hain. spring-boot-starter-security dependency add karo. Hamesha default password ko override karo (startup logs mein dikhta hai)."
          },
          "code": {
            "title": "Minimal Security Configuration",
            "language": "java",
            "content": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .formLogin(Customizer.withDefaults())\n            .logout(logout -> logout.logoutSuccessUrl(\"/\"));\n        return http.build();\n    }\n    \n    @Bean\n    public UserDetailsService userDetailsService() {\n        UserDetails user = User.builder()\n            .username(\"user\")\n            .password(passwordEncoder().encode(\"password\"))\n            .roles(\"USER\")\n            .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}"
          },
          "codeExplanations": {
            "english": "SecurityFilterChain defines URL-based access rules. /public/** requires no auth. /admin/** requires ADMIN role. formLogin() enables default login page. UserDetailsService loads users (here in-memory). Passwords MUST be encoded (BCrypt). Never store plain-text passwords. Default login page at /login.",
            "hinglish": "SecurityFilterChain URL-based access rules define karta hai. /public/** ko auth ki zaroorat nahi. /admin/** ke liye ADMIN role chahiye. formLogin() default login page enable karta hai. UserDetailsService users ko load karta hai (yahan memory mein). Passwords ko hamesha encode karo (BCrypt). Kabhi bhi plain-text passwords store mat karo. Default login page /login pe hota hai."
          },
          "keyPoints": [
            "Default security is enabled with spring-boot-starter-security‚Äîno config needed for basic auth",
            "Always customize the default security configuration for production",
            "Password encoding is non-negotiable‚ÄîBCrypt is the standard"
          ],
          "extras": {
            "flowDiagram": "Request ‚Üí Security Filters (Authentication, CSRF, etc.) ‚Üí [Authenticated?] ‚Üí Access Decision ‚Üí Controller / 403",
            "comparisonTable": [],
            "examples": [
              "Basic auth for internal APIs",
              "Form login for web applications",
              "Stateless JWT for mobile clients"
            ]
          }
        },
        {
          "id": "topic-authentication",
          "title": "üîë Authentication",
          "explanations": {
            "english": "Authentication verifies user identity (who are you?). Spring Security supports multiple mechanisms: form login, HTTP basic, OAuth2, JWT. Process: collect credentials ‚Üí authenticate against provider (database, LDAP, OAuth) ‚Üí create SecurityContext with UserDetails. Implement UserDetailsService to load user data. Passwords must be encoded with PasswordEncoder.",
            "hinglish": "Authentication user ki identity verify karta hai (aap kaun hain?). Spring Security form login, HTTP basic, OAuth2, JWT jaise kai tarike support karta hai. Process: credentials lo ‚Üí provider (database, LDAP) se match karo ‚Üí SecurityContext banayo UserDetails ke saath. UserDetailsService implement karo taaki user data load ho sake. Passwords ko PasswordEncoder se encode karna zaroori hai."
          },
          "code": {
            "title": "Custom UserDetailsService",
            "language": "java",
            "content": "@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Override\n    public UserDetails loadUserByUsername(String username) \n        throws UsernameNotFoundException {\n        \n        UserEntity user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\"User not found\"));\n        \n        return User.builder()\n            .username(user.getUsername())\n            .password(user.getPassword()) // Already BCrypt encoded in DB\n            .authorities(user.getRoles().stream()\n                .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role))\n                .collect(Collectors.toList()))\n            .build();\n    }\n}"
          },
          "codeExplanations": {
            "english": "loadUserByUsername() fetches user from database. Returns Spring Security's UserDetails object. Authorities must include \"ROLE_\" prefix for role-based checks (e.g., hasRole(\"ADMIN\") checks for ROLE_ADMIN). Password in DB must be BCrypt encoded. Never return raw database entity‚Äîmap to UserDetails.",
            "hinglish": "loadUserByUsername() database se user dhoondta hai. Spring Security ka UserDetails object return karta hai. Authorities mein \"ROLE_\" prefix hona chahiye (jaise ROLE_ADMIN). Database mein password BCrypt encoded hona chahiye. Kabhi bhi seedha database entity mat return karo‚ÄîUserDetails mein map karo."
          },
          "keyPoints": [
            "UserDetailsService is the core interface for loading user data",
            "SecurityContext holds authentication details for the current request",
            "AuthenticationManager handles the authentication flow internally"
          ],
          "extras": {
            "flowDiagram": "Login Request ‚Üí UsernamePasswordAuthenticationToken ‚Üí AuthenticationManager ‚Üí UserDetailsService ‚Üí [Valid?] ‚Üí SecurityContext",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-authorization",
          "title": "üö™ Authorization",
          "explanations": {
            "english": "Authorization determines what an authenticated user can do (permissions). Two levels: URL-based (web security) and method-level (business logic). Use hasRole(), hasAuthority(), permitAll() in SecurityFilterChain. Roles imply authorities with ROLE_ prefix. Principle: Least privilege‚Äîgrant minimal necessary access. Always validate authorization on server side, never rely solely on UI hiding.",
            "hinglish": "Authorization decide karta hai ki authenticated user kya kar sakta hai (permissions). Do levels hain: URL-based (web security) aur method-level (business logic). SecurityFilterChain mein hasRole(), hasAuthority(), permitAll() use karo. Roles ke saath automatically ROLE_ prefix add hota hai. Siddhant: Least privilege‚Äîsirf zaroori access do. Authorization hamesha server side pe validate karo, UI mein chhupane par bharosa mat karo."
          },
          "code": {
            "title": "URL-Based Authorization Rules",
            "language": "java",
            "content": "@Bean\npublic SecurityFilterChain apiSecurity(HttpSecurity http) throws Exception {\n    http\n        .securityMatcher(\"/api/**\")\n        .authorizeHttpRequests(auth -> auth\n            .requestMatchers(\"/api/public/**\").permitAll()\n            .requestMatchers(\"/api/user/**\").hasAnyRole(\"USER\", \"ADMIN\")\n            .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n            .requestMatchers(\"/api/billing/**\").hasAuthority(\"BILLING_ACCESS\")\n            .anyRequest().denyAll() // Fail-safe\n        )\n        .httpBasic(Customizer.withDefaults());\n    return http.build();\n}"
          },
          "codeExplanations": {
            "english": "securityMatcher scopes config to /api/**. hasRole(\"ADMIN\") checks for ROLE_ADMIN authority. hasAuthority() checks exact authority string (no ROLE_ prefix added). denyAll() as default blocks unintended access. Order matters: first matching rule applies. Always end with a catch-all rule.",
            "hinglish": "securityMatcher configuration ko sirf /api/** tak limit karta hai. hasRole(\"ADMIN\") ROLE_ADMIN authority check karta hai. hasAuthority() seedha authority string check karta hai (ROLE_ prefix nahi add karta). denyAll() default rule hai jo unintended access rokta hai. Order important hai: pehla matching rule apply hota hai. Hamesha ek catch-all rule ke saath khatam karo."
          },
          "keyPoints": [
            "URL patterns are evaluated in order‚Äîplace specific rules before generic ones",
            "hasRole adds ROLE_ prefix; hasAuthority uses exact string",
            "Default deny (denyAll) is a critical security best practice"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "permitAll(): Public endpoints (login, health check)",
              "hasRole(\"USER\"): Authenticated user access",
              "hasAuthority(\"DELETE\"): Fine-grained permission"
            ]
          }
        },
        {
          "id": "topic-form-login",
          "title": "üñºÔ∏è Form Login",
          "explanations": {
            "english": "Enables username/password login via HTML form. Spring Security provides default login page at /login. Customize with .formLogin() builder: loginPage(), successHandler(), failureUrl(). POST /login processes credentials. Requires CSRF protection (enabled by default). Redirects after login/logout configurable. Ideal for traditional web applications with server-rendered views.",
            "hinglish": "Username/password login HTML form ke through enable karta hai. Spring Security default login page /login pe provide karta hai. .formLogin() builder se customize karo: loginPage(), successHandler(), failureUrl(). POST /login credentials process karta hai. CSRF protection zaroori hai (default enabled). Login/logout ke baad redirect configure kar sakte hain. Traditional web applications ke liye perfect hai."
          },
          "code": {
            "title": "Custom Form Login Configuration",
            "language": "java",
            "content": "@Bean\npublic SecurityFilterChain webSecurity(HttpSecurity http) throws Exception {\n    http\n        .authorizeHttpRequests(auth -> auth\n            .requestMatchers(\"/css/**\", \"/js/**\", \"/login\").permitAll()\n            .anyRequest().authenticated()\n        )\n        .formLogin(form -> form\n            .loginPage(\"/custom-login\") // Custom login page URL\n            .loginProcessingUrl(\"/authenticate\") // POST endpoint\n            .defaultSuccessUrl(\"/dashboard\", true)\n            .failureUrl(\"/custom-login?error=true\")\n            .permitAll()\n        )\n        .logout(logout -> logout\n            .logoutUrl(\"/perform-logout\")\n            .logoutSuccessUrl(\"/\")\n            .invalidateHttpSession(true)\n            .clearAuthentication(true)\n        );\n    return http.build();\n}"
          },
          "codeExplanations": {
            "english": "loginPage() sets custom login view (must handle POST to loginProcessingUrl). defaultSuccessUrl redirects after successful login. failureUrl handles auth failures. permitAll() allows unauthenticated access to login resources. Logout configuration invalidates session and clears authentication. Always protect login endpoints with HTTPS in production.",
            "hinglish": "loginPage() custom login page ka URL set karta hai (jo loginProcessingUrl par POST karega). defaultSuccessUrl successful login ke baad redirect karta hai. failureUrl auth failures handle karta hai. permitAll() login resources tak unauthenticated access deta hai. Logout configuration session ko invalidate karta hai aur authentication clear karta hai. Production mein hamesha login endpoints ko HTTPS se secure karo."
          },
          "keyPoints": [
            "Default login page is auto-generated but not production-ready",
            "Custom login pages must POST credentials to loginProcessingUrl",
            "CSRF tokens required in login forms (Thymeleaf auto-includes)"
          ],
          "extras": {
            "flowDiagram": "User ‚Üí /custom-login (GET) ‚Üí Form POST /authenticate ‚Üí Authentication ‚Üí [Success] ‚Üí /dashboard",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-jwt",
          "title": "webtoken JWT (JSON Web Tokens)",
          "explanations": {
            "english": "JWT is a stateless authentication token containing user claims (username, roles) signed by server. Client sends token in Authorization header (Bearer <token>). Server validates signature and extracts claims‚Äîno session storage needed. Ideal for microservices, mobile apps, SPAs. Requires custom filter to validate tokens. Never store secrets in JWT payload. Use strong signing algorithms (HS512, RS256).",
            "hinglish": "JWT ek stateless authentication token hai jisme user claims (username, roles) hote hain aur server ke signature se signed hote hain. Client token ko Authorization header mein bhejta hai (Bearer <token>). Server signature validate karta hai aur claims extract karta hai‚Äîsession storage ki zaroorat nahi. Microservices, mobile apps, SPAs ke liye perfect. Custom filter banana padta hai tokens validate karne ke liye. Kabhi bhi secrets JWT payload mein mat rakho. Strong signing algorithms (HS512, RS256) use karo."
          },
          "code": {
            "title": "JWT Utility Class (Simplified)",
            "language": "java",
            "content": "@Component\npublic class JwtUtil {\n    private final String secret = \"YourStrongSecretKeyMustBeLong\"; // Use environment variable!\n    private final long expiration = 86400000; // 24 hours\n    \n    public String generateToken(UserDetails userDetails) {\n        return Jwts.builder()\n            .setSubject(userDetails.getUsername())\n            .claim(\"roles\", userDetails.getAuthorities())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + expiration))\n            .signWith(SignatureAlgorithm.HS512, secret)\n            .compact();\n    }\n    \n    public Boolean validateToken(String token, UserDetails userDetails) {\n        final String username = extractUsername(token);\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\n    }\n    \n    public String extractUsername(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token)\n            .getBody().getSubject();\n    }\n    \n    private Boolean isTokenExpired(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token)\n            .getBody().getExpiration().before(new Date());\n    }\n}"
          },
          "codeExplanations": {
            "english": "generateToken() creates JWT with username and roles. Claims are base64-encoded (NOT encrypted)‚Äînever put secrets here. validateToken() checks username match and expiration. Secret key MUST be stored securely (environment variable, vault). Use io.jsonwebtoken:jjwt library. Always verify token signature on every request.",
            "hinglish": "generateToken() username aur roles ke saath JWT banata hai. Claims base64-encoded hote hain (encrypted nahi)‚Äîyahan kabhi secrets mat rakho. validateToken() username match aur expiration check karta hai. Secret key ko securely store karo (environment variable, vault). io.jsonwebtoken:jjwt library use karo. Har request pe token signature verify karo."
          },
          "keyPoints": [
            "JWT payload is base64-encoded‚Äîtreat as public data (no secrets)",
            "Always validate token signature and expiration on every request",
            "Store secret key securely‚Äînever in code or version control"
          ],
          "extras": {
            "flowDiagram": "Login ‚Üí Generate JWT ‚Üí Client stores token ‚Üí Subsequent requests: Header Authorization: Bearer <token> ‚Üí Validate signature ‚Üí Extract claims ‚Üí Authorize",
            "comparisonTable": [],
            "examples": [
              "Access token for API clients",
              "Refresh tokens for long sessions (separate endpoint)",
              "Mobile app authentication"
            ]
          }
        },
        {
          "id": "topic-stateless-auth",
          "title": "‚òÅÔ∏è Stateless Authentication",
          "explanations": {
            "english": "Stateless authentication (like JWT) requires no server-side session storage. Each request contains all necessary auth data (token). Server validates token independently per request. Benefits: horizontal scaling (no session affinity), simpler microservices. Drawbacks: token revocation challenges, larger payload. Contrast with stateful (session-based) auth where server stores session ID. Use stateless for APIs, SPAs, mobile; stateful for traditional web apps.",
            "hinglish": "Stateless authentication (jaise JWT) mein server-side session storage ki zaroorat nahi hoti. Har request ke saath saara auth data (token) aata hai. Server har request ko independently validate karta hai. Fayde: horizontal scaling aasan (koi session affinity nahi), microservices ke liye simple. Nuksan: token revoke karna mushkil, payload bada hota hai. Stateful (session-based) auth se compare karo jahan server session ID store karta hai. APIs, SPAs, mobile ke liye stateless use karo; traditional web apps ke liye stateful."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "No session storage on server‚Äîideal for cloud-native scaling",
            "Token must contain all required claims (roles, permissions)",
            "Implement token refresh mechanism to handle expiration"
          ],
          "extras": {
            "flowDiagram": "Client Request ‚Üí [Has Valid Token?] ‚Üí Yes: Process Request / No: 401 Unauthorized",
            "comparisonTable": [
              {
                "column1": "Stateless (JWT)",
                "column2": "Stateful (Session)"
              },
              {
                "column1": "No server session storage",
                "column2": "Server stores session data"
              },
              {
                "column1": "Scales horizontally easily",
                "column2": "Requires session affinity or shared session store"
              },
              {
                "column1": "Token revocation difficult",
                "column2": "Instant revocation via session invalidate"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-method-security",
          "title": "‚öôÔ∏è Method Security",
          "explanations": {
            "english": "Enforce security at the method level (business logic layer), not just URLs. Protect service methods directly. Requires @EnableMethodSecurity (Spring Security 6+). Uses annotations like @PreAuthorize, @PostAuthorize. Evaluated at runtime via AOP proxies. Critical for layered architectures where controllers delegate to services. Prevents security gaps when multiple endpoints call the same service method.",
            "hinglish": "Security ko method level (business logic layer) par enforce karo, sirf URLs par nahi. Service methods ko directly secure karo. @EnableMethodSecurity annotation lagani padti hai (Spring Security 6+). @PreAuthorize, @PostAuthorize jaise annotations use karte hain. Runtime pe AOP proxies ke through evaluate hota hai. Layered architectures ke liye zaroori hai jahan controllers services ko call karte hain. Security gaps ko rokta hai jab ek hi service method ko multiple endpoints se call kiya jata hai."
          },
          "code": {
            "title": "Enable Method Security",
            "language": "java",
            "content": "@Configuration\n@EnableMethodSecurity // Replaces @EnableGlobalMethodSecurity in Spring Security 6+\npublic class MethodSecurityConfig {\n    // Configuration beans if needed\n}\n\n@Service\npublic class ReportService {\n    \n    @PreAuthorize(\"hasRole('ADMIN')\")\n    public Report generateFinancialReport() {\n        // Only admins can call this\n        return new Report();\n    }\n    \n    @PreAuthorize(\"#userId == authentication.principal.username\")\n    public UserData getUserData(String userId) {\n        // User can only access their own data\n        return userRepository.findById(userId);\n    }\n}"
          },
          "codeExplanations": {
            "english": "@EnableMethodSecurity activates method-level security. @PreAuthorize checks before method execution. SpEL expressions: hasRole(), authentication.principal. #userId refers to method parameter. Security checks happen on the service layer‚Äîcritical even if controller has URL security. Requires CGLIB proxies (default in Spring Boot).",
            "hinglish": "@EnableMethodSecurity method-level security ko activate karta hai. @PreAuthorize method execute hone se pehle check karta hai. SpEL expressions: hasRole(), authentication.principal. #userId method parameter ko refer karta hai. Security checks service layer par hote hain‚ÄîURL security ke saath bhi zaroori. CGLIB proxies ki zaroorat hoti hai (Spring Boot mein default)."
          },
          "keyPoints": [
            "Add spring-boot-starter-aop dependency for proxy support",
            "Method security complements‚Äînot replaces‚Äîweb security",
            "SpEL expressions can access method arguments and authentication object"
          ],
          "extras": {
            "flowDiagram": "Controller ‚Üí [Web Security Pass] ‚Üí Service Method ‚Üí [Method Security Check] ‚Üí Execute / AccessDeniedException",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "topic-pre-authorize",
          "title": "üõ°Ô∏è @PreAuthorize",
          "explanations": {
            "english": "@PreAuthorize specifies access rules using SpEL before method execution. Check roles (hasRole('ADMIN')), permissions (hasAuthority('DELETE')), or custom logic (#id == authentication.principal.username). Most flexible method security annotation. Combine conditions with AND/OR. Failures throw AccessDeniedException. Use for fine-grained control beyond URL patterns‚Äîe.g., row-level security.",
            "hinglish": "@PreAuthorize method execute hone se pehle SpEL use karke access rules define karta hai. Roles check karo (hasRole('ADMIN')), permissions (hasAuthority('DELETE')), ya custom logic (#id == authentication.principal.username). Sabse flexible method security annotation. Conditions ko AND/OR se jodo. Failures AccessDeniedException throw karte hain. URL patterns se zyada fine-grained control ke liye use karo‚Äîjaise row-level security."
          },
          "code": {
            "title": "Advanced @PreAuthorize Examples",
            "language": "java",
            "content": "@Service\npublic class DocumentService {\n    \n    // Role-based access\n    @PreAuthorize(\"hasRole('EDITOR') or hasRole('ADMIN')\")\n    public void editDocument(Long id) { ... }\n    \n    // Ownership check (method parameter vs current user)\n    @PreAuthorize(\"#document.owner == authentication.principal.username\")\n    public void updateDocument(Document document) { ... }\n    \n    // Custom permission expression\n    @PreAuthorize(\"@documentSecurityService.canAccess(#id, authentication)\")\n    public Document getDocument(Long id) { ... }\n    \n    // Permission-based (not role-based)\n    @PreAuthorize(\"hasAuthority('document:delete')\")\n    public void deleteDocument(Long id) { ... }\n}"
          },
          "codeExplanations": {
            "english": "SpEL expressions: hasRole checks granted authorities. #document.owner accesses method parameter field. @documentSecurityService calls a Spring bean for complex logic. hasAuthority checks exact permission string (better for fine-grained control than roles). authentication object provides current user details. Custom beans (@...) enable reusable security logic.",
            "hinglish": "SpEL expressions: hasRole granted authorities check karta hai. #document.owner method parameter ke field ko access karta hai. @documentSecurityService complex logic ke liye Spring bean ko call karta hai. hasAuthority exact permission string check karta hai (roles se behtar fine-grained control ke liye). authentication object current user details deta hai. Custom beans (@...) reusable security logic enable karte hain."
          },
          "keyPoints": [
            "SpEL can reference Spring beans for complex authorization logic",
            "Prefer hasAuthority over hasRole for permission-based systems",
            "Parameter names must be compiled with -parameters flag or use @P annotation"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "@PreAuthorize(\"isAuthenticated()\") ‚Üí Require any authenticated user",
              "@PreAuthorize(\"principal.username == #username\") ‚Üí Owner-only access",
              "@PreAuthorize(\"@customChecker.hasAccess(#id)\") ‚Üí Delegate to service"
            ]
          }
        },
        {
          "id": "topic-oauth2",
          "title": "üîê OAuth2",
          "explanations": {
            "english": "OAuth2 is an authorization framework (not authentication!). Enables apps to access resources on behalf of a user without sharing passwords. Roles: Resource Owner (user), Client (your app), Authorization Server (Google, Auth0), Resource Server (your API). Spring Security supports OAuth2 client (login via Google) and resource server (protect APIs with JWT). Use spring-boot-starter-oauth2-client and spring-boot-starter-oauth2-resource-server.",
            "hinglish": "OAuth2 ek authorization framework hai (authentication nahi!). Apps ko user ke resources tak uske bina password share kiye access dene ki ijazat deta hai. Roles: Resource Owner (user), Client (aapka app), Authorization Server (Google, Auth0), Resource Server (aapka API). Spring Security OAuth2 client (Google se login) aur resource server (JWT se APIs secure karna) dono support karta hai. spring-boot-starter-oauth2-client aur spring-boot-starter-oauth2-resource-server dependencies use karo."
          },
          "code": {
            "title": "OAuth2 Resource Server Configuration",
            "language": "java",
            "content": "@Configuration\n@EnableWebSecurity\npublic class OAuth2ResourceServerConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthConverter()))\n            );\n        return http.build();\n    }\n    \n    @Bean\n    public JwtAuthenticationConverter jwtAuthConverter() {\n        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();\n        grantedAuthoritiesConverter.setAuthorityPrefix(\"ROLE_\");\n        grantedAuthoritiesConverter.setAuthoritiesClaimName(\"roles\");\n        \n        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();\n        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);\n        return jwtAuthenticationConverter;\n    }\n}"
          },
          "codeExplanations": {
            "english": "oauth2ResourceServer() configures API as resource server. jwt() validates incoming JWT tokens. jwtAuthenticationConverter maps claims (like \"roles\" in token) to Spring Security authorities. Authorization server (Auth0, Keycloak) must issue tokens with required claims. Client apps obtain tokens via OAuth2 flows (Authorization Code flow for web apps).",
            "hinglish": "oauth2ResourceServer() API ko resource server ke roop mein configure karta hai. jwt() aane wale JWT tokens ko validate karta hai. jwtAuthenticationConverter token ke claims (jaise \"roles\") ko Spring Security authorities mein map karta hai. Authorization server (Auth0, Keycloak) ko required claims ke saath tokens issue karne honge. Client apps OAuth2 flows (Authorization Code flow) se tokens obtain karte hain."
          },
          "keyPoints": [
            "OAuth2 is for authorization delegation‚Äînot user authentication",
            "Resource server validates JWT tokens issued by authorization server",
            "Map custom claims (roles, permissions) from token to authorities"
          ],
          "extras": {
            "flowDiagram": "User ‚Üí Client App ‚Üí Redirect to Auth Server ‚Üí Login ‚Üí Auth Code ‚Üí Client exchanges for Token ‚Üí Client calls API with Token ‚Üí Resource Server validates token",
            "comparisonTable": [],
            "examples": [
              "Google Sign-In for user authentication (OAuth2 + OpenID Connect)",
              "Secure microservice-to-microservice communication",
              "Third-party app access to user data (with consent)"
            ]
          }
        },
        {
          "id": "topic-social-login",
          "title": "üí¨ Social Login",
          "explanations": {
            "english": "Social Login uses OAuth2/OIDC to authenticate users via providers (Google, Facebook, GitHub). Spring Security's OAuth2 Client handles redirects, token exchange, and user info fetching. Configure provider details in application.yml. Auto-creates OAuth2AuthorizedClient. Customize user registration flow with OAuth2UserService. Always map provider attributes to your user model. Never store provider tokens long-term without refresh strategy.",
            "hinglish": "Social Login OAuth2/OIDC use karta hai users ko providers (Google, Facebook, GitHub) ke through authenticate karne ke liye. Spring Security ka OAuth2 Client redirects, token exchange, aur user info fetching handle karta hai. Provider details application.yml mein configure karo. OAuth2AuthorizedClient automatically banata hai. OAuth2UserService se user registration flow customize karo. Hamesha provider attributes ko apne user model se map karo. Provider tokens ko long-term bina refresh strategy ke store mat karo."
          },
          "code": {
            "title": "Social Login Configuration (application.yml)",
            "language": "yaml",
            "content": "spring:\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: ${GOOGLE_CLIENT_ID}\n            client-secret: ${GOOGLE_CLIENT_SECRET}\n            scope:\n              - email\n              - profile\n          github:\n            client-id: ${GITHUB_CLIENT_ID}\n            client-secret: ${GITHUB_CLIENT_SECRET}\n        provider:\n          github:\n            user-name-attribute: login # Map GitHub 'login' to username"
          },
          "codeExplanations": {
            "english": "registration defines OAuth2 clients (Google, GitHub). client-id/client-secret from provider dashboard. scope requests user attributes. provider section customizes attribute mapping (GitHub uses 'login' for username). Environment variables (GOOGLE_CLIENT_ID) keep secrets out of code. Spring Security auto-generates login endpoints: /oauth2/authorization/google.",
            "hinglish": "registration OAuth2 clients (Google, GitHub) define karta hai. client-id/client-secret provider dashboard se aate hain. scope user attributes ke liye request karta hai. provider section attribute mapping customize karta hai (GitHub 'login' ko username ke roop mein use karta hai). Environment variables (GOOGLE_CLIENT_ID) secrets ko code se door rakhte hain. Spring Security automatically login endpoints banata hai: /oauth2/authorization/google."
          },
          "keyPoints": [
            "Register your app with the provider to get client ID/secret",
            "Use environment variables or secrets manager for credentials",
            "Handle new user registration after successful OAuth2 login"
          ],
          "extras": {
            "flowDiagram": "User clicks 'Login with Google' ‚Üí Redirect to Google ‚Üí User authenticates ‚Üí Google redirects with code ‚Üí Spring exchanges code for token ‚Üí Fetch user info ‚Üí Create session",
            "comparisonTable": [],
            "examples": [
              "Google Sign-In for consumer applications",
              "GitHub login for developer tools",
              "Facebook login for social apps"
            ]
          }
        }
      ]
    },
       {
      "id": "section-actuator",
      "title": "üöÄ Actuator & Observability",
      "intro": "Spring Boot Actuator provides production-ready endpoints to monitor app health, metrics, and environment. Learn to configure securely and integrate with Kubernetes and visualization tools.",
      "topics": [
        {
          "id": "topic-actuator-overview",
          "title": "üåü Actuator & Observability Overview",
          "explanations": {
            "english": "Actuator is Spring Boot's built-in module for monitoring and managing applications in production. It exposes HTTP endpoints (like /actuator/health) that reveal internal app state‚Äîhealth status, metrics, environment properties‚Äîwithout writing custom code. Observability means understanding your system's behavior through logs, metrics, and traces to quickly diagnose issues.",
            "hinglish": "Actuator Spring Boot ka built-in module hai jo production mein app ko monitor aur manage karne mein madad karta hai. Yeh HTTP endpoints (/actuator/health jaise) expose karta hai jo bina custom code likhe app ki internal state dikhata hai‚Äîhealth status, metrics, environment properties. Observability ka matlab hai logs, metrics, aur traces ke zariye system ke behavior ko samajhna taaki issues ko jaldi diagnose kiya ja sake."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Adds monitoring endpoints with zero custom code via spring-boot-starter-actuator dependency",
            "Critical for DevOps: enables health checks, metrics collection, and config inspection",
            "Must be secured in production‚Äînever expose all endpoints publicly"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Health endpoint tells Kubernetes if your pod is ready to receive traffic",
              "Metrics endpoint feeds CPU/memory data to Prometheus for dashboards"
            ]
          }
        },
        {
          "id": "topic-health-endpoints",
          "title": "‚ù§Ô∏è Health Endpoints",
          "explanations": {
            "english": "The /actuator/health endpoint reports application health status (UP/DOWN). Spring Boot auto-configures checks for databases, disks, and Redis. Custom health indicators can verify external services (e.g., payment gateway). Status details can be hidden from unauthenticated users for security.",
            "hinglish": "/actuator/health endpoint application ki health status (UP/DOWN) batata hai. Spring Boot automatically databases, disks, aur Redis ke liye checks configure karta hai. Aap custom health indicators bana sakte hain external services (jaise payment gateway) verify karne ke liye. Security ke liye status details unauthenticated users se chhupaye ja sakte hain."
          },
          "code": {
            "title": "Custom Health Indicator",
            "language": "java",
            "content": "@Component\npublic class PaymentServiceHealthIndicator implements HealthIndicator {\n    @Override\n    public Health health() {\n        if (isPaymentServiceReachable()) {\n            return Health.up().withDetail(\"version\", \"2.1\").build();\n        }\n        return Health.down().withDetail(\"error\", \"Timeout\").build();\n    }\n    private boolean isPaymentServiceReachable() { /* ... */ return true; }\n}"
          },
          "codeExplanations": {
            "english": "This custom indicator checks an external payment service. Returns UP with version detail if reachable, DOWN with error detail if failed. Spring Boot auto-registers it and includes results in /actuator/health.",
            "hinglish": "Yeh custom indicator external payment service check karta hai. Agar service reachable hai to UP aur version detail ke saath return karta hai, warna DOWN aur error detail ke saath. Spring Boot ise automatically register karta hai aur /actuator/health mein results include karta hai."
          },
          "keyPoints": [
            "Default path: /actuator/health (returns {\"status\":\"UP\"})",
            "Enable details with management.endpoint.health.show-details=always (use cautiously in prod)",
            "Critical for load balancers/Kubernetes to route traffic only to healthy instances"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Database down? Health status shows DOWN ‚Üí Kubernetes stops sending traffic",
              "Custom check: Verify third-party API availability before marking app healthy"
            ]
          }
        },
        {
          "id": "topic-metrics-endpoints",
          "title": "üìä Metrics Endpoints",
          "explanations": {
            "english": "The /actuator/metrics endpoint exposes quantitative data like HTTP request counts, JVM memory usage, and database connection pool stats. Metrics are tagged (e.g., uri=\"/api/users\", status=\"200\") for filtering. Integrates with Micrometer to push data to monitoring systems like Prometheus.",
            "hinglish": "/actuator/metrics endpoint quantitative data expose karta hai jaise HTTP request counts, JVM memory usage, aur database connection pool stats. Metrics tagged hote hain (jaise uri=\"/api/users\", status=\"200\") taaki unhe filter kiya ja sake. Micrometer ke saath integrate hota hai taaki data Prometheus jaise monitoring systems mein bheja ja sake."
          },
          "code": {
            "title": "Custom Metric Counter",
            "language": "java",
            "content": "@Service\npublic class OrderService {\n    private final Counter ordersPlaced;\n    \n    public OrderService(MeterRegistry meterRegistry) {\n        this.ordersPlaced = Counter.builder(\"orders.placed\")\n            .description(\"Total orders placed\")\n            .register(meterRegistry);\n    }\n    \n    public void placeOrder() {\n        // Business logic\n        ordersPlaced.increment();\n    }\n}"
          },
          "codeExplanations": {
            "english": "Creates a custom counter metric 'orders.placed'. Micrometer's MeterRegistry registers it. Every time placeOrder() is called, the counter increments. Visible at /actuator/metrics/orders.placed.",
            "hinglish": "Ek custom counter metric 'orders.placed' banata hai. Micrometer ka MeterRegistry ise register karta hai. Har baar jab placeOrder() call hota hai, counter badhta hai. /actuator/metrics/orders.placed par visible hota hai."
          },
          "keyPoints": [
            "Access specific metric: /actuator/metrics/jvm.memory.used?tag=area:heap",
            "Micrometer acts as a facade‚Äîsupports Prometheus, Datadog, New Relic out-of-the-box",
            "Avoid cardinality explosion: don‚Äôt tag metrics with high-variability values (e.g., user IDs)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Track API latency: http.server.requests{uri=\"/login\", status=\"200\"}",
              "Monitor thread pool: tomcat.threads.busy"
            ]
          }
        },
        {
          "id": "topic-env-endpoints",
          "title": "‚öôÔ∏è Env Endpoints",
          "explanations": {
            "english": "The /actuator/env endpoint reveals all environment properties (application.properties, system env vars, JVM args). Extremely useful for debugging config issues but HIGH RISK in production‚Äîexposes secrets like passwords. Always restrict access via security rules.",
            "hinglish": "/actuator/env endpoint saare environment properties dikhata hai (application.properties, system env vars, JVM args). Config issues debug karne ke liye bahut useful hai lekin production mein HIGH RISK‚Äîpasswords jaise secrets expose karta hai. Hamesha security rules ke zariye access restrict karein."
          },
          "code": {
            "title": "Secure Env Endpoint Access",
            "language": "java",
            "content": "@Configuration\npublic class ActuatorSecurity extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .requestMatchers(EndpointRequest.to(\"env\")).hasRole(\"ADMIN\")\n            .requestMatchers(EndpointRequest.toAnyEndpoint()).permitAll()\n            .and().httpBasic();\n    }\n}"
          },
          "codeExplanations": {
            "english": "Spring Security config that restricts /actuator/env access to users with ADMIN role only. Other actuator endpoints remain publicly accessible. Always use HTTPS and role-based access in production.",
            "hinglish": "Spring Security configuration jo /actuator/env tak sirf ADMIN role wale users ko access deta hai. Baki ke actuator endpoints publicly accessible rehte hain. Production mein hamesha HTTPS aur role-based access ka use karein."
          },
          "keyPoints": [
            "Never expose /env publicly in production‚Äîcontains sensitive configuration",
            "Use /actuator/configprops for safer bean-bound properties inspection",
            "Combine with Spring Cloud Config for centralized, encrypted property management"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Debug why feature flag isn't working: check active profile properties via /env",
              "Verify encrypted DB password is decrypted correctly at runtime"
            ]
          }
        },
        {
          "id": "topic-production-security",
          "title": "üîí Production Security",
          "explanations": {
            "english": "Actuator endpoints are powerful but dangerous if exposed publicly. Best practices: 1) Expose only essential endpoints (health, info), 2) Use Spring Security to restrict sensitive endpoints (env, beans) to admin roles, 3) Change default context path (/actuator), 4) Use network policies (firewalls) to limit access to internal IPs only.",
            "hinglish": "Actuator endpoints powerful hain lekin agar publicly expose ho jayein to khatarnak hain. Best practices: 1) Sirf zaroori endpoints (health, info) expose karein, 2) Sensitive endpoints (env, beans) ko admin roles tak limit karne ke liye Spring Security ka use karein, 3) Default context path (/actuator) badal dein, 4) Sirf internal IPs tak access limit karne ke liye network policies (firewalls) ka use karein."
          },
          "code": {
            "title": "Minimal Safe Exposure (application.properties)",
            "language": "properties",
            "content": "management.endpoints.web.exposure.include=health,info\nmanagement.endpoints.web.base-path=/monitoring\nmanagement.endpoint.health.show-details=when_authorized\nmanagement.info.env.enabled=true"
          },
          "codeExplanations": {
            "english": "Exposes ONLY health and info endpoints under /monitoring path. Health details visible only to authenticated users. Prevents accidental exposure of sensitive data like env or beans.",
            "hinglish": "Sirf health aur info endpoints ko /monitoring path ke neeche expose karta hai. Health details sirf authenticated users ko dikhti hain. env ya beans jaise sensitive data ke accidental exposure ko rokta hai."
          },
          "keyPoints": [
            "Default exposure: only 'health' and 'info' are safe for public access",
            "Always set management.endpoints.web.exposure.include explicitly‚Äînever use '*' in prod",
            "Combine application-level security with infrastructure controls (VPC, firewalls)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Bad: management.endpoints.web.exposure.include=* ‚Üí exposes all endpoints",
              "Good: Restrict /env to localhost via firewall rules even if app config is misconfigured"
            ]
          }
        },
        {
          "id": "topic-k8s-readiness",
          "title": "‚úÖ Kubernetes Readiness",
          "explanations": {
            "english": "Readiness probe tells Kubernetes when a pod is ready to receive traffic. Uses /actuator/health/readiness endpoint (Spring Boot 2.3+). If readiness fails, Kubernetes stops sending requests to the pod but keeps it running for recovery. Critical for zero-downtime deployments and handling slow-starting dependencies (e.g., database connections).",
            "hinglish": "Readiness probe Kubernetes ko batata hai ki kab koi pod traffic receive karne ke liye ready hai. /actuator/health/readiness endpoint ka use karta hai (Spring Boot 2.3+). Agar readiness fail hoti hai, Kubernetes us pod ko requests bhejna band kar deta hai lekin recovery ke liye use chalta rakhta hai. Zero-downtime deployments aur slow-starting dependencies (jaise database connections) ke liye bahut zaroori hai."
          },
          "code": {
            "title": "Kubernetes Deployment Snippet",
            "language": "yaml",
            "content": "readinessProbe:\n  httpGet:\n    path: /actuator/health/readiness\n    port: 8080\n  initialDelaySeconds: 10\n  periodSeconds: 5\n  failureThreshold: 3"
          },
          "codeExplanations": {
            "english": "Kubernetes checks /actuator/health/readiness every 5 seconds after 10s startup delay. If 3 consecutive checks fail, pod is marked unready. Traffic stops flowing until health recovers.",
            "hinglish": "Kubernetes 10 seconds ke startup delay ke baad har 5 seconds mein /actuator/health/readiness check karta hai. Agar 3 consecutive checks fail hote hain, pod unready mark ho jata hai. Traffic tab tak band rehta hai jab tak health recover nahi ho jati."
          },
          "keyPoints": [
            "Readiness ‚â† Liveness: Readiness controls traffic routing; liveness controls pod restarts",
            "Customize readiness groups: management.health.readiness.group.includes=db,redis",
            "Prevents traffic during startup or when dependent services are temporarily unavailable"
          ],
          "extras": {
            "flowDiagram": "App Start ‚Üí [K8s waits] ‚Üí Readiness Probe Success? ‚Üí YES ‚Üí Send Traffic\n                                      ‚Üì NO\n                              [Hold traffic, keep pod running]",
            "comparisonTable": [],
            "examples": [
              "App starts but DB connection pool not ready ‚Üí Readiness = DOWN ‚Üí No user traffic",
              "During deployment: New pod passes readiness ‚Üí Old pod drains traffic smoothly"
            ]
          }
        },
        {
          "id": "topic-k8s-liveness",
          "title": "üîÑ Kubernetes Liveness",
          "explanations": {
            "english": "Liveness probe tells Kubernetes when to restart a unhealthy pod. Uses /actuator/health/liveness endpoint. If liveness fails repeatedly, Kubernetes kills and restarts the pod. Use cautiously‚Äîmisconfiguration causes restart loops. Ideal for catching frozen threads or deadlocks.",
            "hinglish": "Liveness probe Kubernetes ko batata hai ki kab kisi unhealthy pod ko restart karna hai. /actuator/health/liveness endpoint ka use karta hai. Agar liveness repeatedly fail hoti hai, Kubernetes pod ko kill karke restart karta hai. Saavdhani se use karein‚Äîgalat configuration restart loops cause kar sakti hai. Frozen threads ya deadlocks pakadne ke liye perfect hai."
          },
          "code": {
            "title": "Liveness Probe Configuration",
            "language": "yaml",
            "content": "livenessProbe:\n  httpGet:\n    path: /actuator/health/liveness\n    port: 8080\n  initialDelaySeconds: 60\n  periodSeconds: 10\n  failureThreshold: 3\n  timeoutSeconds: 5"
          },
          "codeExplanations": {
            "english": "Checks liveness every 10s after 60s startup. 3 failures within timeout trigger pod restart. Higher initialDelay prevents killing pods during slow initialization.",
            "hinglish": "60 seconds ke startup ke baad har 10 seconds mein liveness check karta hai. Timeout ke andar 3 failures pod restart trigger karte hain. Higher initialDelay slow initialization ke dauran pods ko kill hone se bachata hai."
          },
          "keyPoints": [
            "Set longer initialDelaySeconds than readinessProbe to avoid killing slow-starting apps",
            "Never include external dependencies (DB, APIs) in liveness checks‚Äîonly internal app state",
            "Monitor restart counts: frequent restarts indicate liveness misconfiguration or app bugs"
          ],
          "extras": {
            "flowDiagram": "Pod Running ‚Üí Liveness Probe Fails? ‚Üí NO ‚Üí Continue\n                          ‚Üì YES (3x)\n                  [K8s restarts pod]",
            "comparisonTable": [],
            "examples": [
              "App deadlock detected ‚Üí Liveness = DOWN ‚Üí Kubernetes restarts pod automatically",
              "Misconfiguration: Liveness checks DB ‚Üí DB slow ‚Üí Pod restart loop ‚Üí Outage"
            ]
          }
        },
        {
          "id": "topic-prometheus-integration",
          "title": "üìà Prometheus Integration",
          "explanations": {
            "english": "Prometheus is a time-series database for metrics. Spring Boot apps expose metrics via /actuator/prometheus endpoint (requires micrometer-registry-prometheus dependency). Prometheus server 'scrapes' this endpoint periodically to store metrics. Enables alerting, dashboards, and trend analysis.",
            "hinglish": "Prometheus metrics ke liye ek time-series database hai. Spring Boot apps /actuator/prometheus endpoint ke zariye metrics expose karte hain (micrometer-registry-prometheus dependency chahiye). Prometheus server is endpoint ko periodically 'scrape' karta hai metrics store karne ke liye. Alerting, dashboards, aur trend analysis enable karta hai."
          },
          "code": {
            "title": "Prometheus Scraping Config",
            "language": "yaml",
            "content": "scrape_configs:\n  - job_name: 'spring-boot-app'\n    metrics_path: '/actuator/prometheus'\n    static_configs:\n      - targets: ['app-service:8080']\n    scrape_interval: 15s"
          },
          "codeExplanations": {
            "english": "Prometheus configuration to scrape metrics from Spring Boot app every 15 seconds. Targets should match your service DNS name in Kubernetes. Metrics appear in Prometheus UI for querying.",
            "hinglish": "Prometheus configuration jo Spring Boot app se har 15 seconds mein metrics scrape karta hai. Targets ko Kubernetes mein aapke service DNS name se match karna chahiye. Metrics Prometheus UI mein querying ke liye appear hote hain."
          },
          "keyPoints": [
            "Add dependency: io.micrometer:micrometer-registry-prometheus",
            "Metrics format: Prometheus text-based exposition format (key-value pairs with tags)",
            "Use Prometheus Alertmanager to trigger alerts on metric thresholds (e.g., error rate > 5%)"
          ],
          "extras": {
            "flowDiagram": "App ‚Üí /actuator/prometheus ‚Üí [Prometheus Scrapes] ‚Üí Store Metrics ‚Üí Query/Alert",
            "comparisonTable": [],
            "examples": [
              "Query in Prometheus: http_server_requests_seconds_count{uri=\"/api/orders\", status=\"500\"}",
              "Alert rule: IF rate(http_server_requests_seconds_count{status=~\"5..\"}[5m]) > 0.1"
            ]
          }
        },
        {
          "id": "topic-grafana-integration",
          "title": "üé® Grafana Integration",
          "explanations": {
            "english": "Grafana visualizes metrics stored in Prometheus. Create dashboards showing real-time graphs: request rates, error percentages, JVM memory. Import Spring Boot dashboards from Grafana Labs (ID: 12115). Set up alerts that notify Slack/email when thresholds are breached.",
            "hinglish": "Grafana Prometheus mein stored metrics ko visualize karta hai. Real-time graphs dikhane wale dashboards banayein: request rates, error percentages, JVM memory. Grafana Labs (ID: 12115) se Spring Boot dashboards import karein. Thresholds cross hone par Slack/email notify karne wale alerts set karein."
          },
          "code": {
            "title": "Sample Grafana Dashboard Query",
            "language": "promql",
            "content": "// HTTP Error Rate (last 5m)\nsum(rate(http_server_requests_seconds_count{status=~\"5..\"}[5m])) by (uri)\n\n// JVM Heap Usage\njvm_memory_used_bytes{area=\"heap\"} / jvm_memory_max_bytes{area=\"heap\"}"
          },
          "codeExplanations": {
            "english": "First query calculates 5xx error rate per API endpoint. Second shows JVM heap usage percentage. Paste these into Grafana panel queries to generate live graphs.",
            "hinglish": "Pehla query har API endpoint ke liye 5xx error rate calculate karta hai. Dusra JVM heap usage percentage dikhata hai. Inhe Grafana panel queries mein paste karein live graphs banane ke liye."
          },
          "keyPoints": [
            "Connect Grafana to Prometheus as a data source first",
            "Use variables (e.g., $app) in dashboards for dynamic filtering across environments",
            "Share dashboards via JSON export or Grafana Cloud for team collaboration"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Dashboard panel: 'Requests/sec' graph with green (2xx) and red (5xx) lines",
              "Alert: 'High CPU Usage' ‚Üí Fires when instance:cpu_utilization:avg5m > 85%"
            ]
          }
        }
      ]
    },
    {
      "id": "section-logging",
      "title": "üìù Logging",
      "intro": "Go beyond System.out.println! Learn professional logging with SLF4J facade, Logback implementation, structured JSON logs for ELK stack, MDC for contextual tracing, and distributed request tracking.",
      "topics": [
        {
          "id": "topic-logging-overview",
          "title": "üîç Logging Overview",
          "explanations": {
            "english": "Logging captures runtime events for debugging, auditing, and monitoring. Spring Boot uses SLF4J (Simple Logging Facade for Java) as a unified API with Logback as the default implementation. Avoid System.out‚Äîuse logger.info(), logger.error() for configurable, asynchronous, and production-safe logging.",
            "hinglish": "Logging runtime events ko debugging, auditing, aur monitoring ke liye capture karta hai. Spring Boot SLF4J (Simple Logging Facade for Java) ko unified API ke roop mein use karta hai jisme Logback default implementation hai. System.out avoid karein‚Äîconfigurable, asynchronous, aur production-safe logging ke liye logger.info(), logger.error() ka use karein."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "SLF4J is a facade‚Äîswap Logback for Log4j2 without code changes",
            "Log levels: TRACE < DEBUG < INFO < WARN < ERROR (configure per package)",
            "Never log passwords, tokens, or PII (Personally Identifiable Information)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "DEBUG: Detailed flow during development",
              "ERROR: Exception stack traces with context for production alerts"
            ]
          }
        },
        {
          "id": "topic-slf4j",
          "title": "üß± SLF4J",
          "explanations": {
            "english": "SLF4J (Simple Logging Facade for Java) is an abstraction layer. Your code logs against SLF4J API, not a specific implementation (Logback/Log4j2). This decouples logging logic from the backend‚Äîchange logging frameworks by swapping dependencies, not code. Spring Boot starters include SLF4J bindings automatically.",
            "hinglish": "SLF4J (Simple Logging Facade for Java) ek abstraction layer hai. Aapka code specific implementation (Logback/Log4j2) ke bajaye SLF4J API ke against log karta hai. Yeh logging logic ko backend se alag karta hai‚Äîdependencies swap karke bina code change kiye logging frameworks badal sakte hain. Spring Boot starters automatically SLF4J bindings include karte hain."
          },
          "code": {
            "title": "SLF4J Logger Usage",
            "language": "java",
            "content": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Service\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n    \n    public User createUser(String email) {\n        logger.info(\"Creating user with email: {}\", email);\n        try {\n            // ...\n        } catch (Exception e) {\n            logger.error(\"Failed to create user for {}\", email, e);\n        }\n    }\n}"
          },
          "codeExplanations": {
            "english": "Logger instance is static final for performance. Uses parameterized logging ({} placeholder) to avoid string concatenation overhead when log level is disabled. Exception passed as last argument for full stack trace.",
            "hinglish": "Performance ke liye Logger instance static final hai. Parameterized logging ({} placeholder) ka use karta hai taaki jab log level disabled ho to string concatenation overhead na ho. Full stack trace ke liye exception last argument ke roop mein pass kiya gaya hai."
          },
          "keyPoints": [
            "Always use parameterized messages: logger.debug(\"Id={}\", id) not logger.debug(\"Id=\"+id)",
            "Logger name convention: LoggerFactory.getLogger(ClassName.class)",
            "SLF4J bindings resolve at runtime‚Äîensure only ONE binding dependency exists"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Multiple bindings error: Exclude conflicting dependencies in pom.xml",
              "Bridge legacy logs: jcl-over-slf4j routes Apache Commons Logging to SLF4J"
            ]
          }
        },
        {
          "id": "topic-logback",
          "title": "‚öôÔ∏è Logback",
          "explanations": {
            "english": "Logback is Spring Boot's default logging implementation (fast, native SLF4J support). Configure via logback-spring.xml for profiles, rolling files, and console output. Supports async logging for high-throughput apps. Spring Boot enhances it with colored console logs and profile-specific configs.",
            "hinglish": "Logback Spring Boot ka default logging implementation hai (tez, native SLF4J support ke saath). logback-spring.xml ke zariye profiles, rolling files, aur console output ke liye configure karein. High-throughput apps ke liye async logging support karta hai. Spring Boot ise colored console logs aur profile-specific configs ke saath enhance karta hai."
          },
          "code": {
            "title": "logback-spring.xml Snippet",
            "language": "xml",
            "content": "<configuration>\n  <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n    <encoder>\n      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n    </encoder>\n  </appender>\n  \n  <appender name=\"ROLLING\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <file>logs/app.log</file>\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n      <fileNamePattern>logs/app-%d{yyyy-MM-dd}.%i.log</fileNamePattern>\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n    <encoder>\n      <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>\n    </encoder>\n  </appender>\n  \n  <root level=\"INFO\">\n    <appender-ref ref=\"CONSOLE\" />\n    <appender-ref ref=\"ROLLING\" />\n  </root>\n</configuration>"
          },
          "codeExplanations": {
            "english": "Console appender prints colored logs to terminal. Rolling file appender creates daily log files (app-2026-01-27.0.log) and keeps 30 days history. Root logger set to INFO level‚ÄîDEBUG logs ignored.",
            "hinglish": "Console appender terminal par colored logs print karta hai. Rolling file appender rozana log files (app-2026-01-27.0.log) banata hai aur 30 din ka history rakhta hai. Root logger INFO level par set hai‚ÄîDEBUG logs ignore ho jate hain."
          },
          "keyPoints": [
            "Use logback-spring.xml (not logback.xml) to leverage Spring Boot features like profiles",
            "AsyncAppender boosts performance: wraps other appenders for non-blocking I/O",
            "Test logging config with spring-boot-starter-test's OutputCapture"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Profile-specific: <springProfile name=\"prod\"> sets file appender only in production",
              "Log rotation: Prevents disk fill-up by archiving old logs"
            ]
          }
        },
        {
          "id": "topic-structured-json-logging",
          "title": "üì¶ Structured JSON Logging",
          "explanations": {
            "english": "Structured logs (JSON format) are machine-readable‚Äîcritical for log aggregators like ELK Stack (Elasticsearch, Logstash, Kibana) or Splunk. Each log event becomes a JSON object with fields (timestamp, level, message, traceId). Enables powerful filtering, correlation, and dashboards.",
            "hinglish": "Structured logs (JSON format) machine-readable hote hain‚ÄîELK Stack (Elasticsearch, Logstash, Kibana) ya Splunk jaise log aggregators ke liye bahut zaroori hain. Har log event ek JSON object ban jata hai fields ke saath (timestamp, level, message, traceId). Powerful filtering, correlation, aur dashboards enable karta hai."
          },
          "code": {
            "title": "Logback JSON Encoder (pom.xml + logback-spring.xml)",
            "language": "xml",
            "content": "<!-- pom.xml dependency -->\n<dependency>\n  <groupId>net.logstash.logback</groupId>\n  <artifactId>logstash-logback-encoder</artifactId>\n  <version>7.4</version>\n</dependency>\n\n<!-- logback-spring.xml appender -->\n<appender name=\"JSON\" class=\"ch.qos.logback.core.ConsoleAppender\">\n  <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"/>\n</appender>"
          },
          "codeExplanations": {
            "english": "Adds Logstash encoder dependency. Console appender now outputs JSON instead of text. Each log line is a valid JSON object parseable by log shippers (Filebeat, Fluentd).",
            "hinglish": "Logstash encoder dependency add karta hai. Console appender ab text ke bajaye JSON output karta hai. Har log line ek valid JSON object hoti hai jo log shippers (Filebeat, Fluentd) dwara parse ki ja sakti hai."
          },
          "keyPoints": [
            "Never parse text logs‚Äîstructured JSON enables reliable field extraction",
            "Include custom fields: MDC (Mapped Diagnostic Context) injects traceId, userId",
            "Cloud-native: Required for AWS CloudWatch Logs Insights, GCP Logging queries"
          ],
          "extras": {
            "flowDiagram": "App ‚Üí JSON Log ‚Üí [Filebeat] ‚Üí Elasticsearch ‚Üí Kibana Dashboard",
            "comparisonTable": [],
            "examples": [
              "{\"@timestamp\":\"2026-01-27T10:30:00Z\",\"level\":\"INFO\",\"message\":\"User logged in\",\"userId\":\"123\"}",
              "Kibana query: level:ERROR AND message:*timeout*"
            ]
          }
        },
        {
          "id": "topic-mdc",
          "title": "üßµ MDC (Mapped Diagnostic Context)",
          "explanations": {
            "english": "MDC is a thread-local map to attach contextual data (user ID, request ID) to logs. Values set at request start (e.g., in a Filter) automatically appear in all logs from that thread. Critical for tracing requests across microservices and filtering logs by transaction.",
            "hinglish": "MDC ek thread-local map hai jo contextual data (user ID, request ID) ko logs se jodta hai. Request start par values set karein (jaise Filter mein), woh automatically us thread ke saare logs mein appear hongi. Microservices ke beech requests trace karne aur transaction ke hisaab se logs filter karne ke liye bahut zaroori hai."
          },
          "code": {
            "title": "MDC in Servlet Filter",
            "language": "java",
            "content": "@Component\n@Order(Ordered.HIGHEST_PRECEDENCE)\npublic class MdcFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        try {\n            String requestId = UUID.randomUUID().toString();\n            MDC.put(\"requestId\", requestId);\n            MDC.put(\"userId\", extractUserId(request));\n            chain.doFilter(request, response);\n        } finally {\n            MDC.clear(); // Prevent thread pollution in thread pools\n        }\n    }\n}"
          },
          "codeExplanations": {
            "english": "Generates unique requestId per HTTP request. Puts requestId and userId into MDC. All subsequent logs in this request include these fields. finally block clears MDC to avoid leaking data to next request in thread pool.",
            "hinglish": "Har HTTP request ke liye unique requestId generate karta hai. requestId aur userId ko MDC mein daalta hai. Is request ke saare aage ke logs in fields ko include karte hain. finally block MDC ko clear karta hai taaki thread pool mein agle request ko data leak na ho."
          },
          "keyPoints": [
            "MDC is thread-local‚Äîworks perfectly with Spring MVC's thread-per-request model",
            "Clear MDC in finally block! Critical for async/thread-pool scenarios",
            "Log pattern must include %X{requestId} to output MDC values"
          ],
          "extras": {
            "flowDiagram": "HTTP Request ‚Üí Filter sets MDC ‚Üí Service logs ‚Üí [All logs have requestId] ‚Üí Clear MDC",
            "comparisonTable": [],
            "examples": [
              "Log line: [requestId=abc-123] User created successfully",
              "Kibana: Search all logs for requestId=abc-123 to see full request flow"
            ]
          }
        },
        {
          "id": "topic-request-tracing",
          "title": "üîç Request Tracing",
          "explanations": {
            "english": "Distributed tracing tracks a request across microservices using trace IDs and span IDs. Spring Cloud Sleuth auto-injects traceId/spanId into logs and propagates them via HTTP headers (X-B3-TraceId). Integrates with Zipkin/Jaeger for visualizing request flows and latency bottlenecks.",
            "hinglish": "Distributed tracing trace IDs aur span IDs ka use karke ek request ko microservices ke beech track karta hai. Spring Cloud Sleuth logs mein automatically traceId/spanId inject karta hai aur unhe HTTP headers (X-B3-TraceId) ke zariye propagate karta hai. Request flows aur latency bottlenecks visualize karne ke liye Zipkin/Jaeger ke saath integrate karta hai."
          },
          "code": {
            "title": "Sleuth + Zipkin Setup (pom.xml)",
            "language": "xml",
            "content": "<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-sleuth</artifactId>\n</dependency>\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-sleuth-zipkin</artifactId>\n</dependency>\n\n# application.properties\nspring.zipkin.base-url=http://zipkin:9411\nspring.sleuth.sampler.probability=1.0 # Sample 100% in dev"
          },
          "codeExplanations": {
            "english": "Sleuth adds traceId/spanId to logs automatically. Zipkin dependency sends traces to Zipkin server. Sampler probability controls % of requests traced (set low in prod to reduce overhead).",
            "hinglish": "Sleuth automatically logs mein traceId/spanId add karta hai. Zipkin dependency traces ko Zipkin server par bhejta hai. Sampler probability traced hone wale requests ka % control karta hai (overhead kam karne ke liye production mein low set karein)."
          },
          "keyPoints": [
            "Trace ID flows across services via headers‚Äîcorrelate logs from multiple apps",
            "Log pattern must include %X{traceId} and %X{spanId} to see tracing context",
            "Sampling is essential: tracing 100% of requests adds significant overhead"
          ],
          "extras": {
            "flowDiagram": "User Request ‚Üí Service A (traceId=xyz) ‚Üí [HTTP Header] ‚Üí Service B (same traceId) ‚Üí Zipkin UI",
            "comparisonTable": [],
            "examples": [
              "Log entry: [traceId=xyz, spanId=abc] Processing payment",
              "Zipkin UI: Shows timeline of request across 5 services with latency per hop"
            ]
          }
        }
      ]
    },
    {
      "id": "section-testing",
      "title": "üß™ Testing Strategies",
      "intro": "Write faster, targeted tests with Spring Boot's testing utilities. Slice tests for controllers/repos, full context integration tests, and robust mocking with Testcontainers for realistic database testing.",
      "topics": [
        {
          "id": "topic-testing-strategies-overview",
          "title": "üéØ Testing Strategies Overview",
          "explanations": {
            "english": "Effective testing balances speed and coverage. Spring Boot offers: 1) Slice tests (@WebMvcTest) for isolated layer testing, 2) Full context tests (@SpringBootTest) for integration flows, 3) Mocking (@MockBean) to isolate dependencies. Choose the right tool‚Äîslice tests run in seconds; full context tests validate end-to-end behavior.",
            "hinglish": "Effective testing speed aur coverage ko balance karta hai. Spring Boot provide karta hai: 1) Slice tests (@WebMvcTest) isolated layer testing ke liye, 2) Full context tests (@SpringBootTest) integration flows ke liye, 3) Mocking (@MockBean) dependencies ko isolate karne ke liye. Sahi tool chunein‚Äîslice tests seconds mein chalte hain; full context tests end-to-end behavior validate karte hain."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Slice tests: Fast (seconds), test one layer (controller, repo), auto-configure only relevant beans",
            "Full context tests: Slower (minutes), load entire app context, validate complex workflows",
            "Testcontainers: Real databases in Docker‚Äîbest for integration tests requiring actual DB behavior"
          ],
          "extras": {
            "flowDiagram": "Test Goal? ‚Üí Unit Logic? ‚Üí Use JUnit/Mockito\n             ‚Üì\n      Test Web Layer? ‚Üí @WebMvcTest\n             ‚Üì\n      Test DB Layer? ‚Üí @DataJpaTest\n             ‚Üì\n      Full Flow? ‚Üí @SpringBootTest + Testcontainers",
            "comparisonTable": [],
            "examples": [
              "Slice test: Verify controller returns 200 for valid input",
              "Full test: User registers ‚Üí email sent ‚Üí DB record created"
            ]
          }
        },
        {
          "id": "topic-test-slices",
          "title": "üî™ Test Slices",
          "explanations": {
            "english": "Test slices load only a portion of the Spring application context‚Äîdramatically faster than full context tests. Annotations like @WebMvcTest auto-configure just the web layer (controllers, Jackson, MVC infrastructure) and mock everything else (services, repos). Ideal for focused, rapid feedback during development.",
            "hinglish": "Test slices Spring application context ka sirf ek hissa load karte hain‚Äîfull context tests se bahut tez. @WebMvcTest jaise annotations automatically sirf web layer (controllers, Jackson, MVC infrastructure) configure karte hain aur baki sab kuch (services, repos) mock karte hain. Focused, rapid feedback ke liye development ke dauran perfect."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Slice tests run 5-10x faster than @SpringBootTest",
            "Auto-mocks dependencies‚Äîno need for manual @MockBean in simple cases",
            "Limited scope: Cannot test interactions between layers (e.g., controller + service)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Test Slice Type",
                "column2": "Tests"
              },
              {
                "column1": "@WebMvcTest",
                "column2": "Spring MVC controllers, REST APIs"
              },
              {
                "column1": "@DataJpaTest",
                "column2": "JPA repositories, database queries"
              },
              {
                "column1": "@JsonTest",
                "column2": "Jackson serialization/deserialization"
              },
              {
                "column1": "@RestClientTest",
                "column2": "RestTemplate/WebClient calls"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "topic-webmvctest",
          "title": "üåê @WebMvcTest",
          "explanations": {
            "english": "@WebMvcTest focuses testing on Spring MVC controllers. It auto-configures MockMvc for HTTP request simulation, loads only controller beans, and mocks all service/repository dependencies. Perfect for verifying request mappings, status codes, JSON responses, and validation errors without starting a server.",
            "hinglish": "@WebMvcTest Spring MVC controllers par testing focus karta hai. Yeh HTTP request simulation ke liye MockMvc auto-configure karta hai, sirf controller beans load karta hai, aur saare service/repository dependencies mock karta hai. Bina server start kiye request mappings, status codes, JSON responses, aur validation errors verify karne ke liye perfect."
          },
          "code": {
            "title": "Controller Slice Test",
            "language": "java",
            "content": "@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService; // Auto-mocked, but we control behavior\n    \n    @Test\n    void shouldReturnUserWhenExists() throws Exception {\n        when(userService.findById(1L)).thenReturn(new User(1L, \"john@example.com\"));\n        \n        mockMvc.perform(get(\"/api/users/1\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n}"
          },
          "codeExplanations": {
            "english": "Tests UserController in isolation. MockMvc simulates GET /api/users/1. userService is mocked‚Äîwe define its behavior with Mockito. Verifies HTTP 200 and JSON response structure. No database or real service calls.",
            "hinglish": "UserController ko isolation mein test karta hai. MockMvc GET /api/users/1 simulate karta hai. userService mocked hai‚Äîhum Mockito se uska behavior define karte hain. HTTP 200 aur JSON response structure verify karta hai. Koi database ya real service calls nahi."
          },
          "keyPoints": [
            "Use @MockBean to override auto-mocked dependencies with custom behavior",
            "MockMvc methods: perform(), andExpect(), andDo() for assertions and logging",
            "Add @AutoConfigureJsonTesters for easy JSON path assertions"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test validation: POST with invalid email ‚Üí expect status 400 + error message in JSON",
              "Test security: Add @WithMockUser to simulate authenticated requests"
            ]
          }
        },
        {
          "id": "topic-datajpatest",
          "title": "üóÑÔ∏è @DataJpaTest",
          "explanations": {
            "english": "@DataJpaTest configures an in-memory database (H2) and loads only JPA repository beans. Tests database queries, entity mappings, and Spring Data features. Transactions roll back automatically after each test‚Äîno cleanup needed. Avoid using with full application context tests for speed.",
            "hinglish": "@DataJpaTest ek in-memory database (H2) configure karta hai aur sirf JPA repository beans load karta hai. Database queries, entity mappings, aur Spring Data features test karta hai. Har test ke baad transactions automatically roll back hote hain‚Äîcleanup ki zaroorat nahi. Speed ke liye ise full application context tests ke saath use nahi karna chahiye."
          },
          "code": {
            "title": "Repository Slice Test",
            "language": "java",
            "content": "@DataJpaTest\nclass UserRepositoryTest {\n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void shouldFindUserByEmail() {\n        // Given\n        userRepository.save(new User(null, \"test@example.com\"));\n        \n        // When\n        Optional<User> result = userRepository.findByEmail(\"test@example.com\");\n        \n        // Then\n        assertThat(result).isPresent();\n        assertThat(result.get().getEmail()).isEqualTo(\"test@example.com\");\n    }\n}"
          },
          "codeExplanations": {
            "english": "Saves a user to the in-memory H2 database. Queries repository directly. Test runs in a transaction that rolls back after completion‚Äîdatabase is clean for next test. Uses AssertJ assertions for readability.",
            "hinglish": "Ek user ko in-memory H2 database mein save karta hai. Repository ko directly query karta hai. Test ek aisi transaction mein chalta hai jo completion ke baad roll back ho jati hai‚Äîdatabase agle test ke liye clean rehta hai. Readability ke liye AssertJ assertions ka use karta hai."
          },
          "keyPoints": [
            "Uses embedded H2 database by default‚Äîno external DB needed",
            "Transactional tests: @Rollback(false) to keep data (rarely needed)",
            "Add @AutoConfigureTestDatabase(replace = NONE) to use real DB (e.g., Testcontainers)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test native query: @Query(\"SELECT ...\") method returns expected results",
              "Test entity lifecycle: @PrePersist sets createdAt timestamp correctly"
            ]
          }
        },
        {
          "id": "topic-jsontest",
          "title": "üî§ @JsonTest",
          "explanations": {
            "english": "@JsonTest verifies JSON serialization/deserialization with Jackson. Auto-configures JacksonTester beans to convert objects to/from JSON strings. Test if @JsonProperty names match API contracts, custom serializers work, or date formats are correct‚Äîwithout full web context overhead.",
            "hinglish": "@JsonTest Jackson ke saath JSON serialization/deserialization verify karta hai. Objects ko JSON strings mein convert karne ke liye JacksonTester beans auto-configure karta hai. Check karein ki @JsonProperty names API contracts se match karte hain, custom serializers kaam karte hain, ya date formats sahi hain‚Äîbina full web context overhead ke."
          },
          "code": {
            "title": "JSON Serialization Test",
            "language": "java",
            "content": "@JsonTest\nclass UserJsonTest {\n    @Autowired\n    private JacksonTester<User> json;\n    \n    @Test\n    void shouldSerializeUserToJson() throws Exception {\n        User user = new User(1L, \"john@example.com\");\n        \n        // When\n        JsonContent<User> content = json.write(user);\n        \n        // Then\n        assertThat(content).hasJsonPathValue(\"$.id\", 1);\n        assertThat(content).hasJsonPathValue(\"$.email\", \"john@example.com\");\n        assertThat(content).doesNotHaveJsonPathValue(\"$.password\"); // Security check!\n    }\n}"
          },
          "codeExplanations": {
            "english": "JacksonTester converts User object to JSON string. Assertions verify field names, values, and absence of sensitive fields (password). Fast test focused purely on JSON mapping logic.",
            "hinglish": "JacksonTester User object ko JSON string mein convert karta hai. Assertions field names, values, aur sensitive fields (password) ke absence verify karte hain. JSON mapping logic par purely focused tez test."
          },
          "keyPoints": [
            "Test field names, null handling, and custom serializers/deserializers",
            "Verify sensitive fields (passwords) are excluded via @JsonIgnore",
            "Combine with @WebMvcTest to validate full controller JSON output"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test date format: @JsonFormat(pattern = \"yyyy-MM-dd\") outputs \"2026-01-27\"",
              "Test enum serialization: Status.ACTIVE ‚Üí \"active\" in JSON"
            ]
          }
        },
        {
          "id": "topic-full-context-tests",
          "title": "üåç Full Context Tests",
          "explanations": {
            "english": "Full context tests load the entire Spring application context using @SpringBootTest. Used for end-to-end integration tests: verify controller ‚Üí service ‚Üí repository ‚Üí database flow. Slower than slice tests but essential for complex workflows. Control scope with webEnvironment = NONE for non-web tests.",
            "hinglish": "Full context tests @SpringBootTest ka use karke poora Spring application context load karte hain. End-to-end integration tests ke liye use hote hain: controller ‚Üí service ‚Üí repository ‚Üí database flow verify karte hain. Slice tests se dheeme hote hain lekin complex workflows ke liye zaroori hain. Non-web tests ke liye webEnvironment = NONE ke saath scope control karein."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Use sparingly‚Äîreserve for critical user journeys (login, checkout)",
            "Set webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT to test with real HTTP server",
            "Combine with @Testcontainers for realistic database testing",
            "Profile activation: @ActiveProfiles(\"test\") loads test-specific configs"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test user registration flow: POST /register ‚Üí DB save ‚Üí welcome email sent",
              "Test security: Invalid token ‚Üí 401 Unauthorized on protected endpoint"
            ]
          }
        },
        {
          "id": "topic-springboottest",
          "title": "BootTest @SpringBootTest",
          "explanations": {
            "english": "@SpringBootTest is the foundation for full integration tests. It searches for @SpringBootConfiguration (usually your main class) and builds the complete application context. Use @AutoConfigureMockMvc for controller tests with real context, or inject TestRestTemplate for HTTP calls. Always pair with @Transactional to roll back DB changes.",
            "hinglish": "@SpringBootTest full integration tests ki foundation hai. Yeh @SpringBootConfiguration (aam taur par aapka main class) dhundhta hai aur poora application context banata hai. Real context ke saath controller tests ke liye @AutoConfigureMockMvc ka use karein, ya HTTP calls ke liye TestRestTemplate inject karein. Hamesha DB changes roll back karne ke liye @Transactional ke saath pair karein."
          },
          "code": {
            "title": "Full Integration Test",
            "language": "java",
            "content": "@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@Transactional\nclass RegistrationIntegrationTest {\n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void shouldRegisterNewUser() {\n        // Given\n        UserRegistrationRequest request = new UserRegistrationRequest(\"new@example.com\", \"pass123\");\n        \n        // When\n        ResponseEntity<UserResponse> response = restTemplate.postForEntity(\n            \"/api/register\", request, UserResponse.class);\n        \n        // Then\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n        assertThat(userRepository.findByEmail(\"new@example.com\")).isPresent();\n    }\n}"
          },
          "codeExplanations": {
            "english": "Starts app on random port. TestRestTemplate sends real HTTP POST to /api/register. Transactional test rolls back DB insert after test‚Äîno cleanup needed. Verifies HTTP status and database state.",
            "hinglish": "App ko random port par start karta hai. TestRestTemplate /api/register par real HTTP POST bhejta hai. Transactional test test ke baad DB insert roll back karta hai‚Äîcleanup ki zaroorat nahi. HTTP status aur database state verify karta hai."
          },
          "keyPoints": [
            "webEnvironment = RANDOM_PORT: Starts embedded server for realistic HTTP testing",
            "@Transactional: Rolls back DB changes after each test‚Äîkeeps tests isolated",
            "Use @DirtiesContext sparingly (resets context) only when tests mutate static state"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test password encoding: Save user ‚Üí verify stored password is hashed (not plain text)",
              "Test async behavior: @Async method completes within test timeout"
            ]
          }
        },
        {
          "id": "topic-mocking",
          "title": "üé≠ Mocking",
          "explanations": {
            "english": "Mocking replaces real dependencies with controllable test doubles. Isolate the unit under test, simulate edge cases (errors, timeouts), and avoid slow/flaky external calls (DB, APIs). Spring Boot enhances Mockito with @MockBean for Spring context integration.",
            "hinglish": "Mocking asli dependencies ko controllable test doubles ke saath replace karta hai. Test ke unit ko isolate karein, edge cases (errors, timeouts) simulate karein, aur slow/flaky external calls (DB, APIs) se bachein. Spring Boot Mockito ko Spring context integration ke liye @MockBean ke saath enhance karta hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Mockito.mock(): Create mocks manually outside Spring context",
            "@MockBean: Replaces Spring bean with mock in application context",
            "Verify interactions: verify(mock).methodCall() ensures expected behavior",
            "Avoid over-mocking: Test real behavior where possible (use Testcontainers for DB)"
          ],
          "extras": {
            "flowDiagram": "Test Starts ‚Üí @MockBean replaces real bean ‚Üí Test runs with mock ‚Üí Verify interactions",
            "comparisonTable": [],
            "examples": [
              "Simulate payment failure: when(paymentService.charge()).thenThrow(new PaymentException())",
              "Verify email sent: verify(emailService).sendWelcomeEmail(user)"
            ]
          }
        },
        {
          "id": "topic-mockbean",
          "title": "üå± @MockBean",
          "explanations": {
            "english": "@MockBean is Spring Boot's extension of Mockito.mock(). It injects a mock into the Spring application context, replacing any existing bean of the same type. Essential for slice tests (@WebMvcTest) and full context tests where you need to isolate a layer (e.g., mock service in controller test).",
            "hinglish": "@MockBean Mockito.mock() ka Spring Boot extension hai. Yeh Spring application context mein ek mock inject karta hai, same type ke kisi bhi existing bean ko replace karke. Slice tests (@WebMvcTest) aur full context tests ke liye zaroori hai jahan aapko ek layer ko isolate karna ho (jaise controller test mein service mock karna)."
          },
          "code": {
            "title": "@MockBean in Slice Test",
            "language": "java",
            "content": "@WebMvcTest(OrderController.class)\nclass OrderControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private OrderService orderService; // Replaces real OrderService bean\n    \n    @Test\n    void shouldReturn404WhenOrderNotFound() throws Exception {\n        when(orderService.getOrderById(999L)).thenThrow(new OrderNotFoundException());\n        \n        mockMvc.perform(get(\"/api/orders/999\"))\n            .andExpect(status().isNotFound());\n    }\n}"
          },
          "codeExplanations": {
            "english": "@MockBean creates a Mockito mock of OrderService and registers it in the test context. When controller calls orderService.getOrderById(999), it throws exception. Verifies controller handles error correctly by returning 404.",
            "hinglish": "@MockBean OrderService ka Mockito mock banata hai aur use test context mein register karta hai. Jab controller orderService.getOrderById(999) call karta hai, toh exception throw karta hai. Verify karta hai ki controller error ko sahi handle karta hai 404 return karke."
          },
          "keyPoints": [
            "Scope: Mock exists only in current test class context",
            "Reset: Mocks reset after each test method‚Äîno interaction leakage",
            "Use @SpyBean when you need partial mocking (real object with some methods mocked)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Mock external API: when(weatherClient.getForecast()).thenReturn(mockResponse)",
              "Verify retry logic: verify(paymentService, times(3)).processPayment()"
            ]
          }
        },
        {
          "id": "topic-mockito",
          "title": "üÉè Mockito",
          "explanations": {
            "english": "Mockito is the standard mocking framework for Java. Create mocks, define behavior (when/thenReturn), verify interactions (verify), and spy on real objects. Spring Boot testing starters include Mockito‚Äîno extra dependency needed. Master core patterns: stubbing, verification, argument matchers.",
            "hinglish": "Mockito Java ke liye standard mocking framework hai. Mocks banayein, behavior define karein (when/thenReturn), interactions verify karein (verify), aur real objects par spy karein. Spring Boot testing starters mein Mockito included hai‚Äîextra dependency ki zaroorat nahi. Core patterns ko master karein: stubbing, verification, argument matchers."
          },
          "code": {
            "title": "Mockito Core Patterns",
            "language": "java",
            "content": "// Create mock\nUserService mockUserService = Mockito.mock(UserService.class);\n\n// Stub method\nwhen(mockUserService.getUserById(1L)).thenReturn(new User(1L, \"test@example.com\"));\nwhen(mockUserService.getUserById(999L)).thenThrow(new UserNotFoundException());\n\n// Use mock\nUser user = mockUserService.getUserById(1L);\nassertThat(user.getEmail()).isEqualTo(\"test@example.com\");\n\n// Verify interaction\nverify(mockUserService).getUserById(1L);\nverify(mockUserService, never()).deleteUser(anyLong());\n\n// Argument matcher\nverify(emailService).sendWelcomeEmail(argThat(u -> u.getEmail().endsWith(\"@example.com\")));"
          },
          "codeExplanations": {
            "english": "Creates mock UserService. Defines return values for specific inputs. Verifies methods were called with expected arguments. Argument matchers (anyLong, argThat) handle dynamic values. Essential for behavior-driven testing.",
            "hinglish": "Mock UserService banata hai. Specific inputs ke liye return values define karta hai. Verify karta hai ki methods expected arguments ke saath call hue. Argument matchers (anyLong, argThat) dynamic values handle karte hain. Behavior-driven testing ke liye zaroori."
          },
          "keyPoints": [
            "Stubbing: when(...).thenReturn(...) defines mock behavior",
            "Verification: verify(mock).method() checks if method was called",
            "ArgumentCaptor: Capture arguments passed to mocks for detailed assertions",
            "Avoid mocking value objects‚Äîmock only complex dependencies (services, clients)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Test error handling: when(repo.save()).thenThrow(new DataIntegrityViolationException())",
              "Verify async call: verify(notificationService, timeout(100).times(1)).send()"
            ]
          }
        },
        {
          "id": "topic-testcontainers",
          "title": "üê≥ Testcontainers",
          "explanations": {
            "english": "Testcontainers runs real databases, message brokers, or services in Docker containers during tests. Solves 'works on my machine' issues‚Äîtests use identical environments to production. Slower than H2 but catches dialect-specific bugs (PostgreSQL JSONB, MySQL locks). Ideal for @DataJpaTest or @SpringBootTest with real DB.",
            "hinglish": "Testcontainers tests ke dauran Docker containers mein real databases, message brokers, ya services chalata hai. 'Works on my machine' issues ko solve karta hai‚Äîtests production ke identical environments use karte hain. H2 se dheema hai lekin dialect-specific bugs (PostgreSQL JSONB, MySQL locks) pakadta hai. @DataJpaTest ya @SpringBootTest ke saath real DB ke liye perfect."
          },
          "code": {
            "title": "PostgreSQL Test with Testcontainers",
            "language": "java",
            "content": "@SpringBootTest\n@Testcontainers\nclass UserRepositoryIntegrationTest {\n    \n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")\n        .withDatabaseName(\"testdb\")\n        .withUsername(\"testuser\")\n        .withPassword(\"testpass\");\n    \n    @DynamicPropertySource\n    static void configureProperties(DynamicPropertyRegistry registry) {\n        registry.add(\"spring.datasource.url\", postgres::getJdbcUrl);\n        registry.add(\"spring.datasource.username\", postgres::getUsername);\n        registry.add(\"spring.datasource.password\", postgres::getPassword);\n    }\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void shouldSaveUserToRealPostgreSQL() {\n        userRepository.save(new User(null, \"container@example.com\"));\n        assertThat(userRepository.findByEmail(\"container@example.com\")).isPresent();\n    }\n}"
          },
          "codeExplanations": {
            "english": "Spins up PostgreSQL 15 container before tests. @DynamicPropertySource injects container's JDBC URL into Spring config. Test runs against real PostgreSQL‚Äîcatches SQL dialect issues. Container stops automatically after tests.",
            "hinglish": "Tests se pehle PostgreSQL 15 container start karta hai. @DynamicPropertySource container ka JDBC URL Spring config mein inject karta hai. Test real PostgreSQL ke against chalta hai‚ÄîSQL dialect issues pakadta hai. Container tests ke baad automatically band ho jata hai."
          },
          "keyPoints": [
            "Use @Testcontainers + @Container for JUnit 5 lifecycle management",
            "Reuse containers across test classes with singleton pattern for speed",
            "Test complex scenarios: Kafka messages, Redis caching, Elasticsearch queries",
            "CI/CD compatible: Works in GitHub Actions, GitLab CI with Docker support"
          ],
          "extras": {
            "flowDiagram": "Test Starts ‚Üí [Docker] Start Container ‚Üí Run Tests ‚Üí Stop Container ‚Üí Test Pass/Fail",
            "comparisonTable": [],
            "examples": [
              "Test PostgreSQL JSONB query: repository.findUsersByMetadata(\"{\\\"role\\\":\\\"admin\\\"}\")",
              "Test Redis cache: Verify cache hit/miss metrics with real Redis instance"
            ]
          }
        }
      ]
    },
      {
      "id": "microservices-fundamentals",
      "title": "üèóÔ∏è Microservices Fundamentals",
      "intro": "Understand core architectural shifts from monoliths to microservices, including domain boundaries and team structures essential for distributed systems success.",
      "topics": [
        {
          "id": "microservices-fundamentals-monolith",
          "title": "üß± Monolith",
          "explanations": {
            "english": "A monolithic architecture packages all application components (UI, business logic, database layer) into a single deployable unit. Simple to develop and deploy initially, but becomes hard to scale, maintain, or update as the codebase grows. Changes require full redeployment, and failures can bring down the entire system.",
            "hinglish": "Monolith architecture mein pura application‚ÄîUI, business logic, database sab kuch‚Äîek single unit ke andar hota hai. Shuruat mein banana aur deploy karna aasan hota hai, lekin code badhne ke saath scale karna, maintain karna ya update karna mushkil ho jata hai. Koi bhi change ke liye poora application redeploy karna padta hai, aur koi failure pure system ko giraa sakta hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Single codebase, build, and deployment artifact",
            "Tight coupling makes isolated changes risky and slow",
            "Scaling requires replicating the entire application, even unused features"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Traditional banking application where customer management, transactions, and reporting share one database and codebase",
              "Early versions of Shopify or Amazon before microservices migration"
            ]
          }
        },
        {
          "id": "microservices-fundamentals-microservices",
          "title": "üì¶ Microservices",
          "explanations": {
            "english": "Microservices architecture decomposes an application into small, independent services organized around business capabilities. Each service has its own codebase, database, and deployment lifecycle. Services communicate via APIs or messages, enabling independent scaling, technology diversity, and faster delivery cycles.",
            "hinglish": "Microservices architecture application ko chhote, independent services mein todta hai jo business capabilities ke around bante hain. Har service ka apna codebase, database aur deployment hota hai. Services APIs ya messages ke zariye baat karte hain, jisse alag-alag scale karna, alag technology use karna aur tez delivery possible hoti hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Loose coupling: Failure in one service doesn't cascade to others",
            "Independent deployment: Teams release features without coordinating full releases",
            "Polyglot persistence: Choose best database per service (SQL, NoSQL, etc.)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [
              {
                "column1": "Monolith",
                "column2": "Microservices"
              },
              {
                "column1": "Single deployment unit",
                "column2": "Independent service deployments"
              },
              {
                "column1": "Shared database",
                "column2": "Database per service"
              },
              {
                "column1": "Slower innovation cycles",
                "column2": "Faster feature delivery"
              }
            ],
            "examples": [
              "Netflix: Video streaming, recommendations, and billing as separate services",
              "Uber: Rider app, driver app, payment, and trip management as independent services"
            ]
          }
        },
        {
          "id": "microservices-fundamentals-bounded-contexts",
          "title": "üó∫Ô∏è Bounded Contexts",
          "explanations": {
            "english": "A Bounded Context (from Domain-Driven Design) defines explicit boundaries where a specific domain model applies. In microservices, each service owns one bounded context‚Äîits data, rules, and terminology. This prevents ambiguity (e.g., 'Customer' means different things in Sales vs. Support contexts) and reduces coupling between services.",
            "hinglish": "Bounded Context (Domain-Driven Design se) wo clear boundary define karta hai jahan ek specific domain model kaam karta hai. Microservices mein, har service apna bounded context rakhta hai‚Äîapna data, rules, aur terminology. Isse ambiguity khatam hoti hai (jaise 'Customer' ka matlab Sales aur Support mein alag hota hai) aur services ke beech coupling kam hoti hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Each service has its own data model and business rules",
            "Context mapping (e.g., anti-corruption layer) handles integration between contexts",
            "Aligns service boundaries with business domains, not technical layers"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "E-commerce: 'Order' context (payment, status) vs. 'Inventory' context (stock levels, warehouses)",
              "Healthcare: 'Patient Records' context vs. 'Billing' context with different data rules"
            ]
          }
        },
        {
          "id": "microservices-fundamentals-team-autonomy",
          "title": "üë• Team Autonomy",
          "explanations": {
            "english": "Team autonomy means cross-functional teams own services end-to-end‚Äîfrom design and coding to deployment and monitoring. Teams choose their tech stack, work independently, and deploy without waiting for other teams. This accelerates innovation but requires strong DevOps culture, clear APIs, and shared observability practices.",
            "hinglish": "Team autonomy ka matlab hai ki cross-functional teams apne services ko end-to-end control karte hain‚Äîdesign se lekar deployment aur monitoring tak. Teams apna tech stack choose kar sakte hain, independently kaam kar sakte hain, bina dusri teams ka intezaar kiye deploy kar sakte hain. Isse innovation tez hoti hai, lekin strong DevOps culture, clear APIs, aur shared monitoring ki zaroorat hoti hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Conway's Law in action: Team structure shapes system architecture",
            "Reduces bottlenecks; teams deploy 10-100x more frequently",
            "Requires investment in self-service platforms (CI/CD, logging, metrics)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Spotify model: Squads own features/services with full autonomy",
              "Amazon 'Two Pizza Teams': Small teams responsible for specific services"
            ]
          }
        }
      ]
    },
    {
      "id": "communication-patterns",
      "title": "üì° Communication Patterns",
      "intro": "Explore synchronous and asynchronous communication styles between services, including protocols, trade-offs, and Spring Cloud implementations for resilient inter-service calls.",
      "topics": [
        {
          "id": "communication-patterns-synchronous-communication",
          "title": "‚è±Ô∏è Synchronous Communication",
          "explanations": {
            "english": "Synchronous communication requires the client to wait for a response before proceeding. Common in request-response scenarios (e.g., fetching user data). Pros: Simple, immediate feedback. Cons: Tight temporal coupling; client blocks if service is slow/unavailable. Use timeouts, retries, and circuit breakers for resilience.",
            "hinglish": "Synchronous communication mein client ko response aane tak rukna padta hai. Ye request-response scenarios (jaise user data lana) mein common hai. Fayde: Simple, turant feedback. Nuksan: Client aur service ke beech tight dependency; agar service slow ho ya down ho, client ruk jata hai. Resilience ke liye timeouts, retries aur circuit breakers use karein."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Client blocks until response arrives or timeout occurs",
            "Best for real-time user-facing operations (e.g., login, search)",
            "Requires resilience patterns to handle failures gracefully"
          ],
          "extras": {
            "flowDiagram": "Client ‚Üí [Request] ‚Üí Service A ‚Üí [Wait] ‚Üí [Response] ‚Üí Client\n          (Blocks during wait)",
            "comparisonTable": [
              {
                "column1": "Synchronous",
                "column2": "Asynchronous"
              },
              {
                "column1": "Request-response model",
                "column2": "Fire-and-forget or event-driven"
              },
              {
                "column1": "Client waits",
                "column2": "Client continues immediately"
              },
              {
                "column1": "Higher latency risk",
                "column2": "Better fault isolation"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "communication-patterns-rest",
          "title": "üåê REST",
          "explanations": {
            "english": "REST (Representational State Transfer) uses HTTP methods (GET, POST, PUT, DELETE) over URLs to interact with resources. Stateless, cacheable, and human-readable. Widely adopted for microservices due to simplicity, tooling support, and compatibility with web standards. Ideal for CRUD operations and public APIs.",
            "hinglish": "REST (Representational State Transfer) resources ke saath interact karne ke liye HTTP methods (GET, POST, etc.) aur URLs use karta hai. Stateless, cacheable, aur insaan ke liye samajhne mein aasan. Microservices ke liye popular hai kyunki simple hai, tools available hain, aur web standards ke saath compatible hai. CRUD operations aur public APIs ke liye best hai."
          },
          "code": {
            "title": "Spring Boot REST Controller",
            "language": "java",
            "content": "@RestController\n@RequestMapping(\"/api/orders\")\npublic class OrderController {\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<Order> getOrder(@PathVariable Long id) {\n        return ResponseEntity.ok(orderService.findById(id));\n    }\n    \n    @PostMapping\n    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {\n        Order newOrder = orderService.create(request);\n        return ResponseEntity.status(HttpStatus.CREATED)\n                .header(\"Location\", \"/api/orders/\" + newOrder.getId())\n                .body(newOrder);\n    }\n}"
          },
          "codeExplanations": {
            "english": "This controller exposes two REST endpoints: GET /api/orders/{id} retrieves an order, POST /api/orders creates one. @RestController combines controller and response body handling. Path variables and JSON bodies are auto-mapped by Spring. HTTP status codes (200 OK, 201 Created) follow REST conventions.",
            "hinglish": "Ye controller do REST endpoints expose karta hai: GET se order milta hai, POST se naya order banta hai. @RestController controller aur response body handling ko jodta hai. Path variables aur JSON bodies Spring ke dwara automatically map ho jaate hain. HTTP status codes (200 OK, 201 Created) REST conventions ke hisaab se hain."
          },
          "keyPoints": [
            "Uses standard HTTP verbs and status codes",
            "Stateless: Each request contains all needed context",
            "Resources identified by URIs; representations in JSON/XML"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "GET /api/users/123 ‚Üí Returns user details in JSON",
              "DELETE /api/cart/items/456 ‚Üí Removes item from cart"
            ]
          }
        },
        {
          "id": "communication-patterns-feign",
          "title": "ü¶Ö Feign Client",
          "explanations": {
            "english": "Feign is a declarative HTTP client for Java. Instead of writing boilerplate REST calls, define an interface with Spring annotations. Spring Cloud Feign auto-generates the implementation, integrates with Service Discovery (Eureka), and supports fallbacks for resilience. Simplifies inter-service communication in Spring Boot apps.",
            "hinglish": "Feign Java ke liye ek declarative HTTP client hai. Boilerplate code likhne ki jagah, aap interface banate hain Spring annotations ke saath. Spring Cloud Feign khud implementation banata hai, Service Discovery (Eureka) ke saath kaam karta hai, aur resilience ke liye fallbacks support karta hai. Spring Boot apps mein services ke beech communication aasan karta hai."
          },
          "code": {
            "title": "Declarative Feign Client",
            "language": "java",
            "content": "@FeignClient(name = \"user-service\", fallback = UserClientFallback.class)\npublic interface UserClient {\n    \n    @GetMapping(\"/api/users/{id}\")\n    User getUserById(@PathVariable(\"id\") Long userId);\n    \n    @PostMapping(\"/api/users/validate\")\n    Boolean validateUser(@RequestBody UserValidationRequest request);\n}\n\n@Component\npublic class UserClientFallback implements UserClient {\n    public User getUserById(Long userId) {\n        return new User().setFallback(true); // Safe default\n    }\n    public Boolean validateUser(UserValidationRequest r) { return false; }\n}"
          },
          "codeExplanations": {
            "english": "UserClient interface declares methods mapped to user-service endpoints. @FeignClient handles HTTP calls, service discovery, and load balancing. Fallback class provides safe defaults during failures (e.g., return dummy user). Reduces error-prone REST template code significantly.",
            "hinglish": "UserClient interface methods declare karta hai jo user-service ke endpoints se match karte hain. @FeignClient HTTP calls, service discovery aur load balancing sambhalta hai. Fallback class failures ke time safe default deta hai (jaise dummy user). Error-prone REST template code kam karta hai."
          },
          "keyPoints": [
            "Declarative: Define interfaces, not HTTP logic",
            "Auto-integrates with Eureka for service discovery",
            "Built-in support for fallbacks (resilience) and interceptors"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "communication-patterns-grpc",
          "title": "‚ö° gRPC",
          "explanations": {
            "english": "gRPC is a high-performance RPC framework using HTTP/2 and Protocol Buffers (binary serialization). Enables strongly-typed contracts via .proto files. Ideal for internal service communication needing low latency, streaming, or mobile backends. More efficient than REST/JSON but less human-readable and firewall-friendly.",
            "hinglish": "gRPC ek tez RPC framework hai jo HTTP/2 aur Protocol Buffers (binary format) use karta hai. .proto files ke zariye strongly-typed contracts banata hai. Internal services ke liye best jab low latency, streaming ya mobile backend ki zaroorat ho. REST/JSON se zyada efficient hai lekin insaan ke liye padhna mushkil aur firewall ke saath compatibility kam hai."
          },
          "code": {
            "title": "gRPC Service Definition & Call",
            "language": "proto",
            "content": "// user.proto\nsyntax = \"proto3\";\nservice UserService {\n  rpc GetUser (UserRequest) returns (UserResponse);\n}\nmessage UserRequest { int64 id = 1; }\nmessage UserResponse { string name = 1; bool active = 2; }\n\n// Java client call\nUserServiceGrpc.UserServiceBlockingStub stub = \n    UserServiceGrpc.newBlockingStub(channel);\nUserResponse response = stub.getUser(UserRequest.newBuilder().setId(101).build());"
          },
          "codeExplanations": {
            "english": "user.proto defines the service contract and data structures. Compiling generates client/server code in Java. The stub handles serialization, HTTP/2 transport, and error handling. Binary Protocol Buffers reduce payload size vs JSON, improving speed for internal traffic.",
            "hinglish": "user.proto service contract aur data structures define karta hai. Compile karne se Java mein client/server code generate hota hai. Stub serialization, HTTP/2 transport aur error handling sambhalta hai. Binary Protocol Buffers JSON se chhota payload banaate hain, internal traffic ke liye speed badhate hain."
          },
          "keyPoints": [
            "Protocol Buffers: Compact binary format, faster than JSON/XML",
            "HTTP/2 features: Multiplexing, server/client streaming",
            "Strong typing: Compile-time contract validation"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "communication-patterns-asynchronous-communication",
          "title": "üì¨ Asynchronous Communication",
          "explanations": {
            "english": "Asynchronous communication decouples services: sender emits a message/event and continues without waiting. Receiver processes it later. Enables event-driven architectures, resilience (queues buffer failures), and scalability (workers process at own pace). Ideal for notifications, analytics, or non-blocking workflows.",
            "hinglish": "Asynchronous communication services ko alag karta hai: sender message bhejta hai aur bina ruke aage badhta hai. Receiver use baad mein process karta hai. Event-driven architecture, resilience (queues failures ko handle karte hain) aur scalability (workers apni speed se kaam karte hain) enable karta hai. Notifications, analytics ya non-blocking workflows ke liye perfect hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Fire-and-forget: Sender doesn't wait for processing",
            "Message brokers (Kafka, RabbitMQ) persist and route messages",
            "Supports complex patterns: pub/sub, work queues, event sourcing"
          ],
          "extras": {
            "flowDiagram": "Service A ‚Üí [Publish Event] ‚Üí Broker ‚Üí [Queue] ‚Üí Service B (processes later)\nService C ‚Üí [Subscribe] ‚Üí Broker ‚Üí [Queue] ‚Üí Service D",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "communication-patterns-rabbitmq",
          "title": "üêá RabbitMQ",
          "explanations": {
            "english": "RabbitMQ is a message broker implementing AMQP protocol. Routes messages from producers to consumers via exchanges and queues. Supports patterns like work queues (competing consumers), pub/sub, and RPC. Reliable with acknowledgments, retries, and dead-letter queues. Great for task distribution and decoupling.",
            "hinglish": "RabbitMQ ek message broker hai jo AMQP protocol follow karta hai. Producers se messages ko exchanges aur queues ke zariye consumers tak pahunchata hai. Work queues (competing consumers), pub/sub, RPC jaise patterns support karta hai. Acknowledgments, retries aur dead-letter queues ke saath reliable hai. Tasks distribute karne aur decoupling ke liye best hai."
          },
          "code": {
            "title": "Spring Boot RabbitMQ Listener",
            "language": "java",
            "content": "@RabbitListener(queues = \"order.created.queue\")\npublic void handleOrderCreated(OrderEvent event) {\n    log.info(\"Processing order: {}\", event.getOrderId());\n    inventoryService.reserveStock(event.getItems());\n    // Auto-ack on success; retry on exception\n}\n\n// Publisher\nrabbitTemplate.convertAndSend(\n    \"order.exchange\", \n    \"order.created.routing.key\", \n    new OrderEvent(orderId, items)\n);"
          },
          "codeExplanations": {
            "english": "@RabbitListener auto-binds to a queue and processes messages. RabbitTemplate publishes events to an exchange with routing keys. Spring Boot auto-configures connection, serialization, and error handling. Failed messages can be retried or sent to dead-letter queues.",
            "hinglish": "@RabbitListener khud queue se jujhta hai aur messages process karta hai. RabbitTemplate events ko exchange aur routing key ke saath bhejta hai. Spring Boot connection, serialization aur error handling khud set karta hai. Fail hui messages retry ya dead-letter queue mein ja sakti hain."
          },
          "keyPoints": [
            "Exchanges route messages to queues using binding rules",
            "At-least-once delivery with manual/automatic acknowledgments",
            "Plugins for management UI, MQTT, STOMP"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Order service publishes 'order.created' ‚Üí Inventory service consumes to reserve stock",
              "Email service consumes 'user.registered' event to send welcome email"
            ]
          }
        },
        {
          "id": "communication-patterns-kafka",
          "title": "üê≥ Kafka",
          "explanations": {
            "english": "Apache Kafka is a distributed event streaming platform. Stores streams of records in topics (partitioned, replicated logs). Consumers read at their own pace with offset tracking. Built for high throughput, durability, and replayability. Ideal for event sourcing, real-time analytics, and log aggregation.",
            "hinglish": "Apache Kafka ek distributed event streaming platform hai. Records ko topics mein store karta hai (partitioned, replicated logs). Consumers apni speed se padhte hain offset tracking ke saath. High throughput, durability aur replayability ke liye banana gaya hai. Event sourcing, real-time analytics aur log aggregation ke liye perfect hai."
          },
          "code": {
            "title": "Kafka Consumer in Spring Boot",
            "language": "java",
            "content": "@KafkaListener(topics = \"payment-events\", groupId = \"fraud-check-group\")\npublic void listen(PaymentEvent event) {\n    if (event.getAmount() > 10000) {\n        fraudService.flagForReview(event);\n    }\n}\n\n// application.yml config\nspring:\n  kafka:\n    bootstrap-servers: kafka-broker:9092\n    consumer:\n      auto-offset-reset: earliest\n      group-id: fraud-check-group"
          },
          "codeExplanations": {
            "english": "@KafkaListener subscribes to a topic. Spring manages offsets, deserialization, and threading. groupId enables consumer groups for parallel processing. Config in YAML sets brokers, offset strategy, and serialization. Kafka retains messages, allowing consumers to reprocess historical data.",
            "hinglish": "@KafkaListener topic ko subscribe karta hai. Spring offsets, deserialization aur threading sambhalta hai. groupId parallel processing ke liye consumer groups enable karta hai. YAML config brokers, offset strategy aur serialization set karta hai. Kafka messages ko retain karta hai, consumers historical data dobara process kar sakte hain."
          },
          "keyPoints": [
            "Topics partitioned for parallelism and scalability",
            "Persistent storage: Messages retained for configurable time",
            "Consumer groups enable load balancing across instances"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "User activity events streamed to Kafka ‚Üí consumed by analytics service for dashboards",
              "Order events stored in Kafka ‚Üí replayed to rebuild inventory service state after failure"
            ]
          }
        }
      ]
    },
    {
      "id": "api-gateway",
      "title": "üö™ API Gateway",
      "intro": "Learn how API Gateways act as a single entry point for clients, handling routing, security, rate limiting, and cross-cutting concerns to simplify microservices interactions.",
      "topics": [
        {
          "id": "api-gateway-spring-cloud-gateway",
          "title": "Spring Cloud Gateway",
          "explanations": {
            "english": "Spring Cloud Gateway is a non-blocking, reactive API gateway built on Spring WebFlux and Project Reactor. Routes requests to microservices based on predicates (path, header, etc.) and applies filters (modify headers, add auth tokens). Replaces Netflix Zuul; integrates with Service Discovery and Circuit Breakers.",
            "hinglish": "Spring Cloud Gateway ek non-blocking, reactive API gateway hai jo Spring WebFlux aur Project Reactor par bana hai. Requests ko predicates (path, header, etc.) ke hisaab se microservices tak route karta hai aur filters lagata hai (headers modify karna, auth tokens add karna). Netflix Zuul ko replace karta hai; Service Discovery aur Circuit Breakers ke saath integrate karta hai."
          },
          "code": {
            "title": "Gateway Routing Configuration (YAML)",
            "language": "yaml",
            "content": "spring:\n  cloud:\n    gateway:\n      routes:\n        - id: user-service\n          uri: lb://user-service\n          predicates:\n            - Path=/api/users/**\n          filters:\n            - RewritePath=/api/users/(?<segment>.*), /$\\{segment}\n        - id: order-service\n          uri: lb://order-service\n          predicates:\n            - Path=/api/orders/**\n            - Method=GET\n          filters:\n            - name: RequestRateLimiter\n              args:\n                redis-rate-limiter.replenishRate: 10\n                redis-rate-limiter.burstCapacity: 20"
          },
          "codeExplanations": {
            "english": "Routes define path-based routing to services registered in Eureka (lb:// uses client-side load balancing). RewritePath strips /api prefix before forwarding. RequestRateLimiter filter uses Redis for distributed rate limiting. Predicates can combine path, method, headers, or custom logic.",
            "hinglish": "Routes path ke basis par requests ko services tak bhejte hain jo Eureka mein registered hain (lb:// client-side load balancing use karta hai). RewritePath forward karne se pehle /api prefix hata deta hai. RequestRateLimiter filter Redis use karke rate limiting karta hai. Predicates path, method, headers ya custom logic combine kar sakte hain."
          },
          "keyPoints": [
            "Reactive (non-blocking) architecture for high concurrency",
            "Predicates define 'when to route'; filters define 'what to do'",
            "Auto-integrates with Eureka for service discovery"
          ],
          "extras": {
            "flowDiagram": "Client ‚Üí Gateway ‚Üí [Route Match?] ‚Üí Yes ‚Üí [Apply Filters] ‚Üí Service\n                             ‚Üì No\n                      Return 404",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "api-gateway-routing",
          "title": "üîÄ Routing",
          "explanations": {
            "english": "Routing directs client requests to the appropriate backend service. Gateway uses predicates (path, host, header, query param) to match routes. Supports path rewriting, prefix stripping, and weighted routing for canary deployments. Critical for hiding internal service topology from clients.",
            "hinglish": "Routing client ke requests ko sahi backend service tak pahunchata hai. Gateway predicates (path, host, header, query param) use karke routes match karta hai. Path rewriting, prefix stripping aur weighted routing (canary deployments ke liye) support karta hai. Clients se internal service structure chhupane ke liye zaroori hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Path-based routing most common (e.g., /api/users ‚Üí user-service)",
            "Header-based routing for A/B testing or versioning",
            "Dynamic route reloading without restart (via Spring Cloud Config)"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "All requests to /api/payments/** routed to payment-service instances",
              "Requests with header 'X-Version: v2' routed to new service version for testing"
            ]
          }
        },
        {
          "id": "api-gateway-rate-limiting",
          "title": "‚è±Ô∏è Rate Limiting",
          "explanations": {
            "english": "Rate limiting controls how many requests a client can make in a time window. Prevents abuse, protects backend services from overload, and enforces fair usage. Implemented at gateway using algorithms like token bucket (Redis-backed for distributed systems). Configurable per route, user, or API key.",
            "hinglish": "Rate limiting decide karta hai ki ek client ek time window mein kitne requests kar sakta hai. Abuse rokta hai, backend services ko overload se bachata hai aur fair usage enforce karta hai. Gateway par token bucket algorithm (distributed systems ke liye Redis ke saath) use karke implement kiya jata hai. Route, user ya API key ke hisaab se configure kiya ja sakta hai."
          },
          "code": {
            "title": "Custom Rate Limiter Bean",
            "language": "java",
            "content": "@Bean\npublic RedisRateLimiter redisRateLimiter() {\n    return new RedisRateLimiter(10, 20); // replenishRate, burstCapacity\n}\n\n// In route config (YAML):\nfilters:\n  - name: RequestRateLimiter\n    args:\n      redis-rate-limiter.replenishRate: 10\n      redis-rate-limiter.burstCapacity: 20\n      key-resolver: \"#{@userKeyResolver}\""
          },
          "codeExplanations": {
            "english": "RedisRateLimiter uses Redis to track request counts across gateway instances. replenishRate = tokens added per second; burstCapacity = max tokens allowed. key-resolver determines rate limit scope (e.g., per API key). Returns 429 Too Many Requests when limit exceeded.",
            "hinglish": "RedisRateLimiter Redis use karke gateway instances ke across request counts track karta hai. replenishRate = har second tokens add hote hain; burstCapacity = max tokens. key-resolver rate limit scope decide karta hai (jaise per API key). Limit cross hone par 429 Too Many Requests return karta hai."
          },
          "keyPoints": [
            "Protects services from traffic spikes and DDoS attacks",
            "Redis enables consistent limits across multiple gateway instances",
            "Custom key resolvers for user/API-key-based limits"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "Free tier: 100 requests/minute per API key",
              "Premium tier: 1000 requests/minute with higher burst capacity"
            ]
          }
        },
        {
          "id": "api-gateway-authentication",
          "title": "üîí Authentication",
          "explanations": {
            "english": "Authentication at the gateway verifies client identity before routing requests. Common patterns: validate JWT tokens (check signature, expiry), forward tokens to services, or inject user context. Centralizes security logic, reduces duplication in services, and blocks unauthorized requests early.",
            "hinglish": "Gateway par authentication client ki identity verify karta hai request route karne se pehle. Common patterns: JWT tokens validate karna (signature, expiry check karna), tokens services ko forward karna, ya user context inject karna. Security logic ko centralize karta hai, services mein duplication kam karta hai aur unauthorized requests ko early block karta hai."
          },
          "code": {
            "title": "JWT Validation Filter",
            "language": "java",
            "content": "@Component\npublic class JwtAuthFilter extends AbstractGatewayFilterFactory<...> {\n    \n    @Override\n    public GatewayFilter apply(Config config) {\n        return (exchange, chain) -> {\n            String token = exchange.getRequest()\n                .getHeaders().getFirst(\"Authorization\");\n            if (isValidJwt(token)) {\n                // Add user info to header for downstream services\n                ServerHttpRequest request = exchange.getRequest().mutate()\n                    .header(\"X-User-Id\", extractUserId(token))\n                    .build();\n                return chain.filter(exchange.mutate().request(request).build());\n            }\n            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n            return exchange.getResponse().setComplete();\n        };\n    }\n}"
          },
          "codeExplanations": {
            "english": "Custom filter checks Authorization header for valid JWT. On success, injects X-User-Id header for downstream services. On failure, returns 401 immediately. Token validation includes signature check, expiry, and issuer verification. Integrates with Spring Security for key management.",
            "hinglish": "Custom filter Authorization header mein valid JWT check karta hai. Success par, X-User-Id header downstream services ke liye add karta hai. Failure par, turant 401 return karta hai. Token validation mein signature check, expiry aur issuer verification shamil hain. Key management ke liye Spring Security ke saath integrate karta hai."
          },
          "keyPoints": [
            "Validate tokens once at edge; avoid per-service validation",
            "Forward authenticated context (user ID, roles) to services via headers",
            "Combine with OAuth2/OIDC for social logins or SSO"
          ],
          "extras": {
            "flowDiagram": "Client ‚Üí [Request + JWT] ‚Üí Gateway ‚Üí [Validate JWT?] ‚Üí Valid ‚Üí [Add X-User-Id] ‚Üí Service\n                                                      ‚Üì Invalid\n                                                Return 401",
            "comparisonTable": [],
            "examples": []
          }
        }
      ]
    },
    {
      "id": "service-discovery",
      "title": "üß≠ Service Discovery",
      "intro": "Discover how services dynamically locate each other in changing environments using service registries like Eureka, enabling location transparency and client-side load balancing.",
      "topics": [
        {
          "id": "service-discovery-eureka-server",
          "title": "üì° Eureka Server",
          "explanations": {
            "english": "Eureka Server is the service registry in Netflix OSS. Microservices (clients) register themselves with Eureka on startup and send periodic heartbeats. Eureka maintains a real-time list of available service instances. If heartbeats stop, instances are removed after a timeout. Provides a dashboard for monitoring registrations.",
            "hinglish": "Eureka Server Netflix OSS ka service registry hai. Microservices (clients) startup par khud ko Eureka mein register karte hain aur periodic heartbeats bhejte hain. Eureka available service instances ki real-time list rakhta hai. Agar heartbeats band ho jaayein, timeout ke baad instances remove ho jaate hain. Registrations monitor karne ke liye dashboard provide karta hai."
          },
          "code": {
            "title": "Eureka Server Setup",
            "language": "java",
            "content": "@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n# application.yml\nserver:\n  port: 8761\neureka:\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n  server:\n    wait-time-in-ms-when-sync-empty: 0"
          },
          "codeExplanations": {
            "english": "@EnableEurekaServer activates registry functionality. Port 8761 is conventional. register-with-eureka: false because server doesn't register itself. fetch-registry: false as it's the source of truth. wait-time-in-ms... avoids startup delays when no peers exist.",
            "hinglish": "@EnableEurekaServer registry functionality ko activate karta hai. Port 8761 conventional hai. register-with-eureka: false kyunki server khud ko register nahi karta. fetch-registry: false kyunki ye source of truth hai. wait-time-in-ms... startup delays ko avoid karta hai jab koi peer nahi hota."
          },
          "keyPoints": [
            "Self-preservation mode: Keeps instances during network partitions to avoid mass eviction",
            "Peer replication: Multiple Eureka servers sync registries for high availability",
            "Dashboard at http://localhost:8761 for monitoring"
          ],
          "extras": {
            "flowDiagram": "Service Instance ‚Üí [Register + Heartbeat] ‚Üí Eureka Server\nClient ‚Üí [Fetch Registry] ‚Üí Eureka Server ‚Üí Returns instance list",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "service-discovery-eureka-client",
          "title": "üîå Eureka Client",
          "explanations": {
            "english": "Eureka Client is a library added to microservices. On startup, it registers the service with Eureka Server (name, host, port). Sends heartbeats every 30s. Fetches the registry periodically to discover other services. Enables services to find dependencies dynamically without hardcoded IPs.",
            "hinglish": "Eureka Client ek library hai jo microservices mein add ki jaati hai. Startup par, ye service ko Eureka Server mein register karta hai (name, host, port). Har 30 seconds heartbeat bhejta hai. Periodically registry fetch karta hai taki dusre services discover kar sake. Services ko dependencies dynamically dhoondhne mein madad karta hai bina hardcoded IPs ke."
          },
          "code": {
            "title": "Service as Eureka Client",
            "language": "java",
            "content": "@SpringBootApplication\n@EnableDiscoveryClient\npublic class OrderServiceApplication { ... }\n\n# application.yml\nspring:\n  application:\n    name: order-service\nserver:\n  port: 0 # Random port for multiple instances\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka-server:8761/eureka/\n  instance:\n    prefer-ip-address: true"
          },
          "codeExplanations": {
            "english": "@EnableDiscoveryClient registers this app with Eureka. spring.application.name is the service ID used by others. port: 0 allows OS to assign random port (critical for running multiple instances locally). service-url points to Eureka Server. prefer-ip-address uses IP instead of hostname in registry.",
            "hinglish": "@EnableDiscoveryClient is app ko Eureka mein register karta hai. spring.application.name wo service ID hai jo dusre use karenge. port: 0 OS ko random port assign karne deta hai (multiple instances locally chalane ke liye zaroori). service-url Eureka Server ki location batata hai. prefer-ip-address registry mein hostname ki jagah IP use karta hai."
          },
          "keyPoints": [
            "Automatic registration on startup with health checks",
            "Registry cache refreshed every 30 seconds by default",
            "Service name (not IP) used for inter-service communication"
          ],
          "extras": {
            "flowDiagram": "",
            "comparisonTable": [],
            "examples": [
              "user-service registers as 'user-service' on ports 8081, 8082 ‚Üí Eureka shows two instances",
              "order-service queries Eureka for 'user-service' to get available instances"
            ]
          }
        },
        {
          "id": "service-discovery-client-side-load-balancing",
          "title": "‚öñÔ∏è Client-side Load Balancing",
          "explanations": {
            "english": "Client-side load balancing: The calling service (client) fetches the list of available instances from Eureka and selects one (using Ribbon or Spring Cloud LoadBalancer). Benefits: No single point of failure (unlike server-side LB), lower latency (client chooses closest instance), and smarter routing (zone-aware, weighted).",
            "hinglish": "Client-side load balancing: Calling service (client) Eureka se available instances ki list fetch karta hai aur ek select karta hai (Ribbon ya Spring Cloud LoadBalancer use karke). Fayde: Single point of failure nahi (server-side LB ke unlike), kam latency (client closest instance choose karta hai), aur smarter routing (zone-aware, weighted)."
          },
          "code": {
            "title": "Load-Balanced Feign Call",
            "language": "java",
            "content": "@FeignClient(name = \"inventory-service\")\npublic interface InventoryClient {\n    @GetMapping(\"/api/stock/{itemId}\")\n    StockLevel checkStock(@PathVariable(\"itemId\") String itemId);\n}\n\n// Behind the scenes:\n// 1. Fetch inventory-service instances from Eureka\n// 2. Apply load balancing strategy (round-robin by default)\n// 3. Call selected instance"
          },
          "codeExplanations": {
            "english": "FeignClient with service name (not URL) triggers client-side load balancing. Spring Cloud LoadBalancer (successor to Ribbon) fetches instances from Eureka cache, applies strategy (round-robin, random), and retries on failure. No extra code needed‚Äîannotation-driven.",
            "hinglish": "FeignClient mein service name (URL nahi) client-side load balancing trigger karta hai. Spring Cloud LoadBalancer (Ribbon ka successor) Eureka cache se instances fetch karta hai, strategy lagata hai (round-robin, random), aur failure par retry karta hai. Koi extra code ki zaroorat nahi‚Äîannotation-driven."
          },
          "keyPoints": [
            "Load balancing logic resides in the client service",
            "Strategies: Round-robin, random, weighted response time",
            "Integrates seamlessly with Feign, RestTemplate (@LoadBalanced)"
          ],
          "extras": {
            "flowDiagram": "Service A ‚Üí [Get instances: user-service] ‚Üí Eureka ‚Üí [Instance1, Instance2]\nService A ‚Üí [Choose Instance1 (round-robin)] ‚Üí Call Instance1",
            "comparisonTable": [
              {
                "column1": "Client-Side LB",
                "column2": "Server-Side LB (e.g., Nginx)"
              },
              {
                "column1": "Client chooses instance",
                "column2": "Proxy (Nginx) chooses instance"
              },
              {
                "column1": "No proxy hop ‚Üí lower latency",
                "column2": "Extra network hop"
              },
              {
                "column1": "Smarter per-client decisions",
                "column2": "Centralized control"
              }
            ],
            "examples": []
          }
        }
      ]
    },
    {
      "id": "containerization-orchestration",
      "title": "üê≥ Containerization & Orchestration",
      "intro": "Master packaging services into containers with Docker and managing them at scale using Kubernetes, including deployments, networking, and configuration management.",
      "topics": [
        {
          "id": "containerization-orchestration-docker",
          "title": "üê≥ Docker",
          "explanations": {
            "english": "Docker packages an application and its dependencies into a lightweight, isolated container. Containers share the host OS kernel but run in separate user spaces. Ensures consistency across environments (dev, test, prod). Key concepts: Images (blueprint), Containers (running instance), Dockerfile (build instructions).",
            "hinglish": "Docker application aur uske dependencies ko ek lightweight, isolated container mein pack karta hai. Containers host OS kernel ko share karte hain lekin alag user spaces mein chalte hain. Environments (dev, test, prod) mein consistency ensure karta hai. Key concepts: Images (blueprint), Containers (chalta hua instance), Dockerfile (build instructions)."
          },
          "code": {
            "title": "Dockerfile for Spring Boot App",
            "language": "dockerfile",
            "content": "FROM eclipse-temurin:17-jre-alpine\nWORKDIR /app\nCOPY target/order-service.jar app.jar\nEXPOSE 8080\nHEALTHCHECK --interval=30s --timeout=3s \\\n  CMD curl -f http://localhost:8080/actuator/health || exit 1\nENTRYPOINT [\"java\", \"-jar\", \"/app/app.jar\"]"
          },
          "codeExplanations": {
            "english": "Base image: Lightweight Java 17 JRE. Copies built JAR into container. EXPOSE documents port. HEALTHCHECK enables Docker/K8s to monitor app health. ENTRYPOINT defines startup command. Build with 'docker build -t order-service .', run with 'docker run -p 8080:8080 order-service'.",
            "hinglish": "Base image: Lightweight Java 17 JRE. Built JAR ko container mein copy karta hai. EXPOSE port batata hai. HEALTHCHECK Docker/K8s ko app health monitor karne mein madad karta hai. ENTRYPOINT startup command define karta hai. 'docker build -t order-service .' se build karein, 'docker run -p 8080:8080 order-service' se chalayein."
          },
          "keyPoints": [
            "Immutable images: Same artifact deployed everywhere",
            "Resource isolation: CPU/memory limits per container",
            "Layer caching speeds up builds and pulls"
          ],
          "extras": {
            "flowDiagram": "Code ‚Üí [Docker Build] ‚Üí Image ‚Üí [Docker Run] ‚Üí Container ‚Üí [Deploy] ‚Üí Host",
            "comparisonTable": [],
            "examples": [
              "docker build -t user-service:1.0 .",
              "docker run -d -p 8081:8080 --name user1 user-service:1.0"
            ]
          }
        },
        {
          "id": "containerization-orchestration-multi-stage-builds",
          "title": "üèóÔ∏è Multi-stage Builds",
          "explanations": {
            "english": "Multi-stage builds use multiple FROM statements in one Dockerfile. Early stages compile code (with build tools/Maven); later stages copy artifacts into a minimal runtime image. Result: Smaller, more secure images without build tools or source code. Critical for production containers.",
            "hinglish": "Multi-stage builds ek Dockerfile mein multiple FROM statements use karte hain. Pehle stages code compile karte hain (build tools/Maven ke saath); baad ke stages artifacts ko minimal runtime image mein copy karte hain. Result: Chhote, secure images bina build tools ya source code ke. Production containers ke liye zaroori."
          },
          "code": {
            "title": "Multi-stage Dockerfile",
            "language": "dockerfile",
            "content": "# Stage 1: Build\nFROM maven:3.8-openjdk-17 AS builder\nWORKDIR /build\nCOPY pom.xml .\nCOPY src ./src\nRUN mvn clean package -DskipTests\n\n# Stage 2: Runtime\nFROM eclipse-temurin:17-jre-alpine\nWORKDIR /app\nCOPY --from=builder /build/target/*.jar app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\", \"-jar\", \"/app/app.jar\"]"
          },
          "codeExplanations": {
            "english": "Builder stage uses Maven image to compile JAR. Runtime stage starts fresh with minimal JRE image. COPY --from=builder pulls only the JAR artifact. Final image size drops from ~500MB (with Maven) to ~150MB. No source code or Maven in final image.",
            "hinglish": "Builder stage Maven image use karke JAR compile karta hai. Runtime stage minimal JRE image se shuru karta hai. COPY --from=builder sirf JAR artifact lekar aata hai. Final image size ~500MB (Maven ke saath) se ghirkar ~150MB ho jata hai. Final image mein source code ya Maven nahi hota."
          },
          "keyPoints": [
            "Reduces image size by 60-80% compared to single-stage",
            "Improves security: No build tools/compiler in runtime image",
            "Build context isolated; only necessary artifacts copied"
          ],
          "extras": {
            "flowDiagram": "Stage 1 (Builder) ‚Üí [Compile Code] ‚Üí JAR Artifact\nStage 2 (Runtime) ‚Üí [Copy JAR] ‚Üí Minimal Image",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "containerization-orchestration-kubernetes",
          "title": "‚ò∏Ô∏è Kubernetes",
          "explanations": {
            "english": "Kubernetes (K8s) is an open-source platform for automating deployment, scaling, and management of containerized applications. Groups containers into Pods (smallest unit), manages them across a cluster of nodes. Handles self-healing (restart failed pods), service discovery, load balancing, and secrets/config management.",
            "hinglish": "Kubernetes (K8s) containerized applications ko deploy, scale aur manage karne ke liye ek open-source platform hai. Containers ko Pods mein group karta hai (smallest unit), cluster ke nodes par manage karta hai. Self-healing (failed pods restart karna), service discovery, load balancing, aur secrets/config management sambhalta hai."
          },
          "code": {
            "title": "",
            "language": "",
            "content": ""
          },
          "codeExplanations": {
            "english": "",
            "hinglish": ""
          },
          "keyPoints": [
            "Declarative configuration: Define desired state; K8s reconciles reality",
            "Self-healing: Restarts containers, replaces nodes, kills unhealthy pods",
            "Horizontal scaling: Scale pods up/down based on CPU or custom metrics"
          ],
          "extras": {
            "flowDiagram": "Developer ‚Üí [kubectl apply] ‚Üí K8s API Server ‚Üí etcd (state)\nScheduler ‚Üí [Assign Pod] ‚Üí Node ‚Üí kubelet ‚Üí Container Runtime",
            "comparisonTable": [],
            "examples": [
              "kubectl get pods ‚Üí Lists all running pods in namespace",
              "kubectl scale deployment user-service --replicas=5 ‚Üí Scales to 5 instances"
            ]
          }
        },
        {
          "id": "containerization-orchestration-deployments",
          "title": "üöÄ Deployments",
          "explanations": {
            "english": "Deployments manage stateless applications declaratively. Define desired pod template and replica count. Kubernetes ensures the specified number of pods run, handles rolling updates (zero-downtime), rollbacks, and self-healing. Preferred over bare Pods for production workloads.",
            "hinglish": "Deployments stateless applications ko declaratively manage karte hain. Desired pod template aur replica count define karein. Kubernetes ensure karta hai ki specified number ke pods chalein, rolling updates (zero-downtime), rollbacks aur self-healing handle karta hai. Production workloads ke liye bare Pods se behtar."
          },
          "code": {
            "title": "Deployment YAML",
            "language": "yaml",
            "content": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: order-service\n  template:\n    metadata:\n      labels:\n        app: order-service\n    spec:\n      containers:\n      - name: order-service\n        image: order-service:1.2.0\n        ports:\n        - containerPort: 8080\n        resources:\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /actuator/health\n            port: 8080\n          initialDelaySeconds: 60\n          periodSeconds: 10"
          },
          "codeExplanations": {
            "english": "Creates 3 identical pods labeled 'app: order-service'. Kubernetes scheduler places them across nodes. resources set CPU/memory limits. livenessProbe checks health; restarts container if failed. Update image version ‚Üí K8s does rolling update: replaces pods one-by-one without downtime.",
            "hinglish": "3 identical pods banata hai jinpar label 'app: order-service' hai. Kubernetes scheduler unhe nodes par distribute karta hai. resources CPU/memory limits set karte hain. livenessProbe health check karta hai; agar fail ho to container restart karta hai. Image version update karein ‚Üí K8s rolling update karta hai: bina downtime ke pods ek-ek karke replace karta hai."
          },
          "keyPoints": [
            "Rolling updates: Gradually replace old pods with new version",
            "Rollback: kubectl rollout undo reverts to previous version instantly",
            "Pod Disruption Budgets control max unavailable during updates"
          ],
          "extras": {
            "flowDiagram": "Update Deployment ‚Üí K8s creates new ReplicaSet ‚Üí [Scale up new pods] ‚Üí [Scale down old pods] ‚Üí Zero downtime",
            "comparisonTable": [],
            "examples": []
          }
        },
        {
          "id": "containerization-orchestration-services",
          "title": "üîå Services",
          "explanations": {
            "english": "Kubernetes Service is an abstraction defining a logical set of pods and a policy to access them. Provides stable IP/DNS name (e.g., order-service.default.svc.cluster.local) even as pods die/restart. Types: ClusterIP (internal), NodePort (external via node port), LoadBalancer (cloud LB). Enables service discovery and load balancing.",
            "hinglish": "Kubernetes Service ek abstraction hai jo pods ke logical set aur unhe access karne ki policy define karta hai. Stable IP/DNS name provide karta hai (jaise order-service.default.svc.cluster.local) bhale hi pods mar jaayein ya restart ho jaayein. Types: ClusterIP (internal), NodePort (external node port se), LoadBalancer (cloud LB). Service discovery aur load balancing enable karta hai."
          },
          "code": {
            "title": "Service YAML (ClusterIP)",
            "language": "yaml",
            "content": "apiVersion: v1\nkind: Service\nmetadata:\n  name: user-service\nspec:\n  selector:\n    app: user-service\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP"
          },
          "codeExplanations": {
            "english": "Service selects pods with label 'app: user-service'. Exposes port 80 internally; forwards traffic to pod port 8080. Other services call 'http://user-service' (DNS resolved by K8s). ClusterIP is default‚Äîonly accessible within cluster. For external access, use NodePort or LoadBalancer type.",
            "hinglish": "Service un pods ko select karta hai jinpar label 'app: user-service' hai. Internal port 80 expose karta hai; traffic ko pod ke port 8080 par forward karta hai. Dusre services 'http://user-service' call karte hain (DNS K8s ke dwara resolve hota hai). ClusterIP default hai‚Äîsirf cluster ke andar accessible. External access ke liye NodePort ya LoadBalancer type use karein."
          },
          "keyPoints": [
            "Stable endpoint decouples consumers from pod lifecycle",
            "Built-in load balancing across selected pods",
            "Headless Services (clusterIP: None) for direct pod access (stateful apps)"
          ],
          "extras": {
            "flowDiagram": "Pod A (user-service) ‚Üí [Service: user-service] ‚Üí [Load Balances] ‚Üí Pod B (user-service)\nPod C (order-service) ‚Üí Calls 'user-service' ‚Üí Service routes to healthy pod",
            "comparisonTable": [
              {
                "column1": "Service Type",
                "column2": "Use Case"
              },
              {
                "column1": "ClusterIP",
                "column2": "Internal communication between services"
              },
              {
                "column1": "NodePort",
                "column2": "Development/testing; external via :30000-32767"
              },
              {
                "column1": "LoadBalancer",
                "column2": "Production external traffic (cloud providers)"
              }
            ],
            "examples": []
          }
        },
        {
          "id": "containerization-orchestration-ingress",
          "title": "üö™ Ingress",
          "explanations": {
            "english": "Ingress is a Kubernetes resource that manages external HTTP/HTTPS access to services. Defines routing rules (host/path-based) to backend services. Requires an Ingress Controller (e.g., Nginx, Traefik) deployed in the cluster. Enables TLS termination, path rewriting, and centralized routing‚Äîreplaces multiple LoadBalancer services.",
            "hinglish": "Ingress ek Kubernetes resource hai jo services tak external HTTP/HTTPS access manage karta hai. Routing rules (host/path-based) backend services ke liye define karta hai. Cluster mein Ingress Controller (jaise Nginx, Traefik) deploy karna padta hai. TLS termination, path rewriting aur centralized routing enable karta hai‚Äîmultiple LoadBalancer services ko replace karta hai."
          },
          "code": {
            "title": "Ingress YAML",
            "language": "yaml",
            "content": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\nspec:\n  tls:\n  - hosts:\n      - api.example.com\n    secretName: tls-secret\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /users/(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80\n      - path: /orders/(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: order-service\n            port:\n              number: 80"
          },
          "codeExplanations": {
            "english": "Routes requests to api.example.com/users/* to user-service, /orders/* to order-service. TLS uses certificate from Kubernetes Secret 'tls-secret'. rewrite-target annotation strips path prefix before forwarding. Ingress Controller (Nginx) implements these rules as reverse proxy configuration.",
            "hinglish": "Requests ko api.example.com/users/* ko user-service par, /orders/* ko order-service par route karta hai. TLS Kubernetes Secret 'tls-secret' se certificate use karta hai. rewrite-target annotation forward karne se pehle path prefix hata deta hai. Ingress Controller (Nginx) in rules ko reverse proxy configuration ke roop mein implement karta hai."
          },
          "keyPoints": [
            "Single entry point for all HTTP traffic into cluster",
            "Path/host-based routing to multiple services",
            "Annotations enable advanced features (rate limiting, auth, CORS)"
          ],
          "extras": {
            "flowDiagram": "Internet ‚Üí [Ingress Controller (Nginx)] ‚Üí [Rule: /users/*] ‚Üí user-service\n                                      ‚Üí [Rule: /orders/*] ‚Üí order-service",
            "comparisonTable": [],
            "examples": [
              "Host-based: mobile.app.com ‚Üí mobile-service, web.app.com ‚Üí web-service",
              "Path-based: /api/v1/payments ‚Üí payment-service"
            ]
          }
        },
        {
          "id": "containerization-orchestration-configmaps",
          "title": "‚öôÔ∏è ConfigMaps",
          "explanations": {
            "english": "ConfigMaps store non-confidential configuration data (properties, JSON, env vars) decoupled from container images. Injected into pods as environment variables, command-line args, or config files. Enables environment-specific configs (dev/staging/prod) without rebuilding images. Changes require pod restart or use of tools like Reloader.",
            "hinglish": "ConfigMaps non-confidential configuration data (properties, JSON, env vars) ko container images se alag store karte hain. Pods mein environment variables, command-line args ya config files ke roop mein inject kiye jaate hain. Environment-specific configs (dev/staging/prod) enable karte hain bina images rebuild kiye. Changes ke liye pod restart ki zaroorat hoti hai ya Reloader jaise tools use karte hain."
          },
          "code": {
            "title": "ConfigMap & Pod Injection",
            "language": "yaml",
            "content": "# ConfigMap\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  APP_ENV: \"production\"\n  LOG_LEVEL: \"INFO\"\n  DATABASE_URL: \"jdbc:postgresql://db-host:5432/orders\"\n\n# Pod using ConfigMap\nenv:\n  - name: LOG_LEVEL\n    valueFrom:\n      configMapKeyRef:\n        name: app-config\n        key: LOG_LEVEL\nvolumeMounts:\n  - name: config-volume\n    mountPath: /etc/config\nvolumes:\n  - name: config-volume\n    configMap:\n      name: app-config"
          },
          "codeExplanations": {
            "english": "ConfigMap 'app-config' holds key-value pairs. In pod spec, env injects LOG_LEVEL as environment variable. volumeMounts mounts all ConfigMap keys as files in /etc/config (e.g., /etc/config/DATABASE_URL). Spring Boot apps can load configs from mounted files or env vars.",
            "hinglish": "ConfigMap 'app-config' key-value pairs rakhta hai. Pod spec mein, env LOG_LEVEL ko environment variable ke roop mein inject karta hai. volumeMounts ConfigMap ke saare keys ko /etc/config mein files ke roop mein mount karta hai (jaise /etc/config/DATABASE_URL). Spring Boot apps mounted files ya env vars se configs load kar sakte hain."
          },
          "keyPoints": [
            "Separate config from code (12-factor app principle)",
            "Update configs without rebuilding container images",
            "Use Secrets (not ConfigMaps) for passwords, tokens, TLS certs"
          ],
          "extras": {
            "flowDiagram": "ConfigMap ‚Üí [Injected as] ‚Üí Env Vars / Config Files ‚Üí Application reads config",
            "comparisonTable": [
              {
                "column1": "ConfigMap",
                "column2": "Secret"
              },
              {
                "column1": "Non-sensitive data (URLs, flags)",
                "column2": "Sensitive data (passwords, tokens)"
              },
              {
                "column1": "Stored as plaintext in etcd",
                "column2": "Base64-encoded (still not encrypted at rest)"
              },
              {
                "column1": "Mounted as files or env vars",
                "column2": "Same injection methods; requires extra care"
              }
            ],
            "examples": [
              "Database connection strings per environment",
              "Feature flags to enable/disable functionality at runtime"
            ]
          }
        }
      ]
    },
    {
      "id": "spring-boot-microservices",
      "title": "üå± Spring Boot in Microservices",
      "intro": "Leverage Spring Boot and Spring Cloud to implement observability, resilience, and cloud-native patterns critical for production-grade microservices.",
      "topics": [
        {
          "id": "spring-boot-microservices-spring-boot",
          "title": "‚ö° Spring Boot",
          "explanations": {
            "english": "Spring Boot simplifies microservice development with auto-configuration, embedded servers (Tomcat), and production-ready features (Actuator). Starters (spring-boot-starter-web) bundle dependencies. Convention over configuration reduces boilerplate. Ideal for creating standalone, container-friendly services with minimal setup.",
            "hinglish": "Spring Boot auto-configuration, embedded servers (Tomcat) aur production-ready features (Actuator) ke saath microservice development ko aasan karta hai. Starters (spring-boot-starter-web) dependencies bundle karte hain. Convention over configuration boilerplate kam karta hai. Minimal setup ke saath standalone, container-friendly services banane ke liye perfect."
          },
          "code": {
            "title": "Minimal Spring Boot Service",
            "language": "java",
            "content": "@SpringBootApplication\npublic class PaymentServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentServiceApplication.class, args);\n    }\n}\n\n@RestController\nclass HealthController {\n    @GetMapping(\"/actuator/health\")\n    public String health() { return \"{\\\"status\\\":\\\"UP\\\"}\"; }\n}"
          },
          "codeExplanations": {
            "english": "@SpringBootApplication combines configuration, component scan, and auto-config. Embedded Tomcat starts on port 8080. Actuator endpoint provides health check. Add spring-boot-starter-actuator dependency for built-in endpoints (metrics, env, logs). application.properties configures server port, logging, etc.",
            "hinglish": "@SpringBootApplication configuration, component scan aur auto-config ko jodta hai. Embedded Tomcat port 8080 par shuru hota hai. Actuator endpoint health check deta hai. Built-in endpoints (metrics, env, logs) ke liye spring-boot-starter-actuator dependency add karein. application.properties server port, logging, etc. configure karta hai."
          },
          "keyPoints": [
            "Embedded server: No external deployment needed",
            "Actuator: Production monitoring endpoints out-of-the-box",
            "Profiles: Environment-specific configs (application-dev.properties)"
          ],
          "extras": {
            "flowDiagram": "Code + Dependencies ‚Üí [Spring Boot Maven Plugin] ‚Üí Executable JAR ‚Üí [java -jar] ‚Üí Runs with embedded server",
            "comparisonTable": [],
            "examples": [
              "mvn spring-boot:run ‚Üí Starts app in dev mode",
              "java -jar payment-service.jar --spring.profiles.active=prod"
            ]
          }
        },
        {
          "id": "spring-boot-microservices-spring-cloud",
          "title": "‚òÅÔ∏è Spring Cloud",
          "explanations": {
            "english": "Spring Cloud provides tools for building distributed systems: Service Discovery (Eureka), Config Server, API Gateway, Circuit Breaker, and more. Integrates with Spring Boot via starters (spring-cloud-starter-netflix-eureka-client). Abstracts complexity of distributed patterns‚Äîdevelopers focus on business logic.",
            "hinglish": "Spring Cloud distributed systems banane ke liye tools provide karta hai: Service Discovery (Eureka), Config Server, API Gateway, Circuit Breaker, aur bhi. Spring Boot ke saath starters (spring-cloud-starter-netflix-eureka-client) ke zariye integrate karta hai. Distributed patterns ki complexity ko chhupata hai‚Äîdevelopers business logic par focus kar sakte hain."
          },
          "code": {
            "title": "Spring Cloud Dependencies (pom.xml)",
            "language": "xml",
            "content": "<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>2022.0.0</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>\n    </dependency>\n</dependencies>"
          },
          "codeExplanations": {
            "english": "dependencyManagement imports Spring Cloud BOM (Bill of Materials) for version alignment. Starter dependencies pull in required libraries (Eureka client, Resilience4j). Spring Boot auto-configures beans based on classpath presence‚Äîno XML needed. Use @EnableCircuitBreaker or functional patterns for resilience.",
            "hinglish": "dependencyManagement Spring Cloud BOM (Bill of Materials) version alignment ke liye import karta hai. Starter dependencies required libraries (Eureka client, Resilience4j) lekar aate hain. Spring Boot classpath ke hisaab se beans auto-configure karta hai‚ÄîXML ki zaroorat nahi. Resilience ke liye @EnableCircuitBreaker ya functional patterns use karein."
          },
          "keyPoints": [
            "Starters simplify dependency management for cloud patterns",
            "Auto-configuration activates features when dependencies detected",
            "Works with multiple service meshes and registries (Consul, Zookeeper)"
          ],
          "extras": {
            "flowDiagram": "Spring Boot App + Spring Cloud Starters ‚Üí [Auto-config] ‚Üí Integrated with Eureka, Config Server, Gateway",
            "comparisonTable": [],
            "examples": [
              "Config Server: Centralized config management with Git backend",
              "Sleuth + Zipkin: Distributed tracing across services"
            ]
          }
        },
        {
          "id": "spring-boot-microservices-observability",
          "title": "üëÄ Observability",
          "explanations": {
            "english": "Observability = Logs + Metrics + Traces. Logs: Structured JSON logs shipped to ELK/Splunk. Metrics: Micrometer exposes counters, timers to Prometheus. Traces: Spring Cloud Sleuth injects trace/span IDs; Zipkin visualizes request flows across services. Critical for debugging distributed transactions and performance bottlenecks.",
            "hinglish": "Observability = Logs + Metrics + Traces. Logs: Structured JSON logs ELK/Splunk mein bheje jaate hain. Metrics: Micrometer counters, timers ko Prometheus mein expose karta hai. Traces: Spring Cloud Sleuth trace/span IDs inject karta hai; Zipkin services ke beech request flows visualize karta hai. Distributed transactions aur performance bottlenecks debug karne ke liye zaroori."
          },
          "code": {
            "title": "Micrometer Metrics & Sleuth Trace",
            "language": "java",
            "content": "// application.yml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,metrics,prometheus\n  metrics:\n    tags:\n      application: ${spring.application.name}\n\n// In service code\n@Autowired\nprivate MeterRegistry meterRegistry;\n\npublic Order createOrder(OrderRequest req) {\n    Timer.Sample sample = Timer.start(meterRegistry);\n    try {\n        Order order = orderService.process(req);\n        sample.stop(meterRegistry.timer(\"order.processing.time\"));\n        return order;\n    } catch (Exception e) {\n        Counter.builder(\"order.failures\").register(meterRegistry).increment();\n        throw e;\n    }\n}"
          },
          "codeExplanations": {
            "english": "Micrometer auto-exposes metrics at /actuator/prometheus. Timer measures order processing duration; Counter tracks failures. Sleuth auto-injects X-B3-TraceId headers in HTTP calls. Zipkin collects spans to show full request path (e.g., API Gateway ‚Üí User Service ‚Üí Order Service).",
            "hinglish": "Micrometer metrics ko /actuator/prometheus par auto-expose karta hai. Timer order processing duration measure karta hai; Counter failures track karta hai. Sleuth HTTP calls mein X-B3-TraceId headers auto-inject karta hai. Zipkin spans collect karke full request path dikhata hai (jaise API Gateway ‚Üí User Service ‚Üí Order Service)."
          },
          "keyPoints": [
            "Distributed tracing correlates logs across service boundaries",
            "Metrics dashboards (Grafana) show SLOs, error rates, latency",
            "Structured logging (JSON) enables efficient log aggregation"
          ],
          "extras": {
            "flowDiagram": "Service A ‚Üí [Trace ID injected] ‚Üí Service B ‚Üí [Logs + Metrics] ‚Üí Aggregator (Prometheus/ELK) ‚Üí Dashboard (Grafana/Kibana)",
            "comparisonTable": [],
            "examples": [
              "Trace ID in logs: [traceId=abc123, spanId=xyz789] ‚Üí Search all logs for abc123",
              "Alert: Error rate > 1% for payment-service in last 5 minutes"
            ]
          }
        },
        {
          "id": "spring-boot-microservices-resilience",
          "title": "üõ°Ô∏è Resilience",
          "explanations": {
            "english": "Resilience patterns prevent cascading failures in distributed systems. Circuit Breaker (Resilience4j): Stops calling failing service after threshold, fails fast. Retry: Auto-retry transient failures with backoff. Bulkhead: Limits concurrent calls to isolate failures. Timeout: Fails fast on slow responses. Critical for maintaining system stability.",
            "hinglish": "Resilience patterns distributed systems mein cascading failures ko roktein hain. Circuit Breaker (Resilience4j): Threshold ke baad failing service ko call karna band kar deta hai, turant fail karta hai. Retry: Transient failures par auto-retry backoff ke saath. Bulkhead: Concurrent calls ko limit karke failures ko isolate karta hai. Timeout: Slow responses par turant fail karta hai. System stability ke liye zaroori."
          },
          "code": {
            "title": "Resilience4j Circuit Breaker",
            "language": "java",
            "content": "@Service\npublic class InventoryService {\n    \n    @CircuitBreaker(name = \"inventoryService\", fallbackMethod = \"getDefaultStock\")\n    @Retry(name = \"inventoryService\", fallbackMethod = \"getDefaultStock\")\n    @RateLimiter(name = \"inventoryService\")\n    public StockLevel checkStock(String itemId) {\n        return inventoryClient.getStock(itemId); // Feign call\n    }\n    \n    private StockLevel getDefaultStock(String itemId, Exception e) {\n        log.warn(\"Using fallback for item {}\", itemId, e);\n        return new StockLevel().setAvailable(0).setFallback(true);\n    }\n}"
          },
          "codeExplanations": {
            "english": "Annotations apply resilience patterns declaratively. CircuitBreaker opens after failures (configurable), calls fallback. Retry attempts failed calls with exponential backoff. RateLimiter limits calls/sec. Fallback method provides safe default. Configured via application.yml (failure rate threshold, wait duration).",
            "hinglish": "Annotations resilience patterns ko declaratively lagate hain. CircuitBreaker failures ke baad open ho jata hai (configure kiya ja sakta hai), fallback call karta hai. Retry exponential backoff ke saath failed calls retry karta hai. RateLimiter calls/sec limit karta hai. Fallback method safe default deta hai. application.yml mein configure kiya jaata hai (failure rate threshold, wait duration)."
          },
          "keyPoints": [
            "Fail fast: Avoid blocking threads on unresponsive services",
            "Fallbacks provide degraded but functional experience",
            "Metrics track circuit state (closed/half-open/open) for alerts"
          ],
          "extras": {
            "flowDiagram": "Call Service ‚Üí [Circuit Closed?] ‚Üí Yes ‚Üí [Call] ‚Üí Success? ‚Üí Yes ‚Üí Return\n                                      ‚Üì No                ‚Üì No\n                                [Open Circuit]      [Retry?] ‚Üí Yes ‚Üí Retry (max 3x)\n                                      ‚Üì                          ‚Üì No\n                                Return Fallback              Open Circuit",
            "comparisonTable": [],
            "examples": [
              "Payment service circuit opens after 5 failures ‚Üí returns 'payment pending' fallback",
              "Retry with 100ms, 200ms, 400ms backoff for temporary network glitches"
            ]
          }
        },
        {
          "id": "spring-boot-microservices-cloud-native-patterns",
          "title": "üåÄ Cloud-Native Patterns",
          "explanations": {
            "english": "Cloud-native patterns optimize for dynamic environments: Externalized Configuration (Config Server), Health Checks (Actuator), Anti-Corruption Layer (translate between bounded contexts), Saga Pattern (distributed transactions via events). Embrace statelessness, immutability, and automation for scalability and resilience.",
            "hinglish": "Cloud-native patterns dynamic environments ke liye optimize karte hain: Externalized Configuration (Config Server), Health Checks (Actuator), Anti-Corruption Layer (bounded contexts ke beech translate karna), Saga Pattern (events ke zariye distributed transactions). Scalability aur resilience ke liye statelessness, immutability aur automation ko apnayein."
          },
          "code": {
            "title": "Saga Pattern with Events",
            "language": "java",
            "content": "// Order Service\n@PostMapping(\"/orders\")\npublic ResponseEntity<Order> createOrder(@RequestBody OrderRequest req) {\n    Order order = orderRepository.save(new Order(req));\n    // Publish event\n    eventPublisher.publishEvent(new OrderCreatedEvent(order.getId()));\n    return ResponseEntity.ok(order);\n}\n\n// Inventory Service Listener\n@EventListener\npublic void handleOrderCreated(OrderCreatedEvent event) {\n    try {\n        inventoryService.reserveStock(event.getOrderId());\n        eventPublisher.publishEvent(new StockReservedEvent(event.getOrderId()));\n    } catch (InsufficientStockException e) {\n        eventPublisher.publishEvent(new StockReservationFailedEvent(event.getOrderId()));\n    }\n}"
          },
          "codeExplanations": {
            "english": "Saga coordinates distributed transaction via events. Order service creates order and publishes OrderCreatedEvent. Inventory service reserves stock and publishes success/failure event. Compensating actions (e.g., cancel order) triggered on failure. Avoids distributed locks; eventual consistency.",
            "hinglish": "Saga events ke zariye distributed transaction coordinate karta hai. Order service order banata hai aur OrderCreatedEvent publish karta hai. Inventory service stock reserve karta hai aur success/failure event publish karta hai. Failure par compensating actions (jaise order cancel karna) trigger hote hain. Distributed locks se bachata hai; eventual consistency follow karta hai."
          },
          "keyPoints": [
            "Saga Pattern: Break transactions into local transactions with compensating actions",
            "Anti-Corruption Layer: Adapter between services with different domain models",
            "Health checks enable smart load balancing and self-healing"
          ],
          "extras": {
            "flowDiagram": "Order Created ‚Üí [Event] ‚Üí Reserve Stock ‚Üí [Success Event] ‚Üí Process Payment\n                                      ‚Üì [Failure Event]\n                                Cancel Order (Compensating Action)",
            "comparisonTable": [
              {
                "column1": "Pattern",
                "column2": "Purpose"
              },
              {
                "column1": "Saga",
                "column2": "Distributed transactions without 2PC"
              },
              {
                "column1": "Anti-Corruption Layer",
                "column2": "Translate between bounded contexts"
              },
              {
                "column1": "Strangler Fig",
                "column2": "Incrementally migrate monolith to microservices"
              }
            ],
            "examples": [
              "E-commerce checkout saga: Create order ‚Üí Reserve stock ‚Üí Charge payment ‚Üí Ship",
              "If payment fails: Cancel order, release stock (compensating actions)"
            ]
          }
        }
      ]
    }
  ]
}
]